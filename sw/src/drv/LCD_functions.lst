   1               		.file	"LCD_functions.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.LCD_puts_f,"ax",@progbits
  11               	.global	LCD_puts_f
  13               	LCD_puts_f:
  14               	.LFB1:
  15               		.file 1 "src/drv/LCD_functions.c"
   1:src/drv/LCD_functions.c **** //*****************************************************************************
   2:src/drv/LCD_functions.c **** //
   3:src/drv/LCD_functions.c **** //  File........: LCD_functions.c
   4:src/drv/LCD_functions.c **** //
   5:src/drv/LCD_functions.c **** //  Author(s)...: ATMEL Norway
   6:src/drv/LCD_functions.c **** //
   7:src/drv/LCD_functions.c **** //  Target(s)...: ATmega169
   8:src/drv/LCD_functions.c **** //
   9:src/drv/LCD_functions.c **** //  Compiler....: AVR-GCC 4.1.1; avr-libc 1.4.5
  10:src/drv/LCD_functions.c **** //
  11:src/drv/LCD_functions.c **** //  Description.: Additional LCD functions, scrolling text and write data
  12:src/drv/LCD_functions.c **** //
  13:src/drv/LCD_functions.c **** //  Revisions...: 1.0
  14:src/drv/LCD_functions.c **** //
  15:src/drv/LCD_functions.c **** //  YYYYMMDD - VER. - COMMENT                                       - SIGN.
  16:src/drv/LCD_functions.c **** //
  17:src/drv/LCD_functions.c **** //  20021015 - 1.0  - Created                                       - LHM
  18:src/drv/LCD_functions.c **** //  20030116 - 2.0  - Code adapted to AVR Butterflyup               - KS
  19:src/drv/LCD_functions.c **** //  20031009          port to avr-gcc/avr-libc                      - M.Thomas
  20:src/drv/LCD_functions.c **** //  20070131          gLCD_Start_Scroll_Timer volatile              - mt
  21:src/drv/LCD_functions.c **** //  20070517          LCDClear: gTextBuffer[0] to 0-char            - mt
  22:src/drv/LCD_functions.c **** //  20091217          LCDClear: gTextBuffer[TEXTBUFFER_SIZE]='\0'   - M. Loeffler
  23:src/drv/LCD_functions.c **** //*****************************************************************************
  24:src/drv/LCD_functions.c **** 
  25:src/drv/LCD_functions.c **** //  Include files
  26:src/drv/LCD_functions.c **** #include <stdint.h>
  27:src/drv/LCD_functions.c **** #include <avr/io.h>
  28:src/drv/LCD_functions.c **** #include <avr/pgmspace.h>
  29:src/drv/LCD_functions.c **** #include "LCD_driver.h"
  30:src/drv/LCD_functions.c **** #include "LCD_functions.h"
  31:src/drv/LCD_functions.c **** #include "BCD.h"
  32:src/drv/LCD_functions.c **** // mt only for KEY_* and ST_OPTIONS_DISPLAY* definitions:
  33:src/drv/LCD_functions.c **** #include "main.h"
  34:src/drv/LCD_functions.c **** #include "button.h"
  35:src/drv/LCD_functions.c **** 
  36:src/drv/LCD_functions.c **** 
  37:src/drv/LCD_functions.c **** #define FALSE   0
  38:src/drv/LCD_functions.c **** #define TRUE    (!FALSE)
  39:src/drv/LCD_functions.c **** 
  40:src/drv/LCD_functions.c **** // mt char CONTRAST = LCD_INITIAL_CONTRAST;
  41:src/drv/LCD_functions.c **** uint8_t CONTRAST = LCD_INITIAL_CONTRAST;
  42:src/drv/LCD_functions.c **** 
  43:src/drv/LCD_functions.c **** // Start-up delay before scrolling a string over the LCD. "LCD_driver.c"
  44:src/drv/LCD_functions.c **** extern volatile char gLCD_Start_Scroll_Timer;
  45:src/drv/LCD_functions.c **** 
  46:src/drv/LCD_functions.c **** /****************************************************************************
  47:src/drv/LCD_functions.c **** *
  48:src/drv/LCD_functions.c **** *	Function name : LCD_puts_f
  49:src/drv/LCD_functions.c **** *
  50:src/drv/LCD_functions.c **** *	Returns :		None
  51:src/drv/LCD_functions.c **** *
  52:src/drv/LCD_functions.c **** *	Parameters :	pFlashStr: Pointer to the string in flash
  53:src/drv/LCD_functions.c **** *					scrollmode: Not in use
  54:src/drv/LCD_functions.c **** *
  55:src/drv/LCD_functions.c **** *	Purpose :		Writes a string stored in flash to the LCD
  56:src/drv/LCD_functions.c **** *
  57:src/drv/LCD_functions.c **** *****************************************************************************/
  58:src/drv/LCD_functions.c **** 
  59:src/drv/LCD_functions.c **** // mt void LCD_puts_f(char __flash *pFlashStr, char scrollmode)
  60:src/drv/LCD_functions.c **** void LCD_puts_f(const char *pFlashStr, char scrollmode)
  61:src/drv/LCD_functions.c **** {
  16               		.loc 1 61 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23 0000 AC01      		movw r20,r24
  24               	.LVL1:
  25               	.L2:
  62:src/drv/LCD_functions.c ****     uint8_t i;
  63:src/drv/LCD_functions.c **** 
  64:src/drv/LCD_functions.c ****     scrollmode = scrollmode; // 200907, avoid warning
  65:src/drv/LCD_functions.c **** 
  66:src/drv/LCD_functions.c ****     while (gLCD_Update_Required);      // Wait for access to buffer
  26               		.loc 1 66 0 discriminator 1
  27 0002 8091 0000 		lds r24,gLCD_Update_Required
  28 0006 8111      		cpse r24,__zero_reg__
  29 0008 00C0      		rjmp .L2
  30 000a 20E0      		ldi r18,0
  31 000c 30E0      		ldi r19,0
  32               	.L3:
  33 000e 922F      		mov r25,r18
  34               	.LVL2:
  35 0010 FA01      		movw r30,r20
  36 0012 E20F      		add r30,r18
  37 0014 F31F      		adc r31,r19
  38               	.LVL3:
  39               	.LBB2:
  67:src/drv/LCD_functions.c **** 
  68:src/drv/LCD_functions.c ****     // mt: for (i = 0; pFlashStr[i] && i < TEXTBUFFER_SIZE; i++)
  69:src/drv/LCD_functions.c ****     for (i = 0; (const char)(pgm_read_byte(&pFlashStr[i])) && i < TEXTBUFFER_SIZE; i++)
  40               		.loc 1 69 0 discriminator 1
  41               	/* #APP */
  42               	 ;  69 "src/drv/LCD_functions.c" 1
  43 0016 8491      		lpm r24, Z
  44               		
  45               	 ;  0 "" 2
  46               	.LVL4:
  47               	/* #NOAPP */
  48               	.LBE2:
  49 0018 8823      		tst r24
  50 001a 01F0      		breq .L4
  51               		.loc 1 69 0 is_stmt 0 discriminator 3
  52 001c 2931      		cpi r18,25
  53 001e 3105      		cpc r19,__zero_reg__
  54 0020 01F0      		breq .L13
  55               	.LVL5:
  56               	.LBB3:
  70:src/drv/LCD_functions.c ****     {
  71:src/drv/LCD_functions.c ****         // mt: gTextBuffer[i] = pFlashStr[i];
  72:src/drv/LCD_functions.c ****         gTextBuffer[i] = pgm_read_byte(&pFlashStr[i]);
  57               		.loc 1 72 0 is_stmt 1 discriminator 4
  58               	/* #APP */
  59               	 ;  72 "src/drv/LCD_functions.c" 1
  60 0022 E491      		lpm r30, Z
  61               		
  62               	 ;  0 "" 2
  63               	.LVL6:
  64               	/* #NOAPP */
  65               	.LBE3:
  66 0024 D901      		movw r26,r18
  67 0026 A050      		subi r26,lo8(-(gTextBuffer))
  68 0028 B040      		sbci r27,hi8(-(gTextBuffer))
  69 002a EC93      		st X,r30
  70               	.LVL7:
  71 002c 2F5F      		subi r18,-1
  72 002e 3F4F      		sbci r19,-1
  73               	.LVL8:
  74 0030 00C0      		rjmp .L3
  75               	.LVL9:
  76               	.L13:
  77 0032 99E1      		ldi r25,lo8(25)
  78               	.L4:
  73:src/drv/LCD_functions.c ****     }
  74:src/drv/LCD_functions.c **** 
  75:src/drv/LCD_functions.c ****     gTextBuffer[i] = '\0';
  79               		.loc 1 75 0
  80 0034 E92F      		mov r30,r25
  81               	.LVL10:
  82 0036 F0E0      		ldi r31,0
  83 0038 E050      		subi r30,lo8(-(gTextBuffer))
  84 003a F040      		sbci r31,hi8(-(gTextBuffer))
  85 003c 1082      		st Z,__zero_reg__
  76:src/drv/LCD_functions.c **** 
  77:src/drv/LCD_functions.c ****     if (i > 6)
  86               		.loc 1 77 0
  87 003e 9730      		cpi r25,lo8(7)
  88 0040 00F0      		brlo .L6
  78:src/drv/LCD_functions.c ****     {
  79:src/drv/LCD_functions.c ****         gScrollMode = 1;        // Scroll if text is longer than display size
  89               		.loc 1 79 0
  90 0042 81E0      		ldi r24,lo8(1)
  91               	.LVL11:
  92 0044 8093 0000 		sts gScrollMode,r24
  80:src/drv/LCD_functions.c ****         gScroll = 0;
  93               		.loc 1 80 0
  94 0048 1092 0000 		sts gScroll,__zero_reg__
  81:src/drv/LCD_functions.c ****         gLCD_Start_Scroll_Timer = 3;    //Start-up delay before scrolling the text
  95               		.loc 1 81 0
  96 004c 83E0      		ldi r24,lo8(3)
  97 004e 8093 0000 		sts gLCD_Start_Scroll_Timer,r24
  98 0052 00C0      		rjmp .L7
  99               	.LVL12:
 100               	.L6:
  82:src/drv/LCD_functions.c ****     }
  83:src/drv/LCD_functions.c ****     else
  84:src/drv/LCD_functions.c ****     {
  85:src/drv/LCD_functions.c ****         gScrollMode = 0;        
 101               		.loc 1 85 0
 102 0054 1092 0000 		sts gScrollMode,__zero_reg__
  86:src/drv/LCD_functions.c ****         gScroll = 0;
 103               		.loc 1 86 0
 104 0058 1092 0000 		sts gScroll,__zero_reg__
 105               	.LVL13:
 106               	.L7:
  87:src/drv/LCD_functions.c ****     }
  88:src/drv/LCD_functions.c **** 
  89:src/drv/LCD_functions.c ****     gLCD_Update_Required = 1;
 107               		.loc 1 89 0
 108 005c 81E0      		ldi r24,lo8(1)
 109 005e 8093 0000 		sts gLCD_Update_Required,r24
 110 0062 0895      		ret
 111               		.cfi_endproc
 112               	.LFE1:
 114               		.section	.text.LCD_puts,"ax",@progbits
 115               	.global	LCD_puts
 117               	LCD_puts:
 118               	.LFB2:
  90:src/drv/LCD_functions.c **** }
  91:src/drv/LCD_functions.c **** 
  92:src/drv/LCD_functions.c **** 
  93:src/drv/LCD_functions.c **** /****************************************************************************
  94:src/drv/LCD_functions.c **** *
  95:src/drv/LCD_functions.c **** *	Function name : LCD_puts
  96:src/drv/LCD_functions.c **** *
  97:src/drv/LCD_functions.c **** *	Returns :		None
  98:src/drv/LCD_functions.c **** *
  99:src/drv/LCD_functions.c **** *	Parameters :	pStr: Pointer to the string
 100:src/drv/LCD_functions.c **** *					scrollmode: Not in use
 101:src/drv/LCD_functions.c **** *
 102:src/drv/LCD_functions.c **** *	Purpose :		Writes a string to the LCD
 103:src/drv/LCD_functions.c **** *
 104:src/drv/LCD_functions.c **** *****************************************************************************/
 105:src/drv/LCD_functions.c **** void LCD_puts(char *pStr, char scrollmode)
 106:src/drv/LCD_functions.c **** {
 119               		.loc 1 106 0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               	.LVL14:
 126               	.L15:
 107:src/drv/LCD_functions.c ****     uint8_t i; // char i;
 108:src/drv/LCD_functions.c **** 
 109:src/drv/LCD_functions.c ****     scrollmode = scrollmode; // 200907, avoid warning
 110:src/drv/LCD_functions.c **** 
 111:src/drv/LCD_functions.c ****     while (gLCD_Update_Required);      // Wait for access to buffer
 127               		.loc 1 111 0 discriminator 1
 128 0000 2091 0000 		lds r18,gLCD_Update_Required
 129 0004 2111      		cpse r18,__zero_reg__
 130 0006 00C0      		rjmp .L15
 131 0008 FC01      		movw r30,r24
 132               		.loc 1 111 0 is_stmt 0
 133 000a 20E0      		ldi r18,0
 134 000c 30E0      		ldi r19,0
 135               	.LVL15:
 136               	.L16:
 137 000e 822F      		mov r24,r18
 138               	.LVL16:
 112:src/drv/LCD_functions.c **** 
 113:src/drv/LCD_functions.c ****     for (i = 0; pStr[i] && i < TEXTBUFFER_SIZE; i++)
 139               		.loc 1 113 0 is_stmt 1 discriminator 1
 140 0010 9191      		ld r25,Z+
 141 0012 9923      		tst r25
 142 0014 01F0      		breq .L17
 143               		.loc 1 113 0 is_stmt 0 discriminator 3
 144 0016 2931      		cpi r18,25
 145 0018 3105      		cpc r19,__zero_reg__
 146 001a 01F0      		breq .L25
 114:src/drv/LCD_functions.c ****     {
 115:src/drv/LCD_functions.c ****         gTextBuffer[i] = pStr[i];
 147               		.loc 1 115 0 is_stmt 1 discriminator 4
 148 001c D901      		movw r26,r18
 149 001e A050      		subi r26,lo8(-(gTextBuffer))
 150 0020 B040      		sbci r27,hi8(-(gTextBuffer))
 151 0022 9C93      		st X,r25
 152               	.LVL17:
 153 0024 2F5F      		subi r18,-1
 154 0026 3F4F      		sbci r19,-1
 155               	.LVL18:
 156 0028 00C0      		rjmp .L16
 157               	.L25:
 158 002a 89E1      		ldi r24,lo8(25)
 159               	.L17:
 116:src/drv/LCD_functions.c ****     }
 117:src/drv/LCD_functions.c **** 
 118:src/drv/LCD_functions.c ****     gTextBuffer[i] = '\0';
 160               		.loc 1 118 0
 161 002c E82F      		mov r30,r24
 162 002e F0E0      		ldi r31,0
 163 0030 E050      		subi r30,lo8(-(gTextBuffer))
 164 0032 F040      		sbci r31,hi8(-(gTextBuffer))
 165 0034 1082      		st Z,__zero_reg__
 119:src/drv/LCD_functions.c **** 
 120:src/drv/LCD_functions.c ****     if (i > 6)
 166               		.loc 1 120 0
 167 0036 8730      		cpi r24,lo8(7)
 168 0038 00F0      		brlo .L19
 121:src/drv/LCD_functions.c ****     {
 122:src/drv/LCD_functions.c ****         gScrollMode = 1;        // Scroll if text is longer than display size
 169               		.loc 1 122 0
 170 003a 81E0      		ldi r24,lo8(1)
 171 003c 8093 0000 		sts gScrollMode,r24
 123:src/drv/LCD_functions.c ****         gScroll = 0;
 172               		.loc 1 123 0
 173 0040 1092 0000 		sts gScroll,__zero_reg__
 124:src/drv/LCD_functions.c ****         gLCD_Start_Scroll_Timer = 3;    //Start-up delay before scrolling the text
 174               		.loc 1 124 0
 175 0044 83E0      		ldi r24,lo8(3)
 176 0046 8093 0000 		sts gLCD_Start_Scroll_Timer,r24
 177 004a 00C0      		rjmp .L20
 178               	.L19:
 125:src/drv/LCD_functions.c ****     }
 126:src/drv/LCD_functions.c ****     else
 127:src/drv/LCD_functions.c ****     {
 128:src/drv/LCD_functions.c ****         gScrollMode = 0;        
 179               		.loc 1 128 0
 180 004c 1092 0000 		sts gScrollMode,__zero_reg__
 129:src/drv/LCD_functions.c ****         gScroll = 0;
 181               		.loc 1 129 0
 182 0050 1092 0000 		sts gScroll,__zero_reg__
 183               	.L20:
 130:src/drv/LCD_functions.c ****     }
 131:src/drv/LCD_functions.c **** 
 132:src/drv/LCD_functions.c ****     gLCD_Update_Required = 1;
 184               		.loc 1 132 0
 185 0054 81E0      		ldi r24,lo8(1)
 186 0056 8093 0000 		sts gLCD_Update_Required,r24
 187 005a 0895      		ret
 188               		.cfi_endproc
 189               	.LFE2:
 191               		.section	.text.LCD_putc,"ax",@progbits
 192               	.global	LCD_putc
 194               	LCD_putc:
 195               	.LFB3:
 133:src/drv/LCD_functions.c **** }
 134:src/drv/LCD_functions.c **** 
 135:src/drv/LCD_functions.c **** 
 136:src/drv/LCD_functions.c **** /****************************************************************************
 137:src/drv/LCD_functions.c **** *
 138:src/drv/LCD_functions.c **** *   Function name: LCD_putc
 139:src/drv/LCD_functions.c **** *
 140:src/drv/LCD_functions.c **** *   Returns :      None
 141:src/drv/LCD_functions.c **** *
 142:src/drv/LCD_functions.c **** *   Parameters :   digit: Which digit to write on the LCD
 143:src/drv/LCD_functions.c **** *                  character: Character to write
 144:src/drv/LCD_functions.c **** *
 145:src/drv/LCD_functions.c **** *   Purpose :      Writes a character to the LCD
 146:src/drv/LCD_functions.c **** *
 147:src/drv/LCD_functions.c **** *****************************************************************************/
 148:src/drv/LCD_functions.c **** // mt void LCD_putc(char digit, char character)
 149:src/drv/LCD_functions.c **** void LCD_putc(uint8_t digit, char character)
 150:src/drv/LCD_functions.c **** {
 196               		.loc 1 150 0
 197               		.cfi_startproc
 198               	.LVL19:
 199               	/* prologue: function */
 200               	/* frame size = 0 */
 201               	/* stack size = 0 */
 202               	.L__stack_usage = 0
 151:src/drv/LCD_functions.c ****     if (digit < TEXTBUFFER_SIZE) {
 203               		.loc 1 151 0
 204 0000 8931      		cpi r24,lo8(25)
 205 0002 00F4      		brsh .L26
 152:src/drv/LCD_functions.c ****         gTextBuffer[digit] = character;
 206               		.loc 1 152 0
 207 0004 E82F      		mov r30,r24
 208 0006 F0E0      		ldi r31,0
 209 0008 E050      		subi r30,lo8(-(gTextBuffer))
 210 000a F040      		sbci r31,hi8(-(gTextBuffer))
 211 000c 6083      		st Z,r22
 212               	.L26:
 213 000e 0895      		ret
 214               		.cfi_endproc
 215               	.LFE3:
 217               		.section	.text.LCD_Clear,"ax",@progbits
 218               	.global	LCD_Clear
 220               	LCD_Clear:
 221               	.LFB4:
 153:src/drv/LCD_functions.c ****     }
 154:src/drv/LCD_functions.c **** }
 155:src/drv/LCD_functions.c **** 
 156:src/drv/LCD_functions.c **** 
 157:src/drv/LCD_functions.c **** /****************************************************************************
 158:src/drv/LCD_functions.c **** *
 159:src/drv/LCD_functions.c **** *	Function name : LCD_Clear
 160:src/drv/LCD_functions.c **** *
 161:src/drv/LCD_functions.c **** *	Returns :		None
 162:src/drv/LCD_functions.c **** *
 163:src/drv/LCD_functions.c **** *	Parameters :	None
 164:src/drv/LCD_functions.c **** *
 165:src/drv/LCD_functions.c **** *	Purpose :		Clear the LCD
 166:src/drv/LCD_functions.c **** *
 167:src/drv/LCD_functions.c **** *****************************************************************************/
 168:src/drv/LCD_functions.c **** void LCD_Clear(void)
 169:src/drv/LCD_functions.c **** {
 222               		.loc 1 169 0
 223               		.cfi_startproc
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 228               	.LVL20:
 229               		.loc 1 169 0
 230 0000 80E0      		ldi r24,0
 231 0002 90E0      		ldi r25,0
 170:src/drv/LCD_functions.c ****     uint8_t i; // char i;
 171:src/drv/LCD_functions.c **** 
 172:src/drv/LCD_functions.c ****     for (i=0; i<TEXTBUFFER_SIZE; i++) {
 173:src/drv/LCD_functions.c ****         gTextBuffer[i] = ' ';
 232               		.loc 1 173 0
 233 0004 20E2      		ldi r18,lo8(32)
 234               	.LVL21:
 235               	.L29:
 236               		.loc 1 173 0 is_stmt 0 discriminator 3
 237 0006 FC01      		movw r30,r24
 238 0008 E050      		subi r30,lo8(-(gTextBuffer))
 239 000a F040      		sbci r31,hi8(-(gTextBuffer))
 240 000c 2083      		st Z,r18
 241               	.LVL22:
 242 000e 0196      		adiw r24,1
 243               	.LVL23:
 172:src/drv/LCD_functions.c ****         gTextBuffer[i] = ' ';
 244               		.loc 1 172 0 is_stmt 1 discriminator 3
 245 0010 8931      		cpi r24,25
 246 0012 9105      		cpc r25,__zero_reg__
 247 0014 01F4      		brne .L29
 174:src/drv/LCD_functions.c ****     }
 175:src/drv/LCD_functions.c **** 
 176:src/drv/LCD_functions.c ****     gTextBuffer[TEXTBUFFER_SIZE - 1] = '\0'; // M. Loeffler 12/2009
 248               		.loc 1 176 0
 249 0016 1092 0000 		sts gTextBuffer+24,__zero_reg__
 250 001a 0895      		ret
 251               		.cfi_endproc
 252               	.LFE4:
 254               		.section	.text.LCD_Colon,"ax",@progbits
 255               	.global	LCD_Colon
 257               	LCD_Colon:
 258               	.LFB5:
 177:src/drv/LCD_functions.c **** }
 178:src/drv/LCD_functions.c **** 
 179:src/drv/LCD_functions.c **** 
 180:src/drv/LCD_functions.c **** /****************************************************************************
 181:src/drv/LCD_functions.c **** *
 182:src/drv/LCD_functions.c **** *	Function name : LCD_Colon
 183:src/drv/LCD_functions.c **** *
 184:src/drv/LCD_functions.c **** *	Returns :		None
 185:src/drv/LCD_functions.c **** *
 186:src/drv/LCD_functions.c **** *	Parameters :	show: Enables the colon if TRUE, disable if FALSE
 187:src/drv/LCD_functions.c **** *
 188:src/drv/LCD_functions.c **** *	Purpose :		Enable/disable colons on the LCD
 189:src/drv/LCD_functions.c **** *
 190:src/drv/LCD_functions.c **** *****************************************************************************/
 191:src/drv/LCD_functions.c **** void LCD_Colon(char show)
 192:src/drv/LCD_functions.c **** {
 259               		.loc 1 192 0
 260               		.cfi_startproc
 261               	.LVL24:
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 193:src/drv/LCD_functions.c ****     gColon = show;
 266               		.loc 1 193 0
 267 0000 8093 0000 		sts gColon,r24
 268 0004 0895      		ret
 269               		.cfi_endproc
 270               	.LFE5:
 272               		.section	.text.LCD_UpdateRequired,"ax",@progbits
 273               	.global	LCD_UpdateRequired
 275               	LCD_UpdateRequired:
 276               	.LFB6:
 194:src/drv/LCD_functions.c **** }
 195:src/drv/LCD_functions.c **** 
 196:src/drv/LCD_functions.c **** 
 197:src/drv/LCD_functions.c **** /****************************************************************************
 198:src/drv/LCD_functions.c **** *
 199:src/drv/LCD_functions.c **** *	Function name : LCD_UpdateRequired
 200:src/drv/LCD_functions.c **** *
 201:src/drv/LCD_functions.c **** *	Returns :		None
 202:src/drv/LCD_functions.c **** *
 203:src/drv/LCD_functions.c **** *	Parameters :	update: TRUE/FALSE
 204:src/drv/LCD_functions.c **** *                   scrollmode: not in use
 205:src/drv/LCD_functions.c **** *
 206:src/drv/LCD_functions.c **** *	Purpose :		Tells the LCD that there is new data to be presented
 207:src/drv/LCD_functions.c **** *
 208:src/drv/LCD_functions.c **** *****************************************************************************/
 209:src/drv/LCD_functions.c **** void LCD_UpdateRequired(char update, char scrollmode)
 210:src/drv/LCD_functions.c **** {
 277               		.loc 1 210 0
 278               		.cfi_startproc
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
 283               	.LVL25:
 284               	.L33:
 211:src/drv/LCD_functions.c **** 
 212:src/drv/LCD_functions.c ****     while (gLCD_Update_Required);
 285               		.loc 1 212 0 discriminator 1
 286 0000 9091 0000 		lds r25,gLCD_Update_Required
 287 0004 9111      		cpse r25,__zero_reg__
 288 0006 00C0      		rjmp .L33
 213:src/drv/LCD_functions.c ****     
 214:src/drv/LCD_functions.c ****     gScrollMode = scrollmode;
 289               		.loc 1 214 0
 290 0008 6093 0000 		sts gScrollMode,r22
 215:src/drv/LCD_functions.c ****     gScroll = 0;
 291               		.loc 1 215 0
 292 000c 1092 0000 		sts gScroll,__zero_reg__
 216:src/drv/LCD_functions.c **** 
 217:src/drv/LCD_functions.c ****     gLCD_Update_Required = update;
 293               		.loc 1 217 0
 294 0010 8093 0000 		sts gLCD_Update_Required,r24
 295 0014 0895      		ret
 296               		.cfi_endproc
 297               	.LFE6:
 299               		.section	.text.LCD_FlashReset,"ax",@progbits
 300               	.global	LCD_FlashReset
 302               	LCD_FlashReset:
 303               	.LFB7:
 218:src/drv/LCD_functions.c **** }
 219:src/drv/LCD_functions.c **** 
 220:src/drv/LCD_functions.c **** 
 221:src/drv/LCD_functions.c **** /****************************************************************************
 222:src/drv/LCD_functions.c **** *
 223:src/drv/LCD_functions.c **** *	Function name : LCD_FlashReset
 224:src/drv/LCD_functions.c **** *
 225:src/drv/LCD_functions.c **** *	Returns :		None
 226:src/drv/LCD_functions.c **** *
 227:src/drv/LCD_functions.c **** *	Parameters :	None
 228:src/drv/LCD_functions.c **** *
 229:src/drv/LCD_functions.c **** *	Purpose :		This function resets the blinking cycle of a flashing digit
 230:src/drv/LCD_functions.c **** *
 231:src/drv/LCD_functions.c **** *****************************************************************************/
 232:src/drv/LCD_functions.c **** void LCD_FlashReset(void)
 233:src/drv/LCD_functions.c **** {
 304               		.loc 1 233 0
 305               		.cfi_startproc
 306               	/* prologue: function */
 307               	/* frame size = 0 */
 308               	/* stack size = 0 */
 309               	.L__stack_usage = 0
 234:src/drv/LCD_functions.c ****     gFlashTimer = 0;
 310               		.loc 1 234 0
 311 0000 1092 0000 		sts gFlashTimer,__zero_reg__
 312 0004 0895      		ret
 313               		.cfi_endproc
 314               	.LFE7:
 316               		.section	.text.SetContrast,"ax",@progbits
 317               	.global	SetContrast
 319               	SetContrast:
 320               	.LFB8:
 235:src/drv/LCD_functions.c **** }
 236:src/drv/LCD_functions.c **** 
 237:src/drv/LCD_functions.c **** 
 238:src/drv/LCD_functions.c **** /****************************************************************************
 239:src/drv/LCD_functions.c **** *
 240:src/drv/LCD_functions.c **** *	Function name : SetContrast
 241:src/drv/LCD_functions.c **** *
 242:src/drv/LCD_functions.c **** *   Returns :       char ST_state (to the state-machine)
 243:src/drv/LCD_functions.c **** *
 244:src/drv/LCD_functions.c **** *   Parameters :    char input (from joystick)
 245:src/drv/LCD_functions.c **** *
 246:src/drv/LCD_functions.c **** *	Purpose :		Adjust the LCD contrast
 247:src/drv/LCD_functions.c **** *
 248:src/drv/LCD_functions.c **** *****************************************************************************/
 249:src/drv/LCD_functions.c **** char SetContrast(char input)
 250:src/drv/LCD_functions.c **** {
 321               		.loc 1 250 0
 322               		.cfi_startproc
 323               	.LVL26:
 324 0000 CF93      		push r28
 325               	.LCFI0:
 326               		.cfi_def_cfa_offset 3
 327               		.cfi_offset 28, -2
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 1 */
 331               	.L__stack_usage = 1
 332 0002 C82F      		mov r28,r24
 251:src/drv/LCD_functions.c ****     static char enter = 1;
 252:src/drv/LCD_functions.c ****     char CH, CL;
 253:src/drv/LCD_functions.c **** 
 254:src/drv/LCD_functions.c ****     if (enter)
 333               		.loc 1 254 0
 334 0004 8091 0000 		lds r24,enter.1794
 335               	.LVL27:
 336 0008 8823      		tst r24
 337 000a 01F0      		breq .L37
 255:src/drv/LCD_functions.c ****     {
 256:src/drv/LCD_functions.c ****         LCD_Clear();
 338               		.loc 1 256 0
 339 000c 0E94 0000 		call LCD_Clear
 340               	.LVL28:
 257:src/drv/LCD_functions.c ****         enter = 0;
 341               		.loc 1 257 0
 342 0010 1092 0000 		sts enter.1794,__zero_reg__
 343               	.L37:
 258:src/drv/LCD_functions.c ****     }
 259:src/drv/LCD_functions.c **** 
 260:src/drv/LCD_functions.c ****     CH = CHAR2BCD2(CONTRAST);
 344               		.loc 1 260 0
 345 0014 8091 0000 		lds r24,CONTRAST
 346 0018 0E94 0000 		call CHAR2BCD2
 347               	.LVL29:
 261:src/drv/LCD_functions.c ****     CL = (CH & 0x0F) + '0';
 348               		.loc 1 261 0
 349 001c 282F      		mov r18,r24
 350 001e 2F70      		andi r18,lo8(15)
 351 0020 205D      		subi r18,lo8(-(48))
 352               	.LVL30:
 262:src/drv/LCD_functions.c ****     CH = (CH >> 4) + '0';
 353               		.loc 1 262 0
 354 0022 982F      		mov r25,r24
 355 0024 9295      		swap r25
 356 0026 9F70      		andi r25,lo8(15)
 357 0028 905D      		subi r25,lo8(-(48))
 358               	.LVL31:
 359               	.LBB16:
 360               	.LBB17:
 152:src/drv/LCD_functions.c ****     }
 361               		.loc 1 152 0
 362 002a 83E4      		ldi r24,lo8(67)
 363 002c 8093 0000 		sts gTextBuffer,r24
 364               	.LVL32:
 365               	.LBE17:
 366               	.LBE16:
 367               	.LBB18:
 368               	.LBB19:
 369 0030 84E5      		ldi r24,lo8(84)
 370 0032 8093 0000 		sts gTextBuffer+1,r24
 371               	.LVL33:
 372               	.LBE19:
 373               	.LBE18:
 374               	.LBB20:
 375               	.LBB21:
 376 0036 82E5      		ldi r24,lo8(82)
 377 0038 8093 0000 		sts gTextBuffer+2,r24
 378               	.LVL34:
 379               	.LBE21:
 380               	.LBE20:
 381               	.LBB22:
 382               	.LBB23:
 383 003c 80E2      		ldi r24,lo8(32)
 384 003e 8093 0000 		sts gTextBuffer+3,r24
 385               	.LVL35:
 386               	.LBE23:
 387               	.LBE22:
 388               	.LBB24:
 389               	.LBB25:
 390 0042 9093 0000 		sts gTextBuffer+4,r25
 391               	.LVL36:
 392               	.LBE25:
 393               	.LBE24:
 394               	.LBB26:
 395               	.LBB27:
 396 0046 2093 0000 		sts gTextBuffer+5,r18
 397               	.LBE27:
 398               	.LBE26:
 263:src/drv/LCD_functions.c **** 
 264:src/drv/LCD_functions.c ****     LCD_putc(0, 'C');
 265:src/drv/LCD_functions.c ****     LCD_putc(1, 'T');
 266:src/drv/LCD_functions.c ****     LCD_putc(2, 'R');
 267:src/drv/LCD_functions.c ****     LCD_putc(3, ' ');
 268:src/drv/LCD_functions.c ****     LCD_putc(4, CH);
 269:src/drv/LCD_functions.c ****     LCD_putc(5, CL);
 270:src/drv/LCD_functions.c **** 
 271:src/drv/LCD_functions.c ****     LCD_UpdateRequired(TRUE, 0);
 399               		.loc 1 271 0
 400 004a 60E0      		ldi r22,0
 401 004c 81E0      		ldi r24,lo8(1)
 402 004e 0E94 0000 		call LCD_UpdateRequired
 403               	.LVL37:
 404 0052 9091 0000 		lds r25,CONTRAST
 272:src/drv/LCD_functions.c **** 
 273:src/drv/LCD_functions.c ****     if (input == KEY_PLUS)
 405               		.loc 1 273 0
 406 0056 C430      		cpi r28,lo8(4)
 407 0058 01F4      		brne .L38
 274:src/drv/LCD_functions.c ****         CONTRAST++;
 408               		.loc 1 274 0
 409 005a 9F5F      		subi r25,lo8(-(1))
 410 005c 00C0      		rjmp .L47
 411               	.L38:
 275:src/drv/LCD_functions.c ****     else if (input == KEY_MINUS)
 412               		.loc 1 275 0
 413 005e C530      		cpi r28,lo8(5)
 414 0060 01F4      		brne .L39
 276:src/drv/LCD_functions.c ****         CONTRAST--;
 415               		.loc 1 276 0
 416 0062 9150      		subi r25,lo8(-(-1))
 417               	.L47:
 418 0064 9093 0000 		sts CONTRAST,r25
 419               	.L39:
 277:src/drv/LCD_functions.c **** 
 278:src/drv/LCD_functions.c ****     if (CONTRAST == 255)
 420               		.loc 1 278 0
 421 0068 8091 0000 		lds r24,CONTRAST
 422 006c 8F3F      		cpi r24,lo8(-1)
 423 006e 01F4      		brne .L40
 279:src/drv/LCD_functions.c ****         CONTRAST = 0;
 424               		.loc 1 279 0
 425 0070 1092 0000 		sts CONTRAST,__zero_reg__
 426               	.L40:
 280:src/drv/LCD_functions.c ****     if (CONTRAST > 15)
 427               		.loc 1 280 0
 428 0074 8091 0000 		lds r24,CONTRAST
 429 0078 8031      		cpi r24,lo8(16)
 430 007a 00F0      		brlo .L41
 281:src/drv/LCD_functions.c ****         CONTRAST = 15;
 431               		.loc 1 281 0
 432 007c 8FE0      		ldi r24,lo8(15)
 433 007e 8093 0000 		sts CONTRAST,r24
 434               	.L41:
 282:src/drv/LCD_functions.c **** 
 283:src/drv/LCD_functions.c ****     LCD_CONTRAST_LEVEL(CONTRAST);
 435               		.loc 1 283 0
 436 0082 9091 E700 		lds r25,231
 437 0086 8091 0000 		lds r24,CONTRAST
 438 008a 8F70      		andi r24,lo8(15)
 439 008c 907F      		andi r25,lo8(-16)
 440 008e 982B      		or r25,r24
 441 0090 9093 E700 		sts 231,r25
 284:src/drv/LCD_functions.c **** 
 285:src/drv/LCD_functions.c **** 
 286:src/drv/LCD_functions.c ****     if (input == KEY_ENTER)
 442               		.loc 1 286 0
 443 0094 C130      		cpi r28,lo8(1)
 444 0096 01F4      		brne .L43
 287:src/drv/LCD_functions.c ****     {
 288:src/drv/LCD_functions.c ****         enter = 1;
 445               		.loc 1 288 0
 446 0098 C093 0000 		sts enter.1794,r28
 289:src/drv/LCD_functions.c ****         return ST_OPTIONS_DISPLAY_CONTRAST;
 447               		.loc 1 289 0
 448 009c 8CE5      		ldi r24,lo8(92)
 449 009e 00C0      		rjmp .L42
 450               	.L43:
 290:src/drv/LCD_functions.c ****     }
 291:src/drv/LCD_functions.c **** 
 292:src/drv/LCD_functions.c ****     return ST_OPTIONS_DISPLAY_CONTRAST_FUNC;
 451               		.loc 1 292 0
 452 00a0 8DE5      		ldi r24,lo8(93)
 453               	.L42:
 454               	/* epilogue start */
 293:src/drv/LCD_functions.c **** }
 455               		.loc 1 293 0
 456 00a2 CF91      		pop r28
 457               	.LVL38:
 458 00a4 0895      		ret
 459               		.cfi_endproc
 460               	.LFE8:
 462               		.section	.data.enter.1794,"aw",@progbits
 465               	enter.1794:
 466 0000 01        		.byte	1
 467               	.global	CONTRAST
 468               		.section	.data.CONTRAST,"aw",@progbits
 471               	CONTRAST:
 472 0000 0F        		.byte	15
 473               		.text
 474               	.Letext0:
 475               		.file 2 "/usr/lib/avr/include/stdint.h"
 476               		.file 3 "inc/LCD_driver.h"
 477               		.file 4 "inc/BCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD_functions.c
     /tmp/cc462W7k.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc462W7k.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc462W7k.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc462W7k.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc462W7k.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc462W7k.s:13     .text.LCD_puts_f:0000000000000000 LCD_puts_f
     /tmp/cc462W7k.s:117    .text.LCD_puts:0000000000000000 LCD_puts
     /tmp/cc462W7k.s:194    .text.LCD_putc:0000000000000000 LCD_putc
     /tmp/cc462W7k.s:220    .text.LCD_Clear:0000000000000000 LCD_Clear
     /tmp/cc462W7k.s:257    .text.LCD_Colon:0000000000000000 LCD_Colon
     /tmp/cc462W7k.s:275    .text.LCD_UpdateRequired:0000000000000000 LCD_UpdateRequired
     /tmp/cc462W7k.s:302    .text.LCD_FlashReset:0000000000000000 LCD_FlashReset
     /tmp/cc462W7k.s:319    .text.SetContrast:0000000000000000 SetContrast
     /tmp/cc462W7k.s:465    .data.enter.1794:0000000000000000 enter.1794
     /tmp/cc462W7k.s:471    .data.CONTRAST:0000000000000000 CONTRAST

UNDEFINED SYMBOLS
gLCD_Update_Required
gTextBuffer
gScrollMode
gScroll
gLCD_Start_Scroll_Timer
gColon
gFlashTimer
CHAR2BCD2
__do_copy_data

   1               		.file	"LCD_driver.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.LCD_WriteDigit,"ax",@progbits
  11               	.global	LCD_WriteDigit
  13               	LCD_WriteDigit:
  14               	.LFB2:
  15               		.file 1 "src/drv/LCD_driver.c"
   1:src/drv/LCD_driver.c **** //*****************************************************************************
   2:src/drv/LCD_driver.c **** //
   3:src/drv/LCD_driver.c **** //  File........: LCD_driver.c
   4:src/drv/LCD_driver.c **** //
   5:src/drv/LCD_driver.c **** //  Author(s)...: ATMEL Norway
   6:src/drv/LCD_driver.c **** //
   7:src/drv/LCD_driver.c **** //  Target(s)...: ATmega169
   8:src/drv/LCD_driver.c **** //
   9:src/drv/LCD_driver.c **** //  Compiler....: AVR-GCC 4.1.1; avr-libc 1.4.5
  10:src/drv/LCD_driver.c **** //
  11:src/drv/LCD_driver.c **** //  Description.: Functions used to control the AVR Butterfly LCD
  12:src/drv/LCD_driver.c **** //
  13:src/drv/LCD_driver.c **** //  Revisions...: 1.0
  14:src/drv/LCD_driver.c **** //
  15:src/drv/LCD_driver.c **** //  YYYYMMDD - VER. - COMMENT                                       - SIGN.
  16:src/drv/LCD_driver.c **** //
  17:src/drv/LCD_driver.c **** //  20021015 - 1.0  - Written for STK502                            - JLL
  18:src/drv/LCD_driver.c **** //  20030116 - 2.0  - Code adapted to AVR Butterfly                 - KS
  19:src/drv/LCD_driver.c **** //  20031009          port to avr-gcc/avr-libc                      - M.Thomas
  20:src/drv/LCD_driver.c **** //  20070122          "updated 2006-10-10" included (from REV07)    - from Atmel
  21:src/drv/LCD_driver.c **** //  20070129          SIGNAL->ISR, gLCD_Start_Scroll_Timer volatile - mt
  22:src/drv/LCD_driver.c **** //
  23:src/drv/LCD_driver.c **** //*****************************************************************************
  24:src/drv/LCD_driver.c **** 
  25:src/drv/LCD_driver.c **** 
  26:src/drv/LCD_driver.c **** // Include files.
  27:src/drv/LCD_driver.c **** #include <avr/io.h>
  28:src/drv/LCD_driver.c **** #include <avr/pgmspace.h>
  29:src/drv/LCD_driver.c **** #include <avr/interrupt.h>
  30:src/drv/LCD_driver.c **** #include <stdint.h>
  31:src/drv/LCD_driver.c **** // mt - only for AUTO:
  32:src/drv/LCD_driver.c **** #include "main.h"
  33:src/drv/LCD_driver.c **** // mt - for gButtonTimeout
  34:src/drv/LCD_driver.c **** #include "button.h"
  35:src/drv/LCD_driver.c **** #include "LCD_driver.h"
  36:src/drv/LCD_driver.c **** 
  37:src/drv/LCD_driver.c **** #ifndef BOOL
  38:src/drv/LCD_driver.c **** #define BOOL    char
  39:src/drv/LCD_driver.c **** #define FALSE   0
  40:src/drv/LCD_driver.c **** #define TRUE    (!FALSE)
  41:src/drv/LCD_driver.c **** #endif
  42:src/drv/LCD_driver.c **** 
  43:src/drv/LCD_driver.c **** // Variable from "button.c" to prevent button-bouncing
  44:src/drv/LCD_driver.c **** extern unsigned char gButtonTimeout;    
  45:src/drv/LCD_driver.c **** 
  46:src/drv/LCD_driver.c **** volatile char gAutoPressJoystick = FALSE;
  47:src/drv/LCD_driver.c **** 
  48:src/drv/LCD_driver.c **** // Used to indicate when the LCD interrupt handler should update the LCD
  49:src/drv/LCD_driver.c **** // mt jw char gLCD_Update_Required = FALSE;
  50:src/drv/LCD_driver.c **** volatile char gLCD_Update_Required = FALSE;
  51:src/drv/LCD_driver.c **** 
  52:src/drv/LCD_driver.c **** // LCD display buffer (for double buffering).
  53:src/drv/LCD_driver.c **** volatile char LCD_Data[LCD_REGISTER_COUNT];
  54:src/drv/LCD_driver.c **** 
  55:src/drv/LCD_driver.c **** // Buffer that contains the text to be displayed
  56:src/drv/LCD_driver.c **** // Note: Bit 7 indicates that this character is flashing
  57:src/drv/LCD_driver.c **** volatile char gTextBuffer[TEXTBUFFER_SIZE];
  58:src/drv/LCD_driver.c **** 
  59:src/drv/LCD_driver.c **** // Only six letters can be shown on the LCD.
  60:src/drv/LCD_driver.c **** // With the gScroll and gScrollMode variables,
  61:src/drv/LCD_driver.c **** // one can select which part of the buffer to show
  62:src/drv/LCD_driver.c **** volatile signed char gScroll;
  63:src/drv/LCD_driver.c **** volatile char gScrollMode;
  64:src/drv/LCD_driver.c **** 
  65:src/drv/LCD_driver.c **** ////Start-up delay before scrolling a string over the LCD
  66:src/drv/LCD_driver.c **** volatile char gLCD_Start_Scroll_Timer = 0;
  67:src/drv/LCD_driver.c **** 
  68:src/drv/LCD_driver.c **** // The gFlashTimer is used to determine the on/off
  69:src/drv/LCD_driver.c **** // timing of flashing characters
  70:src/drv/LCD_driver.c **** volatile char gFlashTimer = 0;
  71:src/drv/LCD_driver.c **** 
  72:src/drv/LCD_driver.c **** // Turns on/off the colons on the LCD
  73:src/drv/LCD_driver.c **** char gColon = 0;
  74:src/drv/LCD_driver.c **** 
  75:src/drv/LCD_driver.c **** 
  76:src/drv/LCD_driver.c **** // Look-up table used when converting ASCII to
  77:src/drv/LCD_driver.c **** // LCD display data (segment control)
  78:src/drv/LCD_driver.c **** // mt __flash unsigned int LCD_character_table[] =
  79:src/drv/LCD_driver.c **** const unsigned int LCD_character_table[] PROGMEM =
  80:src/drv/LCD_driver.c **** {
  81:src/drv/LCD_driver.c ****     0x0A51,     // '*' (?)
  82:src/drv/LCD_driver.c ****     0x2A80,     // '+'
  83:src/drv/LCD_driver.c ****     0x0000,     // ',' (Not defined)
  84:src/drv/LCD_driver.c ****     0x0A00,     // '-'
  85:src/drv/LCD_driver.c ****     0x0A51,     // '.' Degree sign
  86:src/drv/LCD_driver.c ****     0x0000,     // '/' (Not defined)
  87:src/drv/LCD_driver.c ****     0x5559,     // '0'
  88:src/drv/LCD_driver.c ****     0x0118,     // '1'
  89:src/drv/LCD_driver.c ****     0x1e11,     // '2
  90:src/drv/LCD_driver.c ****     0x1b11,     // '3
  91:src/drv/LCD_driver.c ****     0x0b50,     // '4
  92:src/drv/LCD_driver.c ****     0x1b41,     // '5
  93:src/drv/LCD_driver.c ****     0x1f41,     // '6
  94:src/drv/LCD_driver.c ****     0x0111,     // '7
  95:src/drv/LCD_driver.c ****     0x1f51,     // '8
  96:src/drv/LCD_driver.c ****     0x1b51,     // '9'
  97:src/drv/LCD_driver.c ****     0x0000,     // ':' (Not defined)
  98:src/drv/LCD_driver.c ****     0x0000,     // ';' (Not defined)
  99:src/drv/LCD_driver.c ****     0x0000,     // '<' (Not defined)
 100:src/drv/LCD_driver.c ****     0x0000,     // '=' (Not defined)
 101:src/drv/LCD_driver.c ****     0x0000,     // '>' (Not defined)
 102:src/drv/LCD_driver.c ****     0x0000,     // '?' (Not defined)
 103:src/drv/LCD_driver.c ****     0x0000,     // '@' (Not defined)
 104:src/drv/LCD_driver.c ****     0x0f51,     // 'A' (+ 'a')
 105:src/drv/LCD_driver.c ****     0x3991,     // 'B' (+ 'b')
 106:src/drv/LCD_driver.c ****     0x1441,     // 'C' (+ 'c')
 107:src/drv/LCD_driver.c ****     0x3191,     // 'D' (+ 'd')
 108:src/drv/LCD_driver.c ****     0x1e41,     // 'E' (+ 'e')
 109:src/drv/LCD_driver.c ****     0x0e41,     // 'F' (+ 'f')
 110:src/drv/LCD_driver.c ****     0x1d41,     // 'G' (+ 'g')
 111:src/drv/LCD_driver.c ****     0x0f50,     // 'H' (+ 'h')
 112:src/drv/LCD_driver.c ****     0x2080,     // 'I' (+ 'i')
 113:src/drv/LCD_driver.c ****     0x1510,     // 'J' (+ 'j')
 114:src/drv/LCD_driver.c ****     0x8648,     // 'K' (+ 'k')
 115:src/drv/LCD_driver.c ****     0x1440,     // 'L' (+ 'l')
 116:src/drv/LCD_driver.c ****     0x0578,     // 'M' (+ 'm')
 117:src/drv/LCD_driver.c ****     0x8570,     // 'N' (+ 'n')
 118:src/drv/LCD_driver.c ****     0x1551,     // 'O' (+ 'o')
 119:src/drv/LCD_driver.c ****     0x0e51,     // 'P' (+ 'p')
 120:src/drv/LCD_driver.c ****     0x9551,     // 'Q' (+ 'q')
 121:src/drv/LCD_driver.c ****     0x8e51,     // 'R' (+ 'r')
 122:src/drv/LCD_driver.c ****     0x9021,     // 'S' (+ 's')
 123:src/drv/LCD_driver.c ****     0x2081,     // 'T' (+ 't')
 124:src/drv/LCD_driver.c ****     0x1550,     // 'U' (+ 'u')
 125:src/drv/LCD_driver.c ****     0x4448,     // 'V' (+ 'v')
 126:src/drv/LCD_driver.c ****     0xc550,     // 'W' (+ 'w')
 127:src/drv/LCD_driver.c ****     0xc028,     // 'X' (+ 'x')
 128:src/drv/LCD_driver.c ****     0x2028,     // 'Y' (+ 'y')
 129:src/drv/LCD_driver.c ****     0x5009,     // 'Z' (+ 'z')
 130:src/drv/LCD_driver.c ****     0x0000,     // '[' (Not defined)
 131:src/drv/LCD_driver.c ****     0x0000,     // '\' (Not defined)
 132:src/drv/LCD_driver.c ****     0x0000,     // ']' (Not defined)
 133:src/drv/LCD_driver.c ****     0x0000,     // '^' (Not defined)
 134:src/drv/LCD_driver.c ****     0x0000      // '_'
 135:src/drv/LCD_driver.c **** };
 136:src/drv/LCD_driver.c **** 
 137:src/drv/LCD_driver.c **** 
 138:src/drv/LCD_driver.c **** /*****************************************************************************
 139:src/drv/LCD_driver.c **** *
 140:src/drv/LCD_driver.c **** *   Function name : LCD_Init
 141:src/drv/LCD_driver.c **** *
 142:src/drv/LCD_driver.c **** *   Returns :       None
 143:src/drv/LCD_driver.c **** *
 144:src/drv/LCD_driver.c **** *   Parameters :    None
 145:src/drv/LCD_driver.c **** *
 146:src/drv/LCD_driver.c **** *   Purpose :       Initialize LCD_displayData buffer.
 147:src/drv/LCD_driver.c **** *                   Set up the LCD (timing, contrast, etc.)
 148:src/drv/LCD_driver.c **** *
 149:src/drv/LCD_driver.c **** *****************************************************************************/
 150:src/drv/LCD_driver.c **** void LCD_Init(void)
 151:src/drv/LCD_driver.c **** {
 152:src/drv/LCD_driver.c ****     LCD_AllSegments(FALSE);                     // Clear segment buffer.
 153:src/drv/LCD_driver.c **** 
 154:src/drv/LCD_driver.c ****     LCD_CONTRAST_LEVEL(LCD_INITIAL_CONTRAST);    //Set the LCD contrast level
 155:src/drv/LCD_driver.c **** 
 156:src/drv/LCD_driver.c ****     // Select asynchronous clock source, enable all COM pins and enable all
 157:src/drv/LCD_driver.c ****     // segment pins.
 158:src/drv/LCD_driver.c ****     LCDCRB = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
 159:src/drv/LCD_driver.c **** 
 160:src/drv/LCD_driver.c ****     // Set LCD prescaler to give a framerate of 32,0 Hz
 161:src/drv/LCD_driver.c ****     LCDFRR = (0<<LCDPS0) | (7<<LCDCD0);    
 162:src/drv/LCD_driver.c **** 
 163:src/drv/LCD_driver.c ****     LCDCRA = (1<<LCDEN) | (1<<LCDAB);           // Enable LCD and set low power waveform
 164:src/drv/LCD_driver.c **** 
 165:src/drv/LCD_driver.c ****     //Enable LCD start of frame interrupt
 166:src/drv/LCD_driver.c ****     LCDCRA |= (1<<LCDIE);
 167:src/drv/LCD_driver.c **** 
 168:src/drv/LCD_driver.c ****     //updated 2006-10-10, setting LCD drive time to 1150us in FW rev 07, 
 169:src/drv/LCD_driver.c ****     //instead of previous 300us in FW rev 06. Due to some variations on the LCD
 170:src/drv/LCD_driver.c ****     //glass provided to the AVR Butterfly production.
 171:src/drv/LCD_driver.c ****     LCDCCR |= (1<<LCDDC2) | (1<<LCDDC1) | (1<<LCDDC0);
 172:src/drv/LCD_driver.c **** 
 173:src/drv/LCD_driver.c ****     gLCD_Update_Required = FALSE;
 174:src/drv/LCD_driver.c **** 
 175:src/drv/LCD_driver.c **** 
 176:src/drv/LCD_driver.c **** }
 177:src/drv/LCD_driver.c **** 
 178:src/drv/LCD_driver.c **** 
 179:src/drv/LCD_driver.c **** /*****************************************************************************
 180:src/drv/LCD_driver.c **** *
 181:src/drv/LCD_driver.c **** *   Function name : LCD_WriteDigit(char c, char digit)
 182:src/drv/LCD_driver.c **** *
 183:src/drv/LCD_driver.c **** *   Returns :       None
 184:src/drv/LCD_driver.c **** *
 185:src/drv/LCD_driver.c **** *   Parameters :    Inputs
 186:src/drv/LCD_driver.c **** *                   c: The symbol to be displayed in a LCD digit
 187:src/drv/LCD_driver.c **** *                   digit: In which digit (0-5) the symbol should be displayed
 188:src/drv/LCD_driver.c **** *                   Note: Digit 0 is the first used digit on the LCD,
 189:src/drv/LCD_driver.c **** *                   i.e LCD digit 2
 190:src/drv/LCD_driver.c **** *
 191:src/drv/LCD_driver.c **** *   Purpose :       Stores LCD control data in the LCD_displayData buffer.
 192:src/drv/LCD_driver.c **** *                   (The LCD_displayData is latched in the LCD_SOF interrupt.)
 193:src/drv/LCD_driver.c **** *
 194:src/drv/LCD_driver.c **** *****************************************************************************/
 195:src/drv/LCD_driver.c **** void LCD_WriteDigit(char c, char digit)
 196:src/drv/LCD_driver.c **** {
  16               		.loc 1 196 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 197:src/drv/LCD_driver.c **** 
 198:src/drv/LCD_driver.c ****     unsigned int seg = 0x0000;                  // Holds the segment pattern
 199:src/drv/LCD_driver.c ****     char mask, nibble;
 200:src/drv/LCD_driver.c ****     volatile char *ptr;
 201:src/drv/LCD_driver.c ****     char i;
 202:src/drv/LCD_driver.c **** 
 203:src/drv/LCD_driver.c **** 
 204:src/drv/LCD_driver.c ****     if (digit > 5)                              // Skip if digit is illegal
  23               		.loc 1 204 0
  24 0000 6630      		cpi r22,lo8(6)
  25 0002 00F4      		brsh .L1
 205:src/drv/LCD_driver.c ****         return;
 206:src/drv/LCD_driver.c **** 
 207:src/drv/LCD_driver.c ****     //Lookup character table for segmet data
 208:src/drv/LCD_driver.c ****     if ((c >= '*') && (c <= 'z'))
  26               		.loc 1 208 0
  27 0004 96ED      		ldi r25,lo8(-42)
  28 0006 980F      		add r25,r24
  29 0008 9135      		cpi r25,lo8(81)
  30 000a 00F4      		brsh .L9
 209:src/drv/LCD_driver.c ****     {
 210:src/drv/LCD_driver.c ****         // c is a letter
 211:src/drv/LCD_driver.c ****         if (c >= 'a')                           // Convert to upper case
  31               		.loc 1 211 0
  32 000c 8136      		cpi r24,lo8(97)
  33 000e 00F0      		brlo .L4
 212:src/drv/LCD_driver.c ****             c &= ~0x20;                         // if necessarry
  34               		.loc 1 212 0
  35 0010 8F7D      		andi r24,lo8(-33)
  36               	.LVL1:
  37               	.L4:
 213:src/drv/LCD_driver.c **** 
 214:src/drv/LCD_driver.c ****         c -= '*';
  38               		.loc 1 214 0
  39 0012 8A52      		subi r24,lo8(-(-42))
  40               	.LVL2:
  41               	.LBB2:
 215:src/drv/LCD_driver.c **** 
 216:src/drv/LCD_driver.c ****         //mt seg = LCD_character_table[c];
 217:src/drv/LCD_driver.c ****         seg = (unsigned int) pgm_read_word(&LCD_character_table[(uint8_t)c]); 
  42               		.loc 1 217 0
  43 0014 E82F      		mov r30,r24
  44 0016 F0E0      		ldi r31,0
  45 0018 EE0F      		lsl r30
  46 001a FF1F      		rol r31
  47 001c E050      		subi r30,lo8(-(LCD_character_table))
  48 001e F040      		sbci r31,hi8(-(LCD_character_table))
  49               	.LVL3:
  50               	/* #APP */
  51               	 ;  217 "src/drv/LCD_driver.c" 1
  52 0020 2591      		lpm r18, Z+
  53 0022 3491      		lpm r19, Z
  54               		
  55               	 ;  0 "" 2
  56               	.LVL4:
  57               	/* #NOAPP */
  58 0024 00C0      		rjmp .L3
  59               	.LVL5:
  60               	.L9:
  61               	.LBE2:
 198:src/drv/LCD_driver.c ****     char mask, nibble;
  62               		.loc 1 198 0
  63 0026 20E0      		ldi r18,0
  64 0028 30E0      		ldi r19,0
  65               	.LVL6:
  66               	.L3:
 218:src/drv/LCD_driver.c ****     }
 219:src/drv/LCD_driver.c **** 
 220:src/drv/LCD_driver.c ****     // Adjust mask according to LCD segment mapping
 221:src/drv/LCD_driver.c ****     if (digit & 0x01)
  67               		.loc 1 221 0
  68 002a 562F      		mov r21,r22
  69 002c 5170      		andi r21,lo8(1)
  70 002e 60FD      		sbrc r22,0
  71 0030 00C0      		rjmp .L10
 222:src/drv/LCD_driver.c ****         mask = 0x0F;                // Digit 1, 3, 5
 223:src/drv/LCD_driver.c ****     else
 224:src/drv/LCD_driver.c ****         mask = 0xF0;                // Digit 0, 2, 4
  72               		.loc 1 224 0
  73 0032 40EF      		ldi r20,lo8(-16)
  74 0034 00C0      		rjmp .L5
  75               	.L10:
 222:src/drv/LCD_driver.c ****         mask = 0x0F;                // Digit 1, 3, 5
  76               		.loc 1 222 0
  77 0036 4FE0      		ldi r20,lo8(15)
  78               	.L5:
  79               	.LVL7:
 225:src/drv/LCD_driver.c **** 
 226:src/drv/LCD_driver.c ****     ptr = LCD_Data + (digit >> 1);  // digit = {0,0,1,1,2,2}
  80               		.loc 1 226 0
  81 0038 6695      		lsr r22
  82               	.LVL8:
  83 003a E62F      		mov r30,r22
  84 003c F0E0      		ldi r31,0
  85 003e E050      		subi r30,lo8(-(LCD_Data))
  86 0040 F040      		sbci r31,hi8(-(LCD_Data))
  87               	.LVL9:
  88 0042 BF01      		movw r22,r30
  89 0044 6C5E      		subi r22,-20
  90 0046 7F4F      		sbci r23,-1
  91               	.LVL10:
  92               	.L7:
 227:src/drv/LCD_driver.c **** 
 228:src/drv/LCD_driver.c ****     for (i = 0; i < 4; i++)
 229:src/drv/LCD_driver.c ****     {
 230:src/drv/LCD_driver.c ****         nibble = seg & 0x000F;
  93               		.loc 1 230 0
  94 0048 922F      		mov r25,r18
  95 004a 9F70      		andi r25,lo8(15)
  96               	.LVL11:
 231:src/drv/LCD_driver.c ****         seg >>= 4;
  97               		.loc 1 231 0
  98 004c 84E0      		ldi r24,4
  99               		1:
 100 004e 3695      		lsr r19
 101 0050 2795      		ror r18
 102 0052 8A95      		dec r24
 103 0054 01F4      		brne 1b
 104               	.LVL12:
 232:src/drv/LCD_driver.c ****         if (digit & 0x01)
 105               		.loc 1 232 0
 106 0056 5523      		tst r21
 107 0058 01F0      		breq .L6
 233:src/drv/LCD_driver.c ****             nibble <<= 4;
 108               		.loc 1 233 0
 109 005a 9295      		swap r25
 110               	.LVL13:
 111 005c 907F      		andi r25,lo8(-16)
 112               	.LVL14:
 113               	.L6:
 234:src/drv/LCD_driver.c ****         *ptr = (*ptr & mask) | nibble;
 114               		.loc 1 234 0 discriminator 2
 115 005e 8081      		ld r24,Z
 116 0060 8423      		and r24,r20
 117 0062 892B      		or r24,r25
 118 0064 8083      		st Z,r24
 235:src/drv/LCD_driver.c ****         ptr += 5;
 119               		.loc 1 235 0 discriminator 2
 120 0066 3596      		adiw r30,5
 121               	.LVL15:
 228:src/drv/LCD_driver.c ****     {
 122               		.loc 1 228 0 discriminator 2
 123 0068 E617      		cp r30,r22
 124 006a F707      		cpc r31,r23
 125 006c 01F4      		brne .L7
 126               	.LVL16:
 127               	.L1:
 128 006e 0895      		ret
 129               		.cfi_endproc
 130               	.LFE2:
 132               		.section	.text.LCD_AllSegments,"ax",@progbits
 133               	.global	LCD_AllSegments
 135               	LCD_AllSegments:
 136               	.LFB3:
 236:src/drv/LCD_driver.c ****     }
 237:src/drv/LCD_driver.c **** }
 238:src/drv/LCD_driver.c **** 
 239:src/drv/LCD_driver.c **** 
 240:src/drv/LCD_driver.c **** 
 241:src/drv/LCD_driver.c **** /*****************************************************************************
 242:src/drv/LCD_driver.c **** *
 243:src/drv/LCD_driver.c **** *   Function name : LCD_AllSegments(unsigned char input)
 244:src/drv/LCD_driver.c **** *
 245:src/drv/LCD_driver.c **** *   Returns :       None
 246:src/drv/LCD_driver.c **** *
 247:src/drv/LCD_driver.c **** *   Parameters :    show -  [TRUE;FALSE]
 248:src/drv/LCD_driver.c **** *
 249:src/drv/LCD_driver.c **** *   Purpose :       shows or hide all all LCD segments on the LCD
 250:src/drv/LCD_driver.c **** *
 251:src/drv/LCD_driver.c **** *****************************************************************************/
 252:src/drv/LCD_driver.c **** void LCD_AllSegments(char show)
 253:src/drv/LCD_driver.c **** {
 137               		.loc 1 253 0
 138               		.cfi_startproc
 139               	.LVL17:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 254:src/drv/LCD_driver.c ****     unsigned char i;
 255:src/drv/LCD_driver.c **** 
 256:src/drv/LCD_driver.c ****     if (show)
 144               		.loc 1 256 0
 145 0000 91E0      		ldi r25,lo8(1)
 146 0002 8111      		cpse r24,__zero_reg__
 147 0004 00C0      		rjmp .L17
 148 0006 90E0      		ldi r25,0
 149               	.L17:
 150 0008 9195      		neg r25
 151               	.LVL18:
 152 000a E0E0      		ldi r30,lo8(LCD_Data)
 153 000c F0E0      		ldi r31,hi8(LCD_Data)
 154 000e 84E1      		ldi r24,lo8(20)
 155 0010 8E0F      		add r24,r30
 156               	.LVL19:
 157               	.L18:
 257:src/drv/LCD_driver.c ****         show = 0xFF;
 258:src/drv/LCD_driver.c **** 
 259:src/drv/LCD_driver.c ****     // Set/clear all bits in all LCD registers
 260:src/drv/LCD_driver.c ****     for (i=0; i < LCD_REGISTER_COUNT; i++)
 261:src/drv/LCD_driver.c ****         *(LCD_Data + i) = show;
 158               		.loc 1 261 0 discriminator 3
 159 0012 9193      		st Z+,r25
 160               	.LVL20:
 260:src/drv/LCD_driver.c ****         *(LCD_Data + i) = show;
 161               		.loc 1 260 0 discriminator 3
 162 0014 8E13      		cpse r24,r30
 163 0016 00C0      		rjmp .L18
 164               	/* epilogue start */
 262:src/drv/LCD_driver.c **** }
 165               		.loc 1 262 0
 166 0018 0895      		ret
 167               		.cfi_endproc
 168               	.LFE3:
 170               		.section	.text.LCD_Init,"ax",@progbits
 171               	.global	LCD_Init
 173               	LCD_Init:
 174               	.LFB1:
 151:src/drv/LCD_driver.c ****     LCD_AllSegments(FALSE);                     // Clear segment buffer.
 175               		.loc 1 151 0
 176               		.cfi_startproc
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 152:src/drv/LCD_driver.c **** 
 181               		.loc 1 152 0
 182 0000 80E0      		ldi r24,0
 183 0002 0E94 0000 		call LCD_AllSegments
 184               	.LVL21:
 154:src/drv/LCD_driver.c **** 
 185               		.loc 1 154 0
 186 0006 E7EE      		ldi r30,lo8(-25)
 187 0008 F0E0      		ldi r31,0
 188 000a 8081      		ld r24,Z
 189 000c 8F60      		ori r24,lo8(15)
 190 000e 8083      		st Z,r24
 158:src/drv/LCD_driver.c **** 
 191               		.loc 1 158 0
 192 0010 87EB      		ldi r24,lo8(-73)
 193 0012 8093 E500 		sts 229,r24
 161:src/drv/LCD_driver.c **** 
 194               		.loc 1 161 0
 195 0016 87E0      		ldi r24,lo8(7)
 196 0018 8093 E600 		sts 230,r24
 163:src/drv/LCD_driver.c **** 
 197               		.loc 1 163 0
 198 001c A4EE      		ldi r26,lo8(-28)
 199 001e B0E0      		ldi r27,0
 200 0020 80EC      		ldi r24,lo8(-64)
 201 0022 8C93      		st X,r24
 166:src/drv/LCD_driver.c **** 
 202               		.loc 1 166 0
 203 0024 8C91      		ld r24,X
 204 0026 8860      		ori r24,lo8(8)
 205 0028 8C93      		st X,r24
 171:src/drv/LCD_driver.c **** 
 206               		.loc 1 171 0
 207 002a 8081      		ld r24,Z
 208 002c 806E      		ori r24,lo8(-32)
 209 002e 8083      		st Z,r24
 173:src/drv/LCD_driver.c **** 
 210               		.loc 1 173 0
 211 0030 1092 0000 		sts gLCD_Update_Required,__zero_reg__
 212 0034 0895      		ret
 213               		.cfi_endproc
 214               	.LFE1:
 216               		.section	.text.__vector_22,"ax",@progbits
 217               	.global	__vector_22
 219               	__vector_22:
 220               	.LFB4:
 263:src/drv/LCD_driver.c **** 
 264:src/drv/LCD_driver.c **** 
 265:src/drv/LCD_driver.c **** /*****************************************************************************
 266:src/drv/LCD_driver.c **** *
 267:src/drv/LCD_driver.c **** *   LCD Interrupt Routine
 268:src/drv/LCD_driver.c **** *
 269:src/drv/LCD_driver.c **** *   Returns :       None
 270:src/drv/LCD_driver.c **** *
 271:src/drv/LCD_driver.c **** *   Parameters :    None
 272:src/drv/LCD_driver.c **** *
 273:src/drv/LCD_driver.c **** *   Purpose: Latch the LCD_displayData and Set LCD_status.updateComplete
 274:src/drv/LCD_driver.c **** *
 275:src/drv/LCD_driver.c **** *****************************************************************************/
 276:src/drv/LCD_driver.c **** 
 277:src/drv/LCD_driver.c **** ISR(LCD_vect)
 278:src/drv/LCD_driver.c **** {
 221               		.loc 1 278 0
 222               		.cfi_startproc
 223 0000 1F92      		push r1
 224               	.LCFI0:
 225               		.cfi_def_cfa_offset 3
 226               		.cfi_offset 1, -2
 227 0002 0F92      		push r0
 228               	.LCFI1:
 229               		.cfi_def_cfa_offset 4
 230               		.cfi_offset 0, -3
 231 0004 0FB6      		in r0,__SREG__
 232 0006 0F92      		push r0
 233 0008 1124      		clr __zero_reg__
 234 000a FF92      		push r15
 235               	.LCFI2:
 236               		.cfi_def_cfa_offset 5
 237               		.cfi_offset 15, -4
 238 000c 0F93      		push r16
 239               	.LCFI3:
 240               		.cfi_def_cfa_offset 6
 241               		.cfi_offset 16, -5
 242 000e 1F93      		push r17
 243               	.LCFI4:
 244               		.cfi_def_cfa_offset 7
 245               		.cfi_offset 17, -6
 246 0010 2F93      		push r18
 247               	.LCFI5:
 248               		.cfi_def_cfa_offset 8
 249               		.cfi_offset 18, -7
 250 0012 3F93      		push r19
 251               	.LCFI6:
 252               		.cfi_def_cfa_offset 9
 253               		.cfi_offset 19, -8
 254 0014 4F93      		push r20
 255               	.LCFI7:
 256               		.cfi_def_cfa_offset 10
 257               		.cfi_offset 20, -9
 258 0016 5F93      		push r21
 259               	.LCFI8:
 260               		.cfi_def_cfa_offset 11
 261               		.cfi_offset 21, -10
 262 0018 6F93      		push r22
 263               	.LCFI9:
 264               		.cfi_def_cfa_offset 12
 265               		.cfi_offset 22, -11
 266 001a 7F93      		push r23
 267               	.LCFI10:
 268               		.cfi_def_cfa_offset 13
 269               		.cfi_offset 23, -12
 270 001c 8F93      		push r24
 271               	.LCFI11:
 272               		.cfi_def_cfa_offset 14
 273               		.cfi_offset 24, -13
 274 001e 9F93      		push r25
 275               	.LCFI12:
 276               		.cfi_def_cfa_offset 15
 277               		.cfi_offset 25, -14
 278 0020 AF93      		push r26
 279               	.LCFI13:
 280               		.cfi_def_cfa_offset 16
 281               		.cfi_offset 26, -15
 282 0022 BF93      		push r27
 283               	.LCFI14:
 284               		.cfi_def_cfa_offset 17
 285               		.cfi_offset 27, -16
 286 0024 CF93      		push r28
 287               	.LCFI15:
 288               		.cfi_def_cfa_offset 18
 289               		.cfi_offset 28, -17
 290 0026 DF93      		push r29
 291               	.LCFI16:
 292               		.cfi_def_cfa_offset 19
 293               		.cfi_offset 29, -18
 294 0028 EF93      		push r30
 295               	.LCFI17:
 296               		.cfi_def_cfa_offset 20
 297               		.cfi_offset 30, -19
 298 002a FF93      		push r31
 299               	.LCFI18:
 300               		.cfi_def_cfa_offset 21
 301               		.cfi_offset 31, -20
 302               	/* prologue: Signal */
 303               	/* frame size = 0 */
 304               	/* stack size = 20 */
 305               	.L__stack_usage = 20
 306               	.LVL22:
 279:src/drv/LCD_driver.c ****     static char LCD_timer = LCD_TIMER_SEED;
 280:src/drv/LCD_driver.c ****     char c;
 281:src/drv/LCD_driver.c ****     char c_flash;
 282:src/drv/LCD_driver.c ****     char flash;
 283:src/drv/LCD_driver.c **** 
 284:src/drv/LCD_driver.c ****     char EOL;
 285:src/drv/LCD_driver.c ****     unsigned char i;
 286:src/drv/LCD_driver.c **** 
 287:src/drv/LCD_driver.c ****     static char timeout_count;
 288:src/drv/LCD_driver.c ****     static char auto_joystick_count;
 289:src/drv/LCD_driver.c **** 
 290:src/drv/LCD_driver.c ****     c_flash=0; // mt
 291:src/drv/LCD_driver.c ****     
 292:src/drv/LCD_driver.c **** /**************** Button timeout for the button.c, START ****************/
 293:src/drv/LCD_driver.c ****     if(!gButtonTimeout)
 307               		.loc 1 293 0
 308 002c 8091 0000 		lds r24,gButtonTimeout
 309 0030 8111      		cpse r24,__zero_reg__
 310 0032 00C0      		rjmp .L23
 294:src/drv/LCD_driver.c ****     {
 295:src/drv/LCD_driver.c ****         timeout_count++;
 311               		.loc 1 295 0
 312 0034 8091 0000 		lds r24,timeout_count.1760
 313 0038 8F5F      		subi r24,lo8(-(1))
 314 003a 8093 0000 		sts timeout_count.1760,r24
 296:src/drv/LCD_driver.c ****         
 297:src/drv/LCD_driver.c ****         if(timeout_count > 3)
 315               		.loc 1 297 0
 316 003e 8430      		cpi r24,lo8(4)
 317 0040 00F0      		brlo .L23
 298:src/drv/LCD_driver.c ****         {
 299:src/drv/LCD_driver.c ****             gButtonTimeout = TRUE;
 318               		.loc 1 299 0
 319 0042 81E0      		ldi r24,lo8(1)
 320 0044 8093 0000 		sts gButtonTimeout,r24
 300:src/drv/LCD_driver.c ****             timeout_count = 0;
 321               		.loc 1 300 0
 322 0048 1092 0000 		sts timeout_count.1760,__zero_reg__
 323               	.L23:
 301:src/drv/LCD_driver.c ****         }
 302:src/drv/LCD_driver.c ****     }
 303:src/drv/LCD_driver.c **** 
 304:src/drv/LCD_driver.c **** /**************** Button timeout for the button.c, END ******************/
 305:src/drv/LCD_driver.c **** 
 306:src/drv/LCD_driver.c **** /**************** Auto press joystick for the main.c, START *************/
 307:src/drv/LCD_driver.c **** 
 308:src/drv/LCD_driver.c ****     if(gAutoPressJoystick == AUTO)
 324               		.loc 1 308 0
 325 004c 8091 0000 		lds r24,gAutoPressJoystick
 326 0050 8330      		cpi r24,lo8(3)
 327 0052 01F4      		brne .L25
 309:src/drv/LCD_driver.c ****     {
 310:src/drv/LCD_driver.c ****         auto_joystick_count++;
 328               		.loc 1 310 0
 329 0054 8091 0000 		lds r24,auto_joystick_count.1761
 330 0058 8F5F      		subi r24,lo8(-(1))
 331 005a 8093 0000 		sts auto_joystick_count.1761,r24
 311:src/drv/LCD_driver.c ****         
 312:src/drv/LCD_driver.c ****         if(auto_joystick_count > 16)
 332               		.loc 1 312 0
 333 005e 8131      		cpi r24,lo8(17)
 334 0060 00F0      		brlo .L26
 313:src/drv/LCD_driver.c ****         {
 314:src/drv/LCD_driver.c ****             gAutoPressJoystick = TRUE;
 335               		.loc 1 314 0
 336 0062 81E0      		ldi r24,lo8(1)
 337 0064 8093 0000 		sts gAutoPressJoystick,r24
 315:src/drv/LCD_driver.c ****             auto_joystick_count = 15;
 338               		.loc 1 315 0
 339 0068 8FE0      		ldi r24,lo8(15)
 340 006a 8093 0000 		sts auto_joystick_count.1761,r24
 341 006e 00C0      		rjmp .L26
 342               	.L25:
 316:src/drv/LCD_driver.c ****         }
 317:src/drv/LCD_driver.c ****     }
 318:src/drv/LCD_driver.c ****     else
 319:src/drv/LCD_driver.c ****         auto_joystick_count = 0;
 343               		.loc 1 319 0
 344 0070 1092 0000 		sts auto_joystick_count.1761,__zero_reg__
 345               	.L26:
 320:src/drv/LCD_driver.c **** 
 321:src/drv/LCD_driver.c **** 
 322:src/drv/LCD_driver.c **** /**************** Auto press joystick for the main.c, END ***************/    
 323:src/drv/LCD_driver.c **** 
 324:src/drv/LCD_driver.c ****     LCD_timer--;                    // Decreased every LCD frame
 346               		.loc 1 324 0
 347 0074 8091 0000 		lds r24,LCD_timer.1754
 348 0078 8150      		subi r24,lo8(-(-1))
 349 007a 8093 0000 		sts LCD_timer.1754,r24
 325:src/drv/LCD_driver.c **** 
 326:src/drv/LCD_driver.c ****     if (gScrollMode)
 350               		.loc 1 326 0
 351 007e 9091 0000 		lds r25,gScrollMode
 352 0082 9923      		tst r25
 353 0084 01F0      		breq .L27
 327:src/drv/LCD_driver.c ****     {
 328:src/drv/LCD_driver.c ****         // If we are in scroll mode, and the timer has expired,
 329:src/drv/LCD_driver.c ****         // we will update the LCD
 330:src/drv/LCD_driver.c ****         if (LCD_timer == 0)
 354               		.loc 1 330 0
 355 0086 8111      		cpse r24,__zero_reg__
 356 0088 00C0      		rjmp .L28
 331:src/drv/LCD_driver.c ****         {
 332:src/drv/LCD_driver.c ****             if (gLCD_Start_Scroll_Timer == 0)
 357               		.loc 1 332 0
 358 008a 8091 0000 		lds r24,gLCD_Start_Scroll_Timer
 359 008e 8111      		cpse r24,__zero_reg__
 360 0090 00C0      		rjmp .L29
 333:src/drv/LCD_driver.c ****             {
 334:src/drv/LCD_driver.c ****                 gLCD_Update_Required = TRUE;
 361               		.loc 1 334 0
 362 0092 81E0      		ldi r24,lo8(1)
 363 0094 8093 0000 		sts gLCD_Update_Required,r24
 364 0098 00C0      		rjmp .L28
 365               	.L29:
 335:src/drv/LCD_driver.c ****             }
 336:src/drv/LCD_driver.c ****             else
 337:src/drv/LCD_driver.c ****                 gLCD_Start_Scroll_Timer--;
 366               		.loc 1 337 0
 367 009a 8091 0000 		lds r24,gLCD_Start_Scroll_Timer
 368 009e 8150      		subi r24,lo8(-(-1))
 369 00a0 8093 0000 		sts gLCD_Start_Scroll_Timer,r24
 370 00a4 00C0      		rjmp .L28
 371               	.L27:
 338:src/drv/LCD_driver.c ****         }
 339:src/drv/LCD_driver.c ****     }
 340:src/drv/LCD_driver.c ****     else    
 341:src/drv/LCD_driver.c ****     {   // if not scrolling,
 342:src/drv/LCD_driver.c ****         // disble LCD start of frame interrupt
 343:src/drv/LCD_driver.c ****         // cbi(LCDCRA, LCDIE);   //DEBUG
 344:src/drv/LCD_driver.c ****         gScroll = 0;
 372               		.loc 1 344 0
 373 00a6 1092 0000 		sts gScroll,__zero_reg__
 374               	.L28:
 375               	.LVL23:
 345:src/drv/LCD_driver.c ****     }
 346:src/drv/LCD_driver.c **** 
 347:src/drv/LCD_driver.c **** 
 348:src/drv/LCD_driver.c ****     EOL = FALSE;
 349:src/drv/LCD_driver.c ****     if (gLCD_Update_Required == TRUE)
 376               		.loc 1 349 0
 377 00aa 8091 0000 		lds r24,gLCD_Update_Required
 378 00ae 8130      		cpi r24,lo8(1)
 379 00b0 01F0      		breq .+2
 380 00b2 00C0      		rjmp .L30
 350:src/drv/LCD_driver.c ****     {
 351:src/drv/LCD_driver.c ****         // Duty cycle of flashing characters
 352:src/drv/LCD_driver.c ****         if (gFlashTimer < (LCD_FLASH_SEED >> 1))
 381               		.loc 1 352 0
 382 00b4 F090 0000 		lds r15,gFlashTimer
 383               	.LVL24:
 384 00b8 C0E0      		ldi r28,0
 385 00ba D0E0      		ldi r29,0
 348:src/drv/LCD_driver.c ****     if (gLCD_Update_Required == TRUE)
 386               		.loc 1 348 0
 387 00bc 10E0      		ldi r17,0
 290:src/drv/LCD_driver.c ****     
 388               		.loc 1 290 0
 389 00be 00E0      		ldi r16,0
 390               	.LVL25:
 391               	.L34:
 392 00c0 6C2F      		mov r22,r28
 393               	.LVL26:
 353:src/drv/LCD_driver.c ****             flash = 0;
 354:src/drv/LCD_driver.c ****         else
 355:src/drv/LCD_driver.c ****             flash = 1;
 356:src/drv/LCD_driver.c **** 
 357:src/drv/LCD_driver.c ****         // Repeat for the six LCD characters
 358:src/drv/LCD_driver.c ****         for (i = 0; i < 6; i++)
 359:src/drv/LCD_driver.c ****         {
 360:src/drv/LCD_driver.c ****             if ((gScroll+i) >= 0 && (!EOL))
 394               		.loc 1 360 0
 395 00c2 8091 0000 		lds r24,gScroll
 396 00c6 9E01      		movw r18,r28
 397 00c8 280F      		add r18,r24
 398 00ca 311D      		adc r19,__zero_reg__
 399 00cc 87FD      		sbrc r24,7
 400 00ce 3A95      		dec r19
 401 00d0 37FD      		sbrc r19,7
 402 00d2 00C0      		rjmp .L44
 403               		.loc 1 360 0 is_stmt 0 discriminator 1
 404 00d4 1111      		cpse r17,__zero_reg__
 405 00d6 00C0      		rjmp .L44
 361:src/drv/LCD_driver.c ****             {
 362:src/drv/LCD_driver.c ****                 // We have some visible characters
 363:src/drv/LCD_driver.c ****                 c = gTextBuffer[i + gScroll];
 406               		.loc 1 363 0 is_stmt 1
 407 00d8 8091 0000 		lds r24,gScroll
 408 00dc FE01      		movw r30,r28
 409 00de E80F      		add r30,r24
 410 00e0 F11D      		adc r31,__zero_reg__
 411 00e2 87FD      		sbrc r24,7
 412 00e4 FA95      		dec r31
 413 00e6 E050      		subi r30,lo8(-(gTextBuffer))
 414 00e8 F040      		sbci r31,hi8(-(gTextBuffer))
 415 00ea 8081      		ld r24,Z
 416               	.LVL27:
 364:src/drv/LCD_driver.c ****                 c_flash = c & 0x80 ? 1 : 0;
 417               		.loc 1 364 0
 418 00ec 082F      		mov r16,r24
 419               	.LVL28:
 420 00ee 001F      		rol r16
 421 00f0 0027      		clr r16
 422 00f2 001F      		rol r16
 423               	.LVL29:
 365:src/drv/LCD_driver.c ****                 c = c & 0x7F;
 424               		.loc 1 365 0
 425 00f4 8F77      		andi r24,lo8(127)
 426               	.LVL30:
 366:src/drv/LCD_driver.c **** 
 367:src/drv/LCD_driver.c ****                 if (c == '\0')
 427               		.loc 1 367 0
 428 00f6 01F4      		brne .L31
 429 00f8 11E0      		ldi r17,lo8(1)
 430               	.LVL31:
 431 00fa 1C0F      		add r17,r28
 432               	.LVL32:
 433 00fc 00C0      		rjmp .L31
 434               	.LVL33:
 435               	.L44:
 368:src/drv/LCD_driver.c ****                     EOL = i+1;      // End of character data
 369:src/drv/LCD_driver.c ****             }
 370:src/drv/LCD_driver.c ****             else
 371:src/drv/LCD_driver.c ****                 c = ' ';
 436               		.loc 1 371 0
 437 00fe 80E2      		ldi r24,lo8(32)
 438               	.L31:
 439               	.LVL34:
 372:src/drv/LCD_driver.c **** 
 373:src/drv/LCD_driver.c ****             // Check if this character is flashing
 374:src/drv/LCD_driver.c **** 
 375:src/drv/LCD_driver.c ****             if (c_flash && flash)
 440               		.loc 1 375 0
 441 0100 0023      		tst r16
 442 0102 01F0      		breq .L32
 443               		.loc 1 375 0 is_stmt 0 discriminator 1
 444 0104 34E0      		ldi r19,lo8(4)
 445 0106 3F15      		cp r19,r15
 446 0108 00F4      		brsh .L32
 376:src/drv/LCD_driver.c ****                 LCD_WriteDigit(' ', i);
 447               		.loc 1 376 0 is_stmt 1
 448 010a 80E2      		ldi r24,lo8(32)
 449               	.LVL35:
 450               	.L32:
 377:src/drv/LCD_driver.c ****             else
 378:src/drv/LCD_driver.c ****                 LCD_WriteDigit(c, i);
 451               		.loc 1 378 0
 452 010c 0E94 0000 		call LCD_WriteDigit
 453               	.LVL36:
 454 0110 2196      		adiw r28,1
 455               	.LVL37:
 358:src/drv/LCD_driver.c ****         {
 456               		.loc 1 358 0
 457 0112 C630      		cpi r28,6
 458 0114 D105      		cpc r29,__zero_reg__
 459 0116 01F4      		brne .L34
 460               	.LVL38:
 461 0118 ECEE      		ldi r30,lo8(-20)
 462 011a F0E0      		ldi r31,0
 463               	.LVL39:
 464               	.L35:
 465 011c DF01      		movw r26,r30
 466 011e A050      		subi r26,lo8(-(LCD_Data-236))
 467 0120 B040      		sbci r27,hi8(-(LCD_Data-236))
 379:src/drv/LCD_driver.c ****         }
 380:src/drv/LCD_driver.c **** 
 381:src/drv/LCD_driver.c ****         // Copy the segment buffer to the real segments
 382:src/drv/LCD_driver.c ****         for (i = 0; i < LCD_REGISTER_COUNT; i++)
 383:src/drv/LCD_driver.c ****             *(pLCDREG + i) = *(LCD_Data+i);
 468               		.loc 1 383 0 discriminator 3
 469 0122 8C91      		ld r24,X
 470 0124 8193      		st Z+,r24
 471               	.LVL40:
 382:src/drv/LCD_driver.c ****             *(pLCDREG + i) = *(LCD_Data+i);
 472               		.loc 1 382 0 discriminator 3
 473 0126 E115      		cp r30,__zero_reg__
 474 0128 81E0      		ldi r24,1
 475 012a F807      		cpc r31,r24
 476 012c 01F4      		brne .L35
 384:src/drv/LCD_driver.c **** 
 385:src/drv/LCD_driver.c ****         // Handle colon
 386:src/drv/LCD_driver.c ****         if (gColon)
 477               		.loc 1 386 0
 478 012e 8091 0000 		lds r24,gColon
 479 0132 8823      		tst r24
 480 0134 01F0      		breq .L36
 387:src/drv/LCD_driver.c ****             *(pLCDREG + 8) = 0x01;
 481               		.loc 1 387 0
 482 0136 81E0      		ldi r24,lo8(1)
 483 0138 8093 F400 		sts 244,r24
 484 013c 00C0      		rjmp .L37
 485               	.L36:
 388:src/drv/LCD_driver.c ****         else
 389:src/drv/LCD_driver.c ****             *(pLCDREG + 8) = 0x00;
 486               		.loc 1 389 0
 487 013e 1092 F400 		sts 244,__zero_reg__
 488               	.L37:
 390:src/drv/LCD_driver.c **** 
 391:src/drv/LCD_driver.c ****         // If the text scrolled off the display,
 392:src/drv/LCD_driver.c ****         // we have to start over again.
 393:src/drv/LCD_driver.c ****         if (EOL == 1)
 489               		.loc 1 393 0
 490 0142 1130      		cpi r17,lo8(1)
 491 0144 01F4      		brne .L38
 394:src/drv/LCD_driver.c ****             gScroll = -6;
 492               		.loc 1 394 0
 493 0146 8AEF      		ldi r24,lo8(-6)
 494 0148 00C0      		rjmp .L50
 495               	.L38:
 395:src/drv/LCD_driver.c ****         else
 396:src/drv/LCD_driver.c ****             gScroll++;
 496               		.loc 1 396 0
 497 014a 8091 0000 		lds r24,gScroll
 498 014e 8F5F      		subi r24,lo8(-(1))
 499               	.L50:
 500 0150 8093 0000 		sts gScroll,r24
 397:src/drv/LCD_driver.c **** 
 398:src/drv/LCD_driver.c ****         // No need to update anymore
 399:src/drv/LCD_driver.c ****         gLCD_Update_Required = FALSE;
 501               		.loc 1 399 0
 502 0154 1092 0000 		sts gLCD_Update_Required,__zero_reg__
 503               	.LVL41:
 504               	.L30:
 400:src/drv/LCD_driver.c ****     }
 401:src/drv/LCD_driver.c **** 
 402:src/drv/LCD_driver.c **** 
 403:src/drv/LCD_driver.c ****     // LCD_timer is used when scrolling text
 404:src/drv/LCD_driver.c ****     if (LCD_timer == 0)
 505               		.loc 1 404 0
 506 0158 8091 0000 		lds r24,LCD_timer.1754
 507 015c 8111      		cpse r24,__zero_reg__
 508 015e 00C0      		rjmp .L40
 405:src/drv/LCD_driver.c ****     {
 406:src/drv/LCD_driver.c **** /*        if ((gScroll <= 0) || EOL)
 407:src/drv/LCD_driver.c ****             LCD_timer = LCD_TIMER_SEED/2;
 408:src/drv/LCD_driver.c ****         else*/
 409:src/drv/LCD_driver.c ****             LCD_timer = LCD_TIMER_SEED;
 509               		.loc 1 409 0
 510 0160 83E0      		ldi r24,lo8(3)
 511 0162 8093 0000 		sts LCD_timer.1754,r24
 512               	.L40:
 410:src/drv/LCD_driver.c ****     }
 411:src/drv/LCD_driver.c **** 
 412:src/drv/LCD_driver.c ****     // gFlashTimer is used when flashing characters
 413:src/drv/LCD_driver.c ****     if (gFlashTimer == LCD_FLASH_SEED)
 513               		.loc 1 413 0
 514 0166 8091 0000 		lds r24,gFlashTimer
 515 016a 8A30      		cpi r24,lo8(10)
 516 016c 01F4      		brne .L41
 414:src/drv/LCD_driver.c ****         gFlashTimer= 0;
 517               		.loc 1 414 0
 518 016e 1092 0000 		sts gFlashTimer,__zero_reg__
 519 0172 00C0      		rjmp .L21
 520               	.L41:
 415:src/drv/LCD_driver.c ****     else
 416:src/drv/LCD_driver.c ****         gFlashTimer++;
 521               		.loc 1 416 0
 522 0174 8091 0000 		lds r24,gFlashTimer
 523 0178 8F5F      		subi r24,lo8(-(1))
 524 017a 8093 0000 		sts gFlashTimer,r24
 525               	.L21:
 526               	/* epilogue start */
 417:src/drv/LCD_driver.c **** 
 418:src/drv/LCD_driver.c **** }
 527               		.loc 1 418 0
 528 017e FF91      		pop r31
 529 0180 EF91      		pop r30
 530 0182 DF91      		pop r29
 531 0184 CF91      		pop r28
 532 0186 BF91      		pop r27
 533 0188 AF91      		pop r26
 534 018a 9F91      		pop r25
 535 018c 8F91      		pop r24
 536 018e 7F91      		pop r23
 537 0190 6F91      		pop r22
 538 0192 5F91      		pop r21
 539 0194 4F91      		pop r20
 540 0196 3F91      		pop r19
 541 0198 2F91      		pop r18
 542 019a 1F91      		pop r17
 543 019c 0F91      		pop r16
 544 019e FF90      		pop r15
 545 01a0 0F90      		pop r0
 546 01a2 0FBE      		out __SREG__,r0
 547 01a4 0F90      		pop r0
 548 01a6 1F90      		pop r1
 549 01a8 1895      		reti
 550               		.cfi_endproc
 551               	.LFE4:
 553               		.section	.data.LCD_timer.1754,"aw",@progbits
 556               	LCD_timer.1754:
 557 0000 03        		.byte	3
 558               		.section	.bss.auto_joystick_count.1761,"aw",@nobits
 561               	auto_joystick_count.1761:
 562 0000 00        		.zero	1
 563               		.section	.bss.timeout_count.1760,"aw",@nobits
 566               	timeout_count.1760:
 567 0000 00        		.zero	1
 568               	.global	LCD_character_table
 569               		.section	.progmem.data.LCD_character_table,"a",@progbits
 572               	LCD_character_table:
 573 0000 510A      		.word	2641
 574 0002 802A      		.word	10880
 575 0004 0000      		.word	0
 576 0006 000A      		.word	2560
 577 0008 510A      		.word	2641
 578 000a 0000      		.word	0
 579 000c 5955      		.word	21849
 580 000e 1801      		.word	280
 581 0010 111E      		.word	7697
 582 0012 111B      		.word	6929
 583 0014 500B      		.word	2896
 584 0016 411B      		.word	6977
 585 0018 411F      		.word	8001
 586 001a 1101      		.word	273
 587 001c 511F      		.word	8017
 588 001e 511B      		.word	6993
 589 0020 0000      		.word	0
 590 0022 0000      		.word	0
 591 0024 0000      		.word	0
 592 0026 0000      		.word	0
 593 0028 0000      		.word	0
 594 002a 0000      		.word	0
 595 002c 0000      		.word	0
 596 002e 510F      		.word	3921
 597 0030 9139      		.word	14737
 598 0032 4114      		.word	5185
 599 0034 9131      		.word	12689
 600 0036 411E      		.word	7745
 601 0038 410E      		.word	3649
 602 003a 411D      		.word	7489
 603 003c 500F      		.word	3920
 604 003e 8020      		.word	8320
 605 0040 1015      		.word	5392
 606 0042 4886      		.word	-31160
 607 0044 4014      		.word	5184
 608 0046 7805      		.word	1400
 609 0048 7085      		.word	-31376
 610 004a 5115      		.word	5457
 611 004c 510E      		.word	3665
 612 004e 5195      		.word	-27311
 613 0050 518E      		.word	-29103
 614 0052 2190      		.word	-28639
 615 0054 8120      		.word	8321
 616 0056 5015      		.word	5456
 617 0058 4844      		.word	17480
 618 005a 50C5      		.word	-15024
 619 005c 28C0      		.word	-16344
 620 005e 2820      		.word	8232
 621 0060 0950      		.word	20489
 622 0062 0000      		.word	0
 623 0064 0000      		.word	0
 624 0066 0000      		.word	0
 625 0068 0000      		.word	0
 626 006a 0000      		.word	0
 627               	.global	gColon
 628               		.section	.bss.gColon,"aw",@nobits
 631               	gColon:
 632 0000 00        		.zero	1
 633               	.global	gFlashTimer
 634               		.section	.bss.gFlashTimer,"aw",@nobits
 637               	gFlashTimer:
 638 0000 00        		.zero	1
 639               	.global	gLCD_Start_Scroll_Timer
 640               		.section	.bss.gLCD_Start_Scroll_Timer,"aw",@nobits
 643               	gLCD_Start_Scroll_Timer:
 644 0000 00        		.zero	1
 645               		.comm	gScrollMode,1,1
 646               		.comm	gScroll,1,1
 647               		.comm	gTextBuffer,25,1
 648               		.comm	LCD_Data,20,1
 649               	.global	gLCD_Update_Required
 650               		.section	.bss.gLCD_Update_Required,"aw",@nobits
 653               	gLCD_Update_Required:
 654 0000 00        		.zero	1
 655               	.global	gAutoPressJoystick
 656               		.section	.bss.gAutoPressJoystick,"aw",@nobits
 659               	gAutoPressJoystick:
 660 0000 00        		.zero	1
 661               		.text
 662               	.Letext0:
 663               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD_driver.c
     /tmp/ccvFSjQs.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccvFSjQs.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccvFSjQs.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccvFSjQs.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccvFSjQs.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccvFSjQs.s:13     .text.LCD_WriteDigit:0000000000000000 LCD_WriteDigit
     /tmp/ccvFSjQs.s:572    .progmem.data.LCD_character_table:0000000000000000 LCD_character_table
                            *COM*:0000000000000014 LCD_Data
     /tmp/ccvFSjQs.s:135    .text.LCD_AllSegments:0000000000000000 LCD_AllSegments
     /tmp/ccvFSjQs.s:173    .text.LCD_Init:0000000000000000 LCD_Init
     /tmp/ccvFSjQs.s:653    .bss.gLCD_Update_Required:0000000000000000 gLCD_Update_Required
     /tmp/ccvFSjQs.s:219    .text.__vector_22:0000000000000000 __vector_22
     /tmp/ccvFSjQs.s:566    .bss.timeout_count.1760:0000000000000000 timeout_count.1760
     /tmp/ccvFSjQs.s:659    .bss.gAutoPressJoystick:0000000000000000 gAutoPressJoystick
     /tmp/ccvFSjQs.s:561    .bss.auto_joystick_count.1761:0000000000000000 auto_joystick_count.1761
     /tmp/ccvFSjQs.s:556    .data.LCD_timer.1754:0000000000000000 LCD_timer.1754
                            *COM*:0000000000000001 gScrollMode
     /tmp/ccvFSjQs.s:643    .bss.gLCD_Start_Scroll_Timer:0000000000000000 gLCD_Start_Scroll_Timer
                            *COM*:0000000000000001 gScroll
     /tmp/ccvFSjQs.s:637    .bss.gFlashTimer:0000000000000000 gFlashTimer
                            *COM*:0000000000000019 gTextBuffer
     /tmp/ccvFSjQs.s:631    .bss.gColon:0000000000000000 gColon

UNDEFINED SYMBOLS
gButtonTimeout
__do_copy_data
__do_clear_bss


main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002e4c  00002ee0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e4c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000064  00800146  00800146  00002f26  2**0
                  ALLOC
  3 .debug_aranges 00000390  00000000  00000000  00002f26  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000c09  00000000  00000000  000032b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002ebf  00000000  00000000  00003ebf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000e94  00000000  00000000  00006d7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002fbb  00000000  00000000  00007c12  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000580  00000000  00000000  0000abd0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000c67  00000000  00000000  0000b150  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001739  00000000  00000000  0000bdb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000328  00000000  00000000  0000d4f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

    return 0;
}

void Timer0_SetCountdownTimer(char timer, char value)
{
       0:	da c5       	rjmp	.+2996   	; 0xbb6 <__ctors_end>
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char Usart_Rx(void)
{
       2:	00 00       	nop
*
*	Purpose :		Transfers a page from flash to dataflash SRAM buffer
*					
******************************************************************************/
void Page_To_Buffer (unsigned int PageAdr, unsigned char BufferNo)
{
       4:	f4 c5       	rjmp	.+3048   	; 0xbee <__bad_interrupt>
*
*	Purpose :		Writes a string to the LCD
*
*****************************************************************************/
void LCD_puts(char *pStr, char scrollmode)
{
       6:	00 00       	nop
       8:	0c 94 9d 10 	jmp	0x213a	; 0x213a <__vector_2>
       c:	0c 94 7a 10 	jmp	0x20f4	; 0x20f4 <__vector_3>
      10:	ee c5       	rjmp	.+3036   	; 0xbee <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 46 0b 	jmp	0x168c	; 0x168c <__vector_5>
      18:	ea c5       	rjmp	.+3028   	; 0xbee <__bad_interrupt>
      1a:	00 00       	nop
      1c:	e8 c5       	rjmp	.+3024   	; 0xbee <__bad_interrupt>
      1e:	00 00       	nop
      20:	e6 c5       	rjmp	.+3020   	; 0xbee <__bad_interrupt>
      22:	00 00       	nop
      24:	e4 c5       	rjmp	.+3016   	; 0xbee <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <__vector_10>
      2c:	e0 c5       	rjmp	.+3008   	; 0xbee <__bad_interrupt>
      2e:	00 00       	nop
      30:	de c5       	rjmp	.+3004   	; 0xbee <__bad_interrupt>
      32:	00 00       	nop
      34:	dc c5       	rjmp	.+3000   	; 0xbee <__bad_interrupt>
      36:	00 00       	nop
      38:	da c5       	rjmp	.+2996   	; 0xbee <__bad_interrupt>
      3a:	00 00       	nop
      3c:	d8 c5       	rjmp	.+2992   	; 0xbee <__bad_interrupt>
      3e:	00 00       	nop
      40:	d6 c5       	rjmp	.+2988   	; 0xbee <__bad_interrupt>
      42:	00 00       	nop
      44:	d4 c5       	rjmp	.+2984   	; 0xbee <__bad_interrupt>
      46:	00 00       	nop
      48:	d2 c5       	rjmp	.+2980   	; 0xbee <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d0 c5       	rjmp	.+2976   	; 0xbee <__bad_interrupt>
      4e:	00 00       	nop
      50:	ce c5       	rjmp	.+2972   	; 0xbee <__bad_interrupt>
      52:	00 00       	nop
      54:	cc c5       	rjmp	.+2968   	; 0xbee <__bad_interrupt>
      56:	00 00       	nop
      58:	0c 94 f4 11 	jmp	0x23e8	; 0x23e8 <__vector_22>

0000005c <MT_AVRBF>:
	...

0000005d <MT_TIME>:
      5d:	54 69 6d 65 00                                      Time.

00000062 <MT_TIME_CLOCK>:
      62:	43 6c 6f 63 6b 00                                   Clock.

00000068 <MT_TIME_CLOCK_ADJUST>:
      68:	41 64 6a 75 73 74 20 43 6c 6f 63 6b 00              Adjust Clock.

00000075 <MT_TIME_CLOCKFORMAT_ADJUST>:
      75:	43 68 61 6e 67 65 20 43 6c 6f 63 6b 20 46 6f 72     Change Clock For
      85:	6d 61 74 00                                         mat.

00000089 <MT_TIME_DATE>:
      89:	44 61 74 65 00                                      Date.

0000008e <MT_TIME_DATE_ADJUST>:
      8e:	41 64 6a 75 73 74 20 44 61 74 65 00                 Adjust Date.

0000009a <MT_TIME_DATEFORMAT_ADJUST>:
      9a:	43 68 61 6e 67 65 20 44 61 74 65 20 46 6f 72 6d     Change Date Form
      aa:	61 74 00                                            at.

000000ad <MT_MUSIC>:
      ad:	4d 75 73 69 63 00                                   Music.

000000b3 <MT_TEMPERATURE>:
      b3:	54 65 6d 70 65 72 61 74 75 72 65 00                 Temperature.

000000bf <MT_VOLTAGE>:
      bf:	56 6f 6c 74 61 67 65 00                             Voltage.

000000c7 <MT_LIGHT>:
      c7:	4c 69 67 68 74 00                                   Light.

000000cd <MT_OPTIONS>:
      cd:	4f 70 74 69 6f 6e 73 00                             Options.

000000d5 <MT_OPTIONS_DISPLAY>:
      d5:	44 69 73 70 6c 61 79 00                             Display.

000000dd <MT_OPTIONS_DISPLAY_CONTRAST>:
      dd:	41 64 6a 75 73 74 20 63 6f 6e 74 72 61 73 74 00     Adjust contrast.

000000ed <MT_OPTIONS_BOOT>:
      ed:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

000000f8 <MT_OPTIONS_POWER_SAVE>:
      f8:	50 6f 77 65 72 20 53 61 76 65 20 4d 6f 64 65 00     Power Save Mode.

00000108 <MT_OPTIONS_AUTO_POWER_SAVE>:
     108:	41 75 74 6f 20 50 6f 77 65 72 20 53 61 76 65 00     Auto Power Save.

00000118 <MT_OPTIONS_KEYCLICK>:
     118:	4b 65 79 20 43 6c 69 63 6b 00                       Key Click.

00000122 <menu_nextstate>:
     122:	14 04 5a 14 02 15 14 05 28 15 04 1b 15 02 16 15     ..Z.....(.......
     132:	03 14 15 05 1b 17 04 19 17 01 18 17 03 16 17 05     ................
     142:	19 19 04 17 19 01 24 19 03 16 19 05 17 1b 04 15     ......$.........
     152:	1b 02 1c 1b 03 14 1b 05 15 1d 04 1f 1d 01 1e 1d     ................
     162:	03 1c 1d 05 1f 1f 04 1d 1f 01 20 1f 03 1c 1f 05     .......... .....
     172:	1d 28 04 14 28 02 2a 28 05 3c 29 02 2a 29 03 28     .(..(.*(.<).*).(
     182:	3c 04 28 3c 02 3d 3c 05 46 46 04 3c 46 02 47 46     <.(<.=<.FF.<F.GF
     192:	05 50 50 04 46 50 02 51 50 05 5a 5a 04 50 5a 02     .PP.FP.QP.ZZ.PZ.
     1a2:	5b 5a 05 14 5b 04 64 5b 02 5c 5b 03 5a 5b 05 5e     [Z..[.d[.\[.Z[.^
     1b2:	5c 01 5d 5c 03 5b 5e 04 5b 5e 02 5f 5e 03 5a 5e     \.]\.[^.[^._^.Z^
     1c2:	05 60 60 04 5e 60 02 61 60 03 5a 60 05 62 62 04     .``.^`.a`.Z`.bb.
     1d2:	60 62 02 63 62 03 5a 62 05 64 64 04 62 64 02 65     `b.cb.Zb.dd.bd.e
     1e2:	64 03 5a 64 05 5b 00 00 00                          d.Zd.[...

000001eb <menu_state>:
     1eb:	14 5d 00 00 00 15 62 00 00 00 16 00 00 ee 0e 17     .]....b.........
     1fb:	68 00 00 00 18 00 00 f0 0d 19 75 00 00 00 24 00     h.........u...$.
     20b:	00 22 0c 1b 89 00 00 00 1c 00 00 6e 0d 1d 8e 00     .".........n....
     21b:	00 00 1e 00 00 61 0c 1f 9a 00 00 00 20 00 00 e4     .....a...... ...
     22b:	0b 28 ad 00 00 00 2a 00 00 6a 13 2b 00 00 f6 13     .(....*..j.+....
     23b:	3c b3 00 00 00 3d 00 00 9d 09 46 bf 00 00 00 47     <....=....F....G
     24b:	00 00 7f 09 50 c7 00 00 00 51 00 00 61 09 5a cd     ....P....Q..a.Z.
     25b:	00 00 00 5b d5 00 00 00 5c dd 00 00 00 5d 00 00     ...[....\....]..
     26b:	2f 11 5e ed 00 00 00 5f 00 00 99 06 60 f8 00 00     /.^...._....`...
     27b:	00 61 00 00 7b 06 62 08 01 00 00 63 00 00 11 07     .a..{.b....c....
     28b:	64 18 01 00 00 65 00 00 b5 06 00 00 00 00 00        d....e.........

0000029a <__c.1706>:
     29a:	4f 66 66 00                                         Off.

0000029e <__c.1704>:
     29e:	4f 6e 00                                            On.

000002a1 <__c.1691>:
     2a1:	4f 66 66 00                                         Off.

000002a5 <__c.1689>:
     2a5:	4f 66 66 00                                         Off.

000002a9 <__c.1672>:
     2a9:	50 72 65 73 73 20 65 6e 74 65 72 20 74 6f 20 73     Press enter to s
     2b9:	6c 65 65 70 00                                      leep.

000002be <__c.1662>:
     2be:	4a 75 6d 70 20 74 6f 20 62 6f 6f 74 6c 6f 61 64     Jump to bootload
     2ce:	65 72 00                                            er.

000002d1 <TEMP_Celsius_pos>:
     2d1:	26 03 1c 03 12 03 07 03 fd 02 f2 02 e7 02 dc 02     &...............
     2e1:	d0 02 c5 02 b9 02 ad 02 a1 02 95 02 89 02 7c 02     ..............|.
     2f1:	70 02 63 02 57 02 4a 02 3e 02 32 02 25 02 19 02     p.c.W.J.>.2.%...
     301:	0c 02 00 02 f4 01 e8 01 dc 01 d0 01 c4 01 b8 01     ................
     311:	ad 01 a2 01 96 01 8c 01 81 01 76 01 6c 01 62 01     ..........v.l.b.
     321:	58 01 4e 01 44 01 3b 01 32 01 29 01 20 01 17 01     X.N.D.;.2.). ...
     331:	0f 01 07 01 ff 00 f7 00 f0 00 e9 00 e1 00 db 00     ................
     341:	d4 00 cd 00 c7 00 c1 00 bb 00                       ..........

0000034b <TEMP_Celsius_neg>:
     34b:	2f 03 39 03 42 03 4b 03 53 03 5c 03 64 03 6c 03     /.9.B.K.S.\.d.l.
     35b:	73 03 7b 03 82 03 88 03 8f 03 95 03 9b 03           s.{...........

00000369 <TEMP_Fahrenheit_pos>:
     369:	aa 03 a7 03 a4 03 a1 03 9e 03 9b 03 98 03 94 03     ................
     379:	91 03 8d 03 8a 03 86 03 82 03 7e 03 7b 03 77 03     ..........~.{.w.
     389:	72 03 6e 03 6a 03 66 03 61 03 5d 03 58 03 53 03     r.n.j.f.a.].X.S.
     399:	4f 03 4a 03 45 03 40 03 3b 03 36 03 30 03 2b 03     O.J.E.@.;.6.0.+.
     3a9:	26 03 20 03 1b 03 15 03 0f 03 0a 03 04 03 fe 02     &. .............
     3b9:	f8 02 f2 02 ec 02 e6 02 df 02 d9 02 d3 02 cc 02     ................
     3c9:	c6 02 bf 02 b9 02 b2 02 ac 02 a5 02 9e 02 97 02     ................
     3d9:	91 02 8a 02 83 02 7c 02 75 02 6e 02 68 02 61 02     ......|.u.n.h.a.
     3e9:	5a 02 53 02 4c 02 45 02 3e 02 37 02 30 02 29 02     Z.S.L.E.>.7.0.).
     3f9:	22 02 1b 02 15 02 0e 02 07 02 00 02 f9 01 f2 01     "...............
     409:	ec 01 e5 01 de 01 d8 01 d1 01 cb 01 c4 01 be 01     ................
     419:	b7 01 b1 01 aa 01 a4 01 9e 01 98 01 92 01 8c 01     ................
     429:	86 01 80 01 7a 01 74 01 6e 01 68 01 63 01 5d 01     ....z.t.n.h.c.].
     439:	58 01 52 01 4d 01 47 01 42 01 3d 01 38 01 33 01     X.R.M.G.B.=.8.3.
     449:	2e 01 29 01 24 01 1f 01 1a 01 15 01 11 01 0c 01     ..).$...........
     459:	08 01 03 01 ff 00 fb 00 f6 00 f2 00 ee 00 ea 00     ................
     469:	e6 00 e2 00 de 00 db 00 d7 00 d3 00 cf 00 cc 00     ................
     479:	c8 00 c5 00 c2 00 be 00 bb 00                       ..........

00000483 <LIGHT_ADC>:
     483:	35 00 60 00 80 00 b0 00 1d 01 3d 01 5a 01 7a 01     5.`.......=.Z.z.
     493:	97 01 b9 01 da 01 f9 01 16 02 40 02 6d 02 82 02     ..........@.m...
     4a3:	a2 02 ef 02 32 03 b0 03 f2 03                       ....2.....

000004ad <LIGHT_VOLTAGE>:
     4ad:	1d 5a 34 40 e1 7a 34 40 6a bc 34 40 91 ed 34 40     .Z4@.z4@j.4@..4@
     4bd:	7d 3f 35 40 a4 70 35 40 2d b2 35 40 f2 d2 35 40     }?5@.p5@-.5@..5@
     4cd:	b6 f3 35 40 3f 35 36 40 66 66 36 40 8d 97 36 40     ..5@?56@ff6@..6@
     4dd:	17 d9 36 40 64 3b 37 40 ee 7c 37 40 14 ae 37 40     ..6@d;7@.|7@..7@
     4ed:	9e ef 37 40 b0 72 38 40 e9 26 39 40 21 b0 3a 40     ..7@.r8@.&9@!.:@
     4fd:	93 18 3c 40                                         ..<@

00000501 <EUROPEAN_DATE_TEXT>:
     501:	44 44 4d 4d 59 59 00                                DDMMYY.

00000508 <AMERICAN_DATE_TEXT>:
     508:	4d 4d 44 44 59 59 00                                MMDDYY.

0000050f <CANADIAN_DATE_TEXT>:
     50f:	59 59 4d 4d 44 44 00                                YYMMDD.

00000516 <EUROPEAN_DATE_NR>:
     516:	04 05 02 03 00 01                                   ......

0000051c <AMERICAN_DATE_NR>:
     51c:	04 05 00 01 02 03                                   ......

00000522 <CANADIAN_DATE_NR>:
     522:	00 01 02 03 04 05                                   ......

00000528 <DATE_FORMAT_NR>:
     528:	16 05 1c 05 22 05                                   ....".

0000052e <__c.1546>:
     52e:	31 32 48 00                                         12H.

00000532 <__c.1544>:
     532:	32 34 48 00                                         24H.

00000536 <__c.1542>:
     536:	32 34 48 00                                         24H.

0000053a <__c.1540>:
     53a:	31 32 48 00                                         12H.

0000053e <__c.1538>:
     53e:	31 32 48 00                                         12H.

00000542 <__c.1536>:
     542:	32 34 48 00                                         24H.

00000546 <DF_pagebits>:
     546:	09 09 09 09 09 0a 0a 0b                             ........

0000054e <DF_pagesize>:
     54e:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

0000055e <LCD_character_table>:
     55e:	51 0a 80 2a 00 00 00 0a 51 0a 00 00 59 55 18 01     Q..*....Q...YU..
     56e:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
	...
     58a:	00 00 51 0f 91 39 41 14 91 31 41 1e 41 0e 41 1d     ..Q..9A..1A.A.A.
     59a:	50 0f 80 20 10 15 48 86 40 14 78 05 70 85 51 15     P.. ..H.@.x.p.Q.
     5aa:	51 0e 51 95 51 8e 21 90 81 20 50 15 48 44 50 c5     Q.Q.Q.!.. P.HDP.
     5ba:	28 c0 28 20 09 50 00 00 00 00 00 00 00 00 00 00     (.( .P..........

000005ca <TEXT_SONG1>:
     5ca:	46 75 72 20 45 6c 69 73 65 00                       Fur Elise.

000005d4 <FurElise>:
     5d4:	03 00 08 00 7b 01 08 00 92 01 08 00 7b 01 08 00     ....{.......{...
     5e4:	92 01 08 00 7b 01 08 00 fa 01 08 00 aa 01 08 00     ....{...........
     5f4:	de 01 04 00 38 02 08 00 01 00 08 00 bc 03 08 00     ....8...........
     604:	f6 02 08 00 38 02 04 00 fa 01 08 00 01 00 08 00     ....8...........
     614:	f6 02 08 00 5a 02 08 00 fa 01 04 00 de 01 08 00     ....Z...........
     624:	01 00 08 00 f6 02 08 00 7b 01 08 00 92 01 08 00     ........{.......
     634:	7b 01 08 00 92 01 08 00 7b 01 08 00 fa 01 08 00     {.......{.......
     644:	aa 01 08 00 de 01 04 00 38 02 08 00 01 00 08 00     ........8.......
     654:	bc 03 08 00 f6 02 08 00 38 02 04 00 fa 01 08 00     ........8.......
     664:	01 00 08 00 f6 02 08 00 de 01 08 00 fa 01 04 00     ................
     674:	38 02 00 00 01 00                                   8.....

0000067a <TEXT_SONG2>:
     67a:	54 75 72 6b 65 79 20 6d 61 72 63 68 00              Turkey march.

00000687 <Mozart>:
     687:	03 00 10 00 a4 02 10 00 f6 02 10 00 24 03 10 00     ............$...
     697:	f6 02 04 00 7e 02 10 00 38 02 10 00 7e 02 10 00     ....~...8...~...
     6a7:	a4 02 10 00 7e 02 04 00 fa 01 10 00 de 01 10 00     ....~...........
     6b7:	fa 01 10 00 18 02 10 00 fa 01 10 00 52 01 10 00     ............R...
     6c7:	7b 01 10 00 92 01 10 00 7b 01 10 00 52 01 10 00     {.......{...R...
     6d7:	7b 01 10 00 92 01 10 00 7b 01 04 00 3f 01 08 00     {.......{...?...
     6e7:	7b 01 08 00 3f 01 20 00 aa 01 20 00 7b 01 10 00     {...?. ... .{...
     6f7:	52 01 08 00 7b 01 08 00 aa 01 08 00 7b 01 20 00     R...{.......{. .
     707:	aa 01 20 00 7b 01 10 00 52 01 08 00 7b 01 08 00     .. .{...R...{...
     717:	aa 01 08 00 7b 01 20 00 aa 01 20 00 7b 01 10 00     ....{. ... .{...
     727:	52 01 08 00 7b 01 08 00 aa 01 08 00 c3 01 04 00     R...{...........
     737:	fa 01 00 00 01 00                                   ......

0000073d <TEXT_SONG3>:
     73d:	4d 69 6e 75 65 74 00                                Minuet.

00000744 <Minuet>:
     744:	02 00 04 00 aa 01 08 00 7e 02 08 00 38 02 08 00     ........~...8...
     754:	fa 01 08 00 de 01 04 00 aa 01 04 00 7e 02 04 00     ............~...
     764:	7e 02 04 00 7b 01 08 00 de 01 08 00 aa 01 08 00     ~...{...........
     774:	7b 01 08 00 52 01 04 00 3f 01 04 00 7e 02 04 00     {...R...?...~...
     784:	7e 02 04 00 de 01 08 00 aa 01 08 00 de 01 08 00     ~...............
     794:	fa 01 08 00 38 02 04 00 fa 01 08 00 de 01 08 00     ....8...........
     7a4:	fa 01 08 00 38 02 08 00 7e 02 04 00 a4 02 08 00     ....8...~.......
     7b4:	7e 02 08 00 38 02 08 00 fa 01 08 00 7e 02 04 00     ~...8.......~...
     7c4:	fa 01 02 00 38 02 00 00 01 00                       ....8.....

000007ce <TEXT_SONG4>:
     7ce:	41 75 6c 64 20 4c 61 6e 67 20 53 79 6e 65 00        Auld Lang Syne.

000007dd <AuldLangSyne>:
     7dd:	03 00 04 00 3f 01 02 00 ef 00 08 00 ef 00 04 00     ....?...........
     7ed:	ef 00 04 00 be 00 02 00 d5 00 08 00 ef 00 04 00     ................
     7fd:	d5 00 08 00 be 00 08 00 d5 00 02 00 ef 00 08 00     ................
     80d:	ef 00 04 00 be 00 04 00 9f 00 02 00 8e 00 08 00     ................
     81d:	01 00 04 00 8e 00 02 00 9f 00 08 00 be 00 04 00     ................
     82d:	be 00 04 00 ef 00 02 00 d5 00 08 00 ef 00 04 00     ................
     83d:	d5 00 08 00 be 00 08 00 d5 00 02 00 ef 00 08 00     ................
     84d:	1c 01 04 00 1c 01 04 00 3f 01 02 00 ef 00 04 00     ........?.......
     85d:	01 00 00 00 01 00                                   ......

00000863 <TEXT_SONG5>:
     863:	53 69 72 65 6e 65 31 00                             Sirene1.

0000086b <Sirene1>:
     86b:	00 00 20 00 90 01 20 00 8d 01 20 00 8a 01 20 00     .. ... ... ... .
     87b:	87 01 20 00 84 01 20 00 81 01 20 00 7e 01 20 00     .. ... ... .~. .
     88b:	7b 01 20 00 78 01 20 00 75 01 20 00 72 01 20 00     {. .x. .u. .r. .
     89b:	6f 01 20 00 6c 01 20 00 69 01 20 00 66 01 20 00     o. .l. .i. .f. .
     8ab:	63 01 20 00 60 01 20 00 5d 01 20 00 5a 01 20 00     c. .`. .]. .Z. .
     8bb:	57 01 20 00 54 01 20 00 51 01 20 00 4e 01 20 00     W. .T. .Q. .N. .
     8cb:	4b 01 20 00 48 01 20 00 45 01 20 00 42 01 20 00     K. .H. .E. .B. .
     8db:	3f 01 20 00 3c 01 20 00 39 01 20 00 36 01 20 00     ?. .<. .9. .6. .
     8eb:	33 01 20 00 30 01 20 00 2d 01 20 00 2a 01 20 00     3. .0. .-. .*. .
     8fb:	2a 01 20 00 2d 01 20 00 30 01 20 00 33 01 20 00     *. .-. .0. .3. .
     90b:	36 01 20 00 39 01 20 00 3c 01 20 00 3f 01 20 00     6. .9. .<. .?. .
     91b:	42 01 20 00 45 01 20 00 48 01 20 00 4b 01 20 00     B. .E. .H. .K. .
     92b:	4e 01 20 00 51 01 20 00 54 01 20 00 57 01 20 00     N. .Q. .T. .W. .
     93b:	5a 01 20 00 5d 01 20 00 60 01 20 00 63 01 20 00     Z. .]. .`. .c. .
     94b:	66 01 20 00 69 01 20 00 6c 01 20 00 6f 01 20 00     f. .i. .l. .o. .
     95b:	72 01 20 00 75 01 20 00 78 01 20 00 7b 01 20 00     r. .u. .x. .{. .
     96b:	7e 01 20 00 81 01 20 00 84 01 20 00 87 01 20 00     ~. ... ... ... .
     97b:	8a 01 20 00 8d 01 20 00 90 01 00 00 01 00           .. ... .......

00000989 <TEXT_SONG6>:
     989:	53 69 72 65 6e 65 32 00                             Sirene2.

00000991 <Sirene2>:
     991:	03 00 04 00 de 01 04 00 3f 01 00 00 01 00           ........?.....

0000099f <TEXT_SONG7>:
     99f:	57 68 69 73 74 6c 65 00                             Whistle.

000009a7 <Whistle>:
     9a7:	00 00 20 00 c8 00 20 00 c3 00 20 00 be 00 20 00     .. ... ... ... .
     9b7:	b9 00 20 00 b4 00 20 00 af 00 20 00 aa 00 20 00     .. ... ... ... .
     9c7:	a5 00 20 00 a0 00 20 00 9b 00 20 00 96 00 20 00     .. ... ... ... .
     9d7:	91 00 20 00 8c 00 20 00 87 00 20 00 82 00 20 00     .. ... ... ... .
     9e7:	7d 00 20 00 78 00 20 00 73 00 20 00 6e 00 20 00     }. .x. .s. .n. .
     9f7:	69 00 20 00 64 00 08 00 01 00 20 00 c8 00 20 00     i. .d..... ... .
     a07:	c3 00 20 00 be 00 20 00 b9 00 20 00 b4 00 20 00     .. ... ... ... .
     a17:	af 00 20 00 aa 00 20 00 a5 00 20 00 a0 00 20 00     .. ... ... ... .
     a27:	9b 00 20 00 96 00 20 00 91 00 20 00 8c 00 20 00     .. ... ... ... .
     a37:	87 00 20 00 82 00 20 00 7d 00 20 00 7d 00 20 00     .. ... .}. .}. .
     a47:	82 00 20 00 87 00 20 00 8c 00 20 00 91 00 20 00     .. ... ... ... .
     a57:	96 00 20 00 9b 00 20 00 a0 00 20 00 a5 00 20 00     .. ... ... ... .
     a67:	aa 00 20 00 af 00 20 00 b4 00 20 00 b9 00 20 00     .. ... ... ... .
     a77:	be 00 20 00 c3 00 20 00 c8 00 00 00 00 00           .. ... .......

00000a85 <TEXT_SONG8>:
     a85:	45 78 6f 72 7a 69 73 74 00                          Exorzist.

00000a8e <Exorcist>:
     a8e:	15 00 90 00 7b 01 90 00 1c 01 90 00 7b 01 90 00     ....{.......{...
     a9e:	fd 00 90 00 7b 01 90 00 3f 01 90 00 1c 01 90 00     ....{...?.......
     aae:	7b 01 90 00 ef 00 90 00 1c 01 90 00 d5 00 90 00     {...............
     abe:	7b 01 90 00 fd 00 90 00 ef 00 90 00 7b 01 90 00     {...........{...
     ace:	fd 00 90 00 7b 01 90 00 1c 01 90 00 7b 01 90 00     ....{.......{...
     ade:	fd 00 90 00 3f 01 90 00 1c 01 90 00 7b 01 90 00     ....?.......{...
     aee:	ef 00 90 00 7b 01 90 00 d5 00 90 00 7b 01 90 00     ....{.......{...
     afe:	fd 00 90 00 ef 00 90 00 7b 01 90 00 fd 00 90 00     ........{.......
     b0e:	7b 01 90 00 1c 01 90 00 7b 01 90 00 fd 00 90 00     {.......{.......
     b1e:	7b 01 90 00 3f 01 40 02 1c 01 00 00 01 00           {...?.@.......

00000b2c <Songs>:
     b2c:	d4 05 87 06 44 07 dd 07 6b 08 91 09 a7 09 8e 0a     ....D...k.......
	...

00000b3e <TEXT_SONG_TBL>:
     b3e:	ca 05 7a 06 3d 07 ce 07 63 08 89 09 9f 09 85 0a     ..z.=...c.......
	...

00000b50 <PLAYING>:
     b50:	50 4c 41 59 49 4e 47 00                             PLAYING.

00000b58 <__c.1539>:
     b58:	45 72 72 6f 72 20 44 61 74 61 46 6c 61 73 68 00     Error DataFlash.

00000b68 <__c.1531>:
     b68:	4c 69 67 68 74 00                                   Light.

00000b6e <__c.1529>:
     b6e:	45 72 72 6f 72 20 56 6f 6c 74 61 67 65 00           Error Voltage.

00000b7c <__c.1527>:
     b7c:	45 72 72 6f 72 20 54 65 6d 70 65 72 61 74 75 72     Error Temperatur
     b8c:	65 00                                               e.

00000b8e <__c.1513>:
     b8e:	4c 43 44 20 74 65 73 74 00                          LCD test.

00000b97 <__c.1508>:
     b97:	53 6f 75 6e 64 00                                   Sound.

00000b9d <__c.1503>:
     b9d:	44 6f 77 6e 00                                      Down.

00000ba2 <__c.1498>:
     ba2:	52 69 67 68 74 00                                   Right.

00000ba8 <__c.1493>:
     ba8:	55 70 00                                            Up.

00000bab <__c.1488>:
     bab:	4c 65 66 74 00                                      Left.

00000bb0 <__c.1486>:
     bb0:	54 65 73 74 00 00                                   Test..

00000bb6 <__ctors_end>:
     bb6:	11 24       	eor	r1, r1
     bb8:	1f be       	out	0x3f, r1	; 63
     bba:	cf ef       	ldi	r28, 0xFF	; 255
     bbc:	d4 e0       	ldi	r29, 0x04	; 4
     bbe:	de bf       	out	0x3e, r29	; 62
     bc0:	cd bf       	out	0x3d, r28	; 61

00000bc2 <__do_copy_data>:
     bc2:	11 e0       	ldi	r17, 0x01	; 1
     bc4:	a0 e0       	ldi	r26, 0x00	; 0
     bc6:	b1 e0       	ldi	r27, 0x01	; 1
     bc8:	ec e4       	ldi	r30, 0x4C	; 76
     bca:	fe e2       	ldi	r31, 0x2E	; 46
     bcc:	02 c0       	rjmp	.+4      	; 0xbd2 <.do_copy_data_start>

00000bce <.do_copy_data_loop>:
     bce:	05 90       	lpm	r0, Z+
     bd0:	0d 92       	st	X+, r0

00000bd2 <.do_copy_data_start>:
     bd2:	a6 34       	cpi	r26, 0x46	; 70
     bd4:	b1 07       	cpc	r27, r17
     bd6:	d9 f7       	brne	.-10     	; 0xbce <.do_copy_data_loop>

00000bd8 <__do_clear_bss>:
     bd8:	11 e0       	ldi	r17, 0x01	; 1
     bda:	a6 e4       	ldi	r26, 0x46	; 70
     bdc:	b1 e0       	ldi	r27, 0x01	; 1
     bde:	01 c0       	rjmp	.+2      	; 0xbe2 <.do_clear_bss_start>

00000be0 <.do_clear_bss_loop>:
     be0:	1d 92       	st	X+, r1

00000be2 <.do_clear_bss_start>:
     be2:	aa 3a       	cpi	r26, 0xAA	; 170
     be4:	b1 07       	cpc	r27, r17
     be6:	e1 f7       	brne	.-8      	; 0xbe0 <.do_clear_bss_loop>
     be8:	7f d1       	rcall	.+766    	; 0xee8 <main>
     bea:	0c 94 24 17 	jmp	0x2e48	; 0x2e48 <_exit>

00000bee <__bad_interrupt>:
     bee:	08 ca       	rjmp	.-3056   	; 0x0 <__vectors>

00000bf0 <StateMachine>:
*
*   Purpose :       Shifts between the different states
*
*****************************************************************************/
unsigned char StateMachine(char state, unsigned char stimuli)
{
     bf0:	58 2f       	mov	r21, r24
     bf2:	40 e0       	ldi	r20, 0x00	; 0
     bf4:	0e c0       	rjmp	.+28     	; 0xc12 <StateMachine+0x22>
    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
    {
        // mt: if (menu_nextstate[i].state == state && menu_nextstate[i].input == stimuli)
        // mt 1/06 : if (pgm_read_byte(&menu_nextstate[i].state) == state && 
        if ( j == state && 
     bf6:	85 17       	cp	r24, r21
     bf8:	59 f4       	brne	.+22     	; 0xc10 <StateMachine+0x20>
             pgm_read_byte(&menu_nextstate[i].input) == stimuli)
     bfa:	f9 01       	movw	r30, r18
     bfc:	ed 5d       	subi	r30, 0xDD	; 221
     bfe:	fe 4f       	sbci	r31, 0xFE	; 254
     c00:	e4 91       	lpm	r30, Z+
    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
    {
        // mt: if (menu_nextstate[i].state == state && menu_nextstate[i].input == stimuli)
        // mt 1/06 : if (pgm_read_byte(&menu_nextstate[i].state) == state && 
        if ( j == state && 
     c02:	e6 17       	cp	r30, r22
     c04:	29 f4       	brne	.+10     	; 0xc10 <StateMachine+0x20>
             pgm_read_byte(&menu_nextstate[i].input) == stimuli)
        {
            // This is the one!
            // mt: nextstate = menu_nextstate[i].nextstate;
            nextstate = pgm_read_byte(&menu_nextstate[i].nextstate);
     c06:	f9 01       	movw	r30, r18
     c08:	ec 5d       	subi	r30, 0xDC	; 220
     c0a:	fe 4f       	sbci	r31, 0xFE	; 254
     c0c:	84 91       	lpm	r24, Z+
     c0e:	08 95       	ret
{
    unsigned char nextstate = state;    // Default stay in same state
    unsigned char i, j;

    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
     c10:	4f 5f       	subi	r20, 0xFF	; 255
     c12:	84 2f       	mov	r24, r20
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	9c 01       	movw	r18, r24
     c18:	22 0f       	add	r18, r18
     c1a:	33 1f       	adc	r19, r19
     c1c:	28 0f       	add	r18, r24
     c1e:	39 1f       	adc	r19, r25
     c20:	f9 01       	movw	r30, r18
     c22:	ee 5d       	subi	r30, 0xDE	; 222
     c24:	fe 4f       	sbci	r31, 0xFE	; 254
     c26:	84 91       	lpm	r24, Z+
     c28:	88 23       	and	r24, r24
     c2a:	29 f7       	brne	.-54     	; 0xbf6 <StateMachine+0x6>
     c2c:	85 2f       	mov	r24, r21
            break;
        }
    }

    return nextstate;
}
     c2e:	08 95       	ret

00000c30 <Delay>:
*
*   Purpose :       Delay-loop
*
*****************************************************************************/
void Delay(unsigned int millisec)
{
     c30:	06 c0       	rjmp	.+12     	; 0xc3e <Delay+0xe>
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
     c32:	20 e0       	ldi	r18, 0x00	; 0
		for (i=0; i<125; i++) {
			asm volatile ("nop"::);
     c34:	00 00       	nop
{
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
		for (i=0; i<125; i++) {
     c36:	2f 5f       	subi	r18, 0xFF	; 255
     c38:	2d 37       	cpi	r18, 0x7D	; 125
     c3a:	e1 f7       	brne	.-8      	; 0xc34 <Delay+0x4>
     c3c:	01 97       	sbiw	r24, 0x01	; 1
void Delay(unsigned int millisec)
{
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
     c3e:	00 97       	sbiw	r24, 0x00	; 0
     c40:	c1 f7       	brne	.-16     	; 0xc32 <Delay+0x2>
		for (i=0; i<125; i++) {
			asm volatile ("nop"::);
		}
	}
}
     c42:	08 95       	ret

00000c44 <OSCCAL_calibration>:
{
    unsigned char calibrate = FALSE;
    int temp;
    unsigned char tempL;

    CLKPR = (1<<CLKPCE);        // set Clock Prescaler Change Enable
     c44:	80 e8       	ldi	r24, 0x80	; 128
     c46:	80 93 61 00 	sts	0x0061, r24
    // set prescaler = 8, Inter RC 8Mhz / 8 = 1Mhz
    CLKPR = (1<<CLKPS1) | (1<<CLKPS0);
     c4a:	83 e0       	ldi	r24, 0x03	; 3
     c4c:	80 93 61 00 	sts	0x0061, r24
    
    TIMSK2 = 0;             //disable OCIE2A and TOIE2
     c50:	10 92 70 00 	sts	0x0070, r1

    ASSR = (1<<AS2);        //select asynchronous operation of timer2 (32,768kHz)
     c54:	88 e0       	ldi	r24, 0x08	; 8
     c56:	80 93 b6 00 	sts	0x00B6, r24
    
    OCR2A = 200;            // set timer2 compare value 
     c5a:	88 ec       	ldi	r24, 0xC8	; 200
     c5c:	80 93 b3 00 	sts	0x00B3, r24

    TIMSK0 = 0;             // delete any interrupt sources
     c60:	10 92 6e 00 	sts	0x006E, r1
        
    TCCR1B = (1<<CS10);     // start timer1 with no prescaling
     c64:	81 e0       	ldi	r24, 0x01	; 1
     c66:	80 93 81 00 	sts	0x0081, r24
    TCCR2A = (1<<CS20);     // start timer2 with no prescaling
     c6a:	80 93 b0 00 	sts	0x00B0, r24

    while((ASSR & 0x01) | (ASSR & 0x04));       //wait for TCN2UB and TCR2UB to be cleared
     c6e:	20 91 b6 00 	lds	r18, 0x00B6
     c72:	80 91 b6 00 	lds	r24, 0x00B6
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	84 70       	andi	r24, 0x04	; 4
     c7a:	90 70       	andi	r25, 0x00	; 0
     c7c:	30 e0       	ldi	r19, 0x00	; 0
     c7e:	21 70       	andi	r18, 0x01	; 1
     c80:	30 70       	andi	r19, 0x00	; 0
     c82:	82 2b       	or	r24, r18
     c84:	93 2b       	or	r25, r19
     c86:	89 2b       	or	r24, r25
     c88:	91 f7       	brne	.-28     	; 0xc6e <OSCCAL_calibration+0x2a>

    Delay(1000);    // wait for external crystal to stabilise
     c8a:	88 ee       	ldi	r24, 0xE8	; 232
     c8c:	93 e0       	ldi	r25, 0x03	; 3
     c8e:	d0 df       	rcall	.-96     	; 0xc30 <Delay>
    
    while(!calibrate)
    {
        cli(); // mt __disable_interrupt();  // disable global interrupt
        
        TIFR1 = 0xFF;   // delete TIFR1 flags
     c90:	3f ef       	ldi	r19, 0xFF	; 255
    
        if (temp > 6250)
        {
            OSCCAL--;   // the internRC oscillator runs to fast, decrease the OSCCAL
        }
        else if (temp < 6120)
     c92:	41 e0       	ldi	r20, 0x01	; 1

    Delay(1000);    // wait for external crystal to stabilise
    
    while(!calibrate)
    {
        cli(); // mt __disable_interrupt();  // disable global interrupt
     c94:	f8 94       	cli
        
        TIFR1 = 0xFF;   // delete TIFR1 flags
     c96:	36 bb       	out	0x16, r19	; 22
        TIFR2 = 0xFF;   // delete TIFR2 flags
     c98:	37 bb       	out	0x17, r19	; 23
        
        TCNT1H = 0;     // clear timer1 counter
     c9a:	10 92 85 00 	sts	0x0085, r1
        TCNT1L = 0;
     c9e:	10 92 84 00 	sts	0x0084, r1
        TCNT2 = 0;      // clear timer2 counter
     ca2:	10 92 b2 00 	sts	0x00B2, r1
           
        // shc/mt while ( !(TIFR2 && (1<<OCF2A)) );   // wait for timer2 compareflag    
        while ( !(TIFR2 & (1<<OCF2A)) );   // wait for timer2 compareflag
     ca6:	b9 9b       	sbis	0x17, 1	; 23
     ca8:	fe cf       	rjmp	.-4      	; 0xca6 <OSCCAL_calibration+0x62>

        TCCR1B = 0; // stop timer1
     caa:	10 92 81 00 	sts	0x0081, r1

        sei(); // __enable_interrupt();  // enable global interrupt
     cae:	78 94       	sei
    
        // shc/mt if ( (TIFR1 && (1<<TOV1)) )
        if ( (TIFR1 & (1<<TOV1)) )
     cb0:	b0 99       	sbic	0x16, 0	; 22
     cb2:	16 c0       	rjmp	.+44     	; 0xce0 <OSCCAL_calibration+0x9c>
        {
            temp = 0xFFFF;      // if timer1 overflows, set the temp to 0xFFFF
        }
        else
        {   // read out the timer1 counter value
            tempL = TCNT1L;
     cb4:	20 91 84 00 	lds	r18, 0x0084
            temp = TCNT1H;
     cb8:	80 91 85 00 	lds	r24, 0x0085
     cbc:	90 e0       	ldi	r25, 0x00	; 0
            temp = (temp << 8);
     cbe:	98 2f       	mov	r25, r24
     cc0:	88 27       	eor	r24, r24
            temp += tempL;
     cc2:	82 0f       	add	r24, r18
     cc4:	91 1d       	adc	r25, r1
        }
    
        if (temp > 6250)
     cc6:	28 e1       	ldi	r18, 0x18	; 24
     cc8:	8b 36       	cpi	r24, 0x6B	; 107
     cca:	92 07       	cpc	r25, r18
     ccc:	24 f0       	brlt	.+8      	; 0xcd6 <OSCCAL_calibration+0x92>
        {
            OSCCAL--;   // the internRC oscillator runs to fast, decrease the OSCCAL
     cce:	80 91 66 00 	lds	r24, 0x0066
     cd2:	81 50       	subi	r24, 0x01	; 1
     cd4:	08 c0       	rjmp	.+16     	; 0xce6 <OSCCAL_calibration+0xa2>
        }
        else if (temp < 6120)
     cd6:	88 5e       	subi	r24, 0xE8	; 232
     cd8:	97 41       	sbci	r25, 0x17	; 23
     cda:	14 f0       	brlt	.+4      	; 0xce0 <OSCCAL_calibration+0x9c>
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	06 c0       	rjmp	.+12     	; 0xcec <OSCCAL_calibration+0xa8>
        {
            OSCCAL++;   // the internRC oscillator runs to slow, increase the OSCCAL
     ce0:	80 91 66 00 	lds	r24, 0x0066
     ce4:	8f 5f       	subi	r24, 0xFF	; 255
     ce6:	80 93 66 00 	sts	0x0066, r24
     cea:	80 e0       	ldi	r24, 0x00	; 0
        }
        else
            calibrate = TRUE;   // the interRC is correct

        TCCR1B = (1<<CS10); // start timer1
     cec:	40 93 81 00 	sts	0x0081, r20

    while((ASSR & 0x01) | (ASSR & 0x04));       //wait for TCN2UB and TCR2UB to be cleared

    Delay(1000);    // wait for external crystal to stabilise
    
    while(!calibrate)
     cf0:	88 23       	and	r24, r24
     cf2:	81 f2       	breq	.-96     	; 0xc94 <OSCCAL_calibration+0x50>
        else
            calibrate = TRUE;   // the interRC is correct

        TCCR1B = (1<<CS10); // start timer1
    }
}
     cf4:	08 95       	ret

00000cf6 <PowerSaveFunc>:
*****************************************************************************/
// mt __flash char TEXT_POWER[]                     = "Press enter to sleep";
// mt jw const char TEXT_POWER[]  PROGMEM  = "Press enter to sleep";

char PowerSaveFunc(char input)
{
     cf6:	98 2f       	mov	r25, r24
    static char enter = 1;    
    
    if(enter)
     cf8:	80 91 04 01 	lds	r24, 0x0104
     cfc:	88 23       	and	r24, r24
     cfe:	41 f0       	breq	.+16     	; 0xd10 <PowerSaveFunc+0x1a>
    {
        enter = 0;
     d00:	10 92 04 01 	sts	0x0104, r1
        //mt jw LCD_puts_f(TEXT_POWER, 1);
        LCD_puts_f(PSTR("Press enter to sleep"), 1);
     d04:	89 ea       	ldi	r24, 0xA9	; 169
     d06:	92 e0       	ldi	r25, 0x02	; 2
     d08:	61 e0       	ldi	r22, 0x01	; 1
     d0a:	0e 94 d7 10 	call	0x21ae	; 0x21ae <LCD_puts_f>
     d0e:	0a c0       	rjmp	.+20     	; 0xd24 <PowerSaveFunc+0x2e>
    }
    else if(input == KEY_ENTER)
     d10:	91 30       	cpi	r25, 0x01	; 1
     d12:	31 f4       	brne	.+12     	; 0xd20 <PowerSaveFunc+0x2a>
    {
        PowerSave = TRUE;
     d14:	90 93 47 01 	sts	0x0147, r25
        enter = 1;
     d18:	90 93 04 01 	sts	0x0104, r25
     d1c:	8a e0       	ldi	r24, 0x0A	; 10
     d1e:	08 95       	ret
        return ST_AVRBF;
    }
    else if (input == KEY_PREV)
     d20:	93 30       	cpi	r25, 0x03	; 3
     d22:	11 f0       	breq	.+4      	; 0xd28 <PowerSaveFunc+0x32>
     d24:	81 e6       	ldi	r24, 0x61	; 97
     d26:	08 95       	ret
    {
        enter = 1;
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	80 93 04 01 	sts	0x0104, r24
     d2e:	80 e6       	ldi	r24, 0x60	; 96
        return ST_OPTIONS_POWER_SAVE;
    }
        
    return ST_OPTIONS_POWER_SAVE_FUNC;

}
     d30:	08 95       	ret

00000d32 <BootFunc>:
*****************************************************************************/
// mt __flash char TEXT_BOOT[]                     
// mt - as in jw-patch: const char TEXT_BOOT[] PROGMEM	= "Jump to bootloader";

char BootFunc(char input)
{
     d32:	98 2f       	mov	r25, r24
    static char enter = 1;
    
    if(enter)
     d34:	80 91 05 01 	lds	r24, 0x0105
     d38:	88 23       	and	r24, r24
     d3a:	41 f0       	breq	.+16     	; 0xd4c <BootFunc+0x1a>
    {
        enter = 0;
     d3c:	10 92 05 01 	sts	0x0105, r1
        // mt jw LCD_puts_f(TEXT_BOOT, 1);
        LCD_puts_f(PSTR("Jump to bootloader"), 1);
     d40:	8e eb       	ldi	r24, 0xBE	; 190
     d42:	92 e0       	ldi	r25, 0x02	; 2
     d44:	61 e0       	ldi	r22, 0x01	; 1
     d46:	0e 94 d7 10 	call	0x21ae	; 0x21ae <LCD_puts_f>
     d4a:	08 c0       	rjmp	.+16     	; 0xd5c <BootFunc+0x2a>
    }
    else if(input == KEY_ENTER)
     d4c:	91 30       	cpi	r25, 0x01	; 1
     d4e:	21 f4       	brne	.+8      	; 0xd58 <BootFunc+0x26>
    {
        WDTCR = (1<<WDCE) | (1<<WDE);     //Enable Watchdog Timer to give reset
     d50:	88 e1       	ldi	r24, 0x18	; 24
     d52:	80 93 60 00 	sts	0x0060, r24
     d56:	ff cf       	rjmp	.-2      	; 0xd56 <BootFunc+0x24>
        while(1);   // wait for watchdog-reset, since the BOOTRST-fuse is 
                    // programmed, the Boot-section will be entered upon reset.
    }
    else if (input == KEY_PREV)
     d58:	93 30       	cpi	r25, 0x03	; 3
     d5a:	11 f0       	breq	.+4      	; 0xd60 <BootFunc+0x2e>
     d5c:	8f e5       	ldi	r24, 0x5F	; 95
     d5e:	08 95       	ret
    {
        enter = 1;
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	80 93 05 01 	sts	0x0105, r24
     d66:	8e e5       	ldi	r24, 0x5E	; 94
        return ST_OPTIONS_BOOT;
    }
    
    return ST_OPTIONS_BOOT_FUNC;
}
     d68:	08 95       	ret

00000d6a <KeyClick>:
*
*   Purpose :       Enable/Disable keyclick
*
*****************************************************************************/
char KeyClick(char input)
{
     d6a:	98 2f       	mov	r25, r24
	static uint8_t enter = 1;
	uint8_t show;

	if ( enter ) {
     d6c:	80 91 02 01 	lds	r24, 0x0102
     d70:	88 23       	and	r24, r24
     d72:	19 f0       	breq	.+6      	; 0xd7a <KeyClick+0x10>
		enter = 0;
     d74:	10 92 02 01 	sts	0x0102, r1
     d78:	81 e0       	ldi	r24, 0x01	; 1
	}
	else {
		show = 0;
	}
		
	if (input == KEY_ENTER)
     d7a:	91 30       	cpi	r25, 0x01	; 1
     d7c:	21 f4       	brne	.+8      	; 0xd86 <KeyClick+0x1c>
	{
		enter = 1;
     d7e:	90 93 02 01 	sts	0x0102, r25
     d82:	84 e6       	ldi	r24, 0x64	; 100
     d84:	08 95       	ret
		return ST_OPTIONS_KEYCLICK;
	}

	if ( (input == KEY_PLUS) || (input == KEY_MINUS) ) {
     d86:	94 50       	subi	r25, 0x04	; 4
     d88:	92 30       	cpi	r25, 0x02	; 2
     d8a:	30 f4       	brcc	.+12     	; 0xd98 <KeyClick+0x2e>
		gKeyClickStatus = ~gKeyClickStatus;
     d8c:	80 91 46 01 	lds	r24, 0x0146
     d90:	80 95       	com	r24
     d92:	80 93 46 01 	sts	0x0146, r24
     d96:	04 c0       	rjmp	.+8      	; 0xda0 <KeyClick+0x36>
		show = 1;
	}

	if ( show ) {
     d98:	88 23       	and	r24, r24
     d9a:	11 f4       	brne	.+4      	; 0xda0 <KeyClick+0x36>
     d9c:	85 e6       	ldi	r24, 0x65	; 101
     d9e:	08 95       	ret
		if ( gKeyClickStatus )
     da0:	80 91 46 01 	lds	r24, 0x0146
     da4:	88 23       	and	r24, r24
     da6:	19 f0       	breq	.+6      	; 0xdae <KeyClick+0x44>
			LCD_puts_f(PSTR("On"),1);
     da8:	8e e9       	ldi	r24, 0x9E	; 158
     daa:	92 e0       	ldi	r25, 0x02	; 2
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <KeyClick+0x48>
		else
			LCD_puts_f(PSTR("Off"),1);
     dae:	8a e9       	ldi	r24, 0x9A	; 154
     db0:	92 e0       	ldi	r25, 0x02	; 2
     db2:	61 e0       	ldi	r22, 0x01	; 1
     db4:	0e 94 d7 10 	call	0x21ae	; 0x21ae <LCD_puts_f>
		LCD_UpdateRequired(TRUE, 0);
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	60 e0       	ldi	r22, 0x00	; 0
     dbc:	0e 94 20 11 	call	0x2240	; 0x2240 <LCD_UpdateRequired>
     dc0:	85 e6       	ldi	r24, 0x65	; 101
	}

	return ST_OPTIONS_KEYCLICK_FUNC;
}
     dc2:	08 95       	ret

00000dc4 <AutoPowerShowMin>:
*   Purpose :       Enable/Disable auto power save
*
*****************************************************************************/

static void AutoPowerShowMin(void)
{
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
	char PH,PL; 
	
	PH = CHAR2BCD2(PowerSaveTimeout);
     dc8:	80 91 00 01 	lds	r24, 0x0100
     dcc:	05 d2       	rcall	.+1034   	; 0x11d8 <CHAR2BCD2>
     dce:	18 2f       	mov	r17, r24
	PL = (PH & 0x0F) + '0';
	PH = (PH >> 4) + '0';
     dd0:	08 2f       	mov	r16, r24
     dd2:	02 95       	swap	r16
     dd4:	0f 70       	andi	r16, 0x0F	; 15
	
	LCD_putc(0, 'M');
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	6d e4       	ldi	r22, 0x4D	; 77
     dda:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(1, 'I');
     dde:	81 e0       	ldi	r24, 0x01	; 1
     de0:	69 e4       	ldi	r22, 0x49	; 73
     de2:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(2, 'N');
     de6:	82 e0       	ldi	r24, 0x02	; 2
     de8:	6e e4       	ldi	r22, 0x4E	; 78
     dea:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(3, ' ');
     dee:	83 e0       	ldi	r24, 0x03	; 3
     df0:	60 e2       	ldi	r22, 0x20	; 32
     df2:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(4, PH);
     df6:	00 5d       	subi	r16, 0xD0	; 208
     df8:	84 e0       	ldi	r24, 0x04	; 4
     dfa:	60 2f       	mov	r22, r16
     dfc:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(5, PL);
     e00:	1f 70       	andi	r17, 0x0F	; 15
     e02:	10 5d       	subi	r17, 0xD0	; 208
     e04:	85 e0       	ldi	r24, 0x05	; 5
     e06:	61 2f       	mov	r22, r17
     e08:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	LCD_putc(6, '\0');
     e0c:	86 e0       	ldi	r24, 0x06	; 6
     e0e:	60 e0       	ldi	r22, 0x00	; 0
     e10:	0e 94 07 11 	call	0x220e	; 0x220e <LCD_putc>
	
	LCD_UpdateRequired(TRUE, 0);
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	60 e0       	ldi	r22, 0x00	; 0
     e18:	0e 94 20 11 	call	0x2240	; 0x2240 <LCD_UpdateRequired>
}
     e1c:	1f 91       	pop	r17
     e1e:	0f 91       	pop	r16
     e20:	08 95       	ret

00000e22 <AutoPower>:

char AutoPower(char input)
{
     e22:	98 2f       	mov	r25, r24
    static char enter = 1;    
    
    if(enter)
     e24:	80 91 03 01 	lds	r24, 0x0103
     e28:	88 23       	and	r24, r24
     e2a:	49 f0       	breq	.+18     	; 0xe3e <AutoPower+0x1c>
    {
        enter = 0;
     e2c:	10 92 03 01 	sts	0x0103, r1
        
        if(AutoPowerSave)  
     e30:	80 91 01 01 	lds	r24, 0x0101
     e34:	88 23       	and	r24, r24
     e36:	c9 f4       	brne	.+50     	; 0xe6a <AutoPower+0x48>
            AutoPowerShowMin();
        else
            LCD_puts_f(PSTR("Off"),1);	// mt LCD_puts("Off", 1);        
     e38:	85 ea       	ldi	r24, 0xA5	; 165
     e3a:	92 e0       	ldi	r25, 0x02	; 2
     e3c:	2b c0       	rjmp	.+86     	; 0xe94 <AutoPower+0x72>
    }
    else if(input == KEY_ENTER)
     e3e:	91 30       	cpi	r25, 0x01	; 1
     e40:	21 f4       	brne	.+8      	; 0xe4a <AutoPower+0x28>
    {
         enter = 1;
     e42:	90 93 03 01 	sts	0x0103, r25
     e46:	82 e6       	ldi	r24, 0x62	; 98
     e48:	08 95       	ret

         return ST_OPTIONS_AUTO_POWER_SAVE;
    }
    else if (input == KEY_PLUS)
     e4a:	94 30       	cpi	r25, 0x04	; 4
     e4c:	81 f4       	brne	.+32     	; 0xe6e <AutoPower+0x4c>
    {

        PowerSaveTimeout += 5;
     e4e:	80 91 00 01 	lds	r24, 0x0100
     e52:	8b 5f       	subi	r24, 0xFB	; 251
     e54:	80 93 00 01 	sts	0x0100, r24
         
        if(PowerSaveTimeout > 90)
     e58:	8b 35       	cpi	r24, 0x5B	; 91
     e5a:	20 f0       	brcs	.+8      	; 0xe64 <AutoPower+0x42>
        {
            PowerSaveTimeout = 90;
     e5c:	8a e5       	ldi	r24, 0x5A	; 90
     e5e:	80 93 00 01 	sts	0x0100, r24
     e62:	1b c0       	rjmp	.+54     	; 0xe9a <AutoPower+0x78>
        }
        else
        {    
            AutoPowerSave = TRUE;
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	80 93 01 01 	sts	0x0101, r24
            AutoPowerShowMin();
     e6a:	ac df       	rcall	.-168    	; 0xdc4 <AutoPowerShowMin>
     e6c:	16 c0       	rjmp	.+44     	; 0xe9a <AutoPower+0x78>
        }
    }
    else if (input == KEY_MINUS)
     e6e:	95 30       	cpi	r25, 0x05	; 5
     e70:	a1 f4       	brne	.+40     	; 0xe9a <AutoPower+0x78>
    {
        if(PowerSaveTimeout)
     e72:	80 91 00 01 	lds	r24, 0x0100
     e76:	88 23       	and	r24, r24
     e78:	19 f0       	breq	.+6      	; 0xe80 <AutoPower+0x5e>
            PowerSaveTimeout -= 5;
     e7a:	85 50       	subi	r24, 0x05	; 5
     e7c:	80 93 00 01 	sts	0x0100, r24

        if(PowerSaveTimeout < 5)
     e80:	80 91 00 01 	lds	r24, 0x0100
     e84:	85 30       	cpi	r24, 0x05	; 5
     e86:	58 f4       	brcc	.+22     	; 0xe9e <AutoPower+0x7c>
        {
            AutoPowerSave = FALSE;
     e88:	10 92 01 01 	sts	0x0101, r1
            PowerSaveTimeout = 0;
     e8c:	10 92 00 01 	sts	0x0100, r1
            LCD_puts_f(PSTR("Off"),1);	// mt LCD_puts("Off", 1);
     e90:	81 ea       	ldi	r24, 0xA1	; 161
     e92:	92 e0       	ldi	r25, 0x02	; 2
     e94:	61 e0       	ldi	r22, 0x01	; 1
     e96:	0e 94 d7 10 	call	0x21ae	; 0x21ae <LCD_puts_f>
     e9a:	83 e6       	ldi	r24, 0x63	; 99
     e9c:	08 95       	ret
        }
        else
        {   
            AutoPowerSave = TRUE;
     e9e:	81 e0       	ldi	r24, 0x01	; 1
     ea0:	80 93 01 01 	sts	0x0101, r24
            AutoPowerShowMin();
     ea4:	8f df       	rcall	.-226    	; 0xdc4 <AutoPowerShowMin>
     ea6:	83 e6       	ldi	r24, 0x63	; 99
        }
    }
        
    return ST_OPTIONS_AUTO_POWER_SAVE_FUNC;    
}
     ea8:	08 95       	ret

00000eaa <Initialization>:
*****************************************************************************/
void Initialization(void)
{
    char tst;           // dummy

    OSCCAL_calibration();       // calibrate the OSCCAL byte
     eaa:	cc de       	rcall	.-616    	; 0xc44 <OSCCAL_calibration>
        
    CLKPR = (1<<CLKPCE);        // set Clock Prescaler Change Enable
     eac:	e1 e6       	ldi	r30, 0x61	; 97
     eae:	f0 e0       	ldi	r31, 0x00	; 0
     eb0:	90 e8       	ldi	r25, 0x80	; 128
     eb2:	90 83       	st	Z, r25

    // set prescaler = 8, Inter RC 8Mhz / 8 = 1Mhz
    CLKPR = (1<<CLKPS1) | (1<<CLKPS0);
     eb4:	83 e0       	ldi	r24, 0x03	; 3
     eb6:	80 83       	st	Z, r24

    // Disable Analog Comparator (power save)
    ACSR = (1<<ACD);
     eb8:	90 bf       	out	0x30, r25	; 48

    // Disable Digital input on PF0-2 (power save)
    DIDR0 = (7<<ADC0D);
     eba:	87 e0       	ldi	r24, 0x07	; 7
     ebc:	80 93 7e 00 	sts	0x007E, r24

    // mt PORTB = (15<<PORTB0);       // Enable pullup on 
    PORTB = (15<<PB0);       // Enable pullup on 
     ec0:	8f e0       	ldi	r24, 0x0F	; 15
     ec2:	85 b9       	out	0x05, r24	; 5
    // mt PORTE = (15<<PORTE4);
    PORTE = (15<<PE4);
     ec4:	80 ef       	ldi	r24, 0xF0	; 240
     ec6:	8e b9       	out	0x0e, r24	; 14

    sbiBF(DDRB, 5);               // set OC1A as output
     ec8:	25 9a       	sbi	0x04, 5	; 4
    sbiBF(PORTB, 5);              // set OC1A high
     eca:	2d 9a       	sbi	0x05, 5	; 5
            
    Button_Init();              // Initialize pin change interrupt on joystick
     ecc:	0e 94 c0 10 	call	0x2180	; 0x2180 <Button_Init>
    
    RTC_init();                 // Start timer2 asynchronous, used for RTC clock
     ed0:	eb d7       	rcall	.+4054   	; 0x1ea8 <RTC_init>

    Timer0_Init();              // Used when playing music etc.
     ed2:	c6 d0       	rcall	.+396    	; 0x1060 <Timer0_Init>

    USART_Init(12);             // Baud rate = 9600bps
     ed4:	8c e0       	ldi	r24, 0x0C	; 12
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	a6 d1       	rcall	.+844    	; 0x1226 <USART_Init>
    
    DF_SPI_init();              // init the SPI interface to communicate with the DataFlash
     eda:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <DF_SPI_init>
    
    tst = Read_DF_status();
     ede:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Read_DF_status>

    DF_CS_inactive;             // disable DataFlash
     ee2:	28 9a       	sbi	0x05, 0	; 5
        
    LCD_Init();                 // initialize the LCD
     ee4:	0c 94 da 11 	jmp	0x23b4	; 0x23b4 <LCD_Init>

00000ee8 <main>:
    char last_buttons;

    last_buttons='\0';  // mt

    // Initial state variables
    state = ST_TIME;
     ee8:	84 e1       	ldi	r24, 0x14	; 20
     eea:	80 93 64 01 	sts	0x0164, r24
    statetext = MT_TIME;
    pStateFunc = NULL;


    // Program initalization
    Initialization();
     eee:	dd df       	rcall	.-70     	; 0xeaa <Initialization>
    sei(); // mt __enable_interrupt();
     ef0:	78 94       	sei
     ef2:	14 e1       	ldi	r17, 0x14	; 20
     ef4:	d1 2e       	mov	r13, r17
     ef6:	cd e5       	ldi	r28, 0x5D	; 93
     ef8:	d0 e0       	ldi	r29, 0x00	; 0
     efa:	ee 24       	eor	r14, r14
     efc:	ff 24       	eor	r15, r15
     efe:	00 e0       	ldi	r16, 0x00	; 0
        //enable ATmega169 power save modus if autopowersave
        if(AutoPowerSave)
        {
            if(gPowerSaveTimer >= PowerSaveTimeout)
            {
                state = ST_AVRBF;
     f00:	ba e0       	ldi	r27, 0x0A	; 10
     f02:	bb 2e       	mov	r11, r27
            {
                PinChangeInterrupt();
                gAutoPressJoystick = AUTO;
            }
            else    
                gAutoPressJoystick = AUTO;
     f04:	a3 e0       	ldi	r26, 0x03	; 3
     f06:	ca 2e       	mov	r12, r26
     f08:	01 c0       	rjmp	.+2      	; 0xf0c <main+0x24>
    pStateFunc = NULL;


    // Program initalization
    Initialization();
    sei(); // mt __enable_interrupt();
     f0a:	01 2f       	mov	r16, r17

    for (;;)            // Main loop
    {
        if(!PowerSave)          // Do not enter main loop in power-save
     f0c:	80 91 47 01 	lds	r24, 0x0147
     f10:	88 23       	and	r24, r24
     f12:	09 f0       	breq	.+2      	; 0xf16 <main+0x2e>
     f14:	3f c0       	rjmp	.+126    	; 0xf94 <main+0xac>
        {
            // Plain menu text
            if (statetext)
     f16:	20 97       	sbiw	r28, 0x00	; 0
     f18:	39 f0       	breq	.+14     	; 0xf28 <main+0x40>
            {
                LCD_puts_f(statetext, 1);
     f1a:	ce 01       	movw	r24, r28
     f1c:	61 e0       	ldi	r22, 0x01	; 1
     f1e:	0e 94 d7 10 	call	0x21ae	; 0x21ae <LCD_puts_f>
                LCD_Colon(0);
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	0e 94 1d 11 	call	0x223a	; 0x223a <LCD_Colon>
                statetext = NULL;
            }
 
            input = getkey();           // Read buttons
     f28:	0e 94 3c 10 	call	0x2078	; 0x2078 <getkey>
     f2c:	68 2f       	mov	r22, r24
    
            if (pStateFunc)
     f2e:	e1 14       	cp	r14, r1
     f30:	f1 04       	cpc	r15, r1
     f32:	19 f0       	breq	.+6      	; 0xf3a <main+0x52>
            {
                // When in this state, we must call the state function
                nextstate = pStateFunc(input);
     f34:	f7 01       	movw	r30, r14
     f36:	09 95       	icall
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <main+0x5c>
            }
            else if (input != KEY_NULL)
     f3a:	88 23       	and	r24, r24
     f3c:	21 f0       	breq	.+8      	; 0xf46 <main+0x5e>
            {
                // Plain menu, clock the state machine
                nextstate = StateMachine(state, input);
     f3e:	80 91 64 01 	lds	r24, 0x0164
     f42:	56 de       	rcall	.-852    	; 0xbf0 <StateMachine>
     f44:	d8 2e       	mov	r13, r24
            }
    
            if (nextstate != state)
     f46:	80 91 64 01 	lds	r24, 0x0164
     f4a:	d8 16       	cp	r13, r24
     f4c:	09 f1       	breq	.+66     	; 0xf90 <main+0xa8>
            {
                state = nextstate;
     f4e:	d0 92 64 01 	sts	0x0164, r13
     f52:	40 e0       	ldi	r20, 0x00	; 0
     f54:	0e c0       	rjmp	.+28     	; 0xf72 <main+0x8a>
                // mt: for (i=0; menu_state[i].state; i++)
                for (i=0; (j=pgm_read_byte(&menu_state[i].state)); i++)
                {
                    //mt: if (menu_state[i].state == state)
                    //mt 1/06 if (pgm_read_byte(&menu_state[i].state) == state)
                    if (j == state)
     f56:	8d 15       	cp	r24, r13
     f58:	59 f4       	brne	.+22     	; 0xf70 <main+0x88>
                    {
                        // mtA
                        // mt - original: statetext =  menu_state[i].pText;
                        // mt - original: pStateFunc = menu_state[i].pFunc;
                        /// mt this is like the example from an avr-gcc guru (mailing-list):
                        statetext =  (PGM_P) pgm_read_word(&menu_state[i].pText);
     f5a:	f9 01       	movw	r30, r18
     f5c:	e4 51       	subi	r30, 0x14	; 20
     f5e:	fe 4f       	sbci	r31, 0xFE	; 254
     f60:	c5 91       	lpm	r28, Z+
     f62:	d4 91       	lpm	r29, Z+
                        // mt - store pointer to function from menu_state[i].pFunc in pStateFunc
                        //// pStateFunc = pmttemp;	// oh je - wie soll ich das jemals debuggen - ?
                        pStateFunc = (PGM_VOID_P) pgm_read_word(&menu_state[i].pFunc);
     f64:	f9 01       	movw	r30, r18
     f66:	e2 51       	subi	r30, 0x12	; 18
     f68:	fe 4f       	sbci	r31, 0xFE	; 254
     f6a:	e5 90       	lpm	r14, Z+
     f6c:	f4 90       	lpm	r15, Z+
     f6e:	12 c0       	rjmp	.+36     	; 0xf94 <main+0xac>
    
            if (nextstate != state)
            {
                state = nextstate;
                // mt: for (i=0; menu_state[i].state; i++)
                for (i=0; (j=pgm_read_byte(&menu_state[i].state)); i++)
     f70:	4f 5f       	subi	r20, 0xFF	; 255
     f72:	84 2f       	mov	r24, r20
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	9c 01       	movw	r18, r24
     f78:	22 0f       	add	r18, r18
     f7a:	33 1f       	adc	r19, r19
     f7c:	22 0f       	add	r18, r18
     f7e:	33 1f       	adc	r19, r19
     f80:	28 0f       	add	r18, r24
     f82:	39 1f       	adc	r19, r25
     f84:	f9 01       	movw	r30, r18
     f86:	e5 51       	subi	r30, 0x15	; 21
     f88:	fe 4f       	sbci	r31, 0xFE	; 254
     f8a:	84 91       	lpm	r24, Z+
     f8c:	88 23       	and	r24, r24
     f8e:	19 f7       	brne	.-58     	; 0xf56 <main+0x6e>
     f90:	c0 e0       	ldi	r28, 0x00	; 0
     f92:	d0 e0       	ldi	r29, 0x00	; 0
            }
        }
        
        
        //enable ATmega169 power save modus if autopowersave
        if(AutoPowerSave)
     f94:	80 91 01 01 	lds	r24, 0x0101
     f98:	88 23       	and	r24, r24
     f9a:	69 f0       	breq	.+26     	; 0xfb6 <main+0xce>
        {
            if(gPowerSaveTimer >= PowerSaveTimeout)
     f9c:	90 91 48 01 	lds	r25, 0x0148
     fa0:	80 91 00 01 	lds	r24, 0x0100
     fa4:	98 17       	cp	r25, r24
     fa6:	38 f0       	brcs	.+14     	; 0xfb6 <main+0xce>
            {
                state = ST_AVRBF;
     fa8:	b0 92 64 01 	sts	0x0164, r11
                gPowerSaveTimer = 0;
     fac:	10 92 48 01 	sts	0x0148, r1
                PowerSave = TRUE;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	80 93 47 01 	sts	0x0147, r24
        
        // If the joystick is held in the UP and DOWN position at the same time,
        // activate test-mode
        // mtA
        // if( !(PINB & (1<<PORTB7)) && !(PINB & (1<<PORTB6)) )    
        if( !(PINB & (1<<PINB7)) && !(PINB & (1<<PINB6)) ) {
     fb6:	1f 99       	sbic	0x03, 7	; 3
     fb8:	04 c0       	rjmp	.+8      	; 0xfc2 <main+0xda>
     fba:	1e 99       	sbic	0x03, 6	; 3
     fbc:	02 c0       	rjmp	.+4      	; 0xfc2 <main+0xda>
            Test();
     fbe:	0e 94 b9 14 	call	0x2972	; 0x2972 <Test>
        }
        // mtE
        
        // Check if the joystick has been in the same position for some time, 
        // then activate auto press of the joystick
        buttons = (~PINB) & PINB_MASK;
     fc2:	83 b1       	in	r24, 0x03	; 3
        buttons |= (~PINE) & PINE_MASK;
     fc4:	1c b1       	in	r17, 0x0c	; 12
     fc6:	10 95       	com	r17
     fc8:	1c 70       	andi	r17, 0x0C	; 12
     fca:	80 95       	com	r24
     fcc:	80 7d       	andi	r24, 0xD0	; 208
     fce:	18 2b       	or	r17, r24
        
        if( buttons != last_buttons ) 
     fd0:	10 17       	cp	r17, r16
     fd2:	19 f0       	breq	.+6      	; 0xfda <main+0xf2>
        {
            last_buttons = buttons;
            gAutoPressJoystick = FALSE;
     fd4:	10 92 58 01 	sts	0x0158, r1
     fd8:	0a c0       	rjmp	.+20     	; 0xfee <main+0x106>
        }
        else if( buttons )
     fda:	00 23       	and	r16, r16
     fdc:	41 f0       	breq	.+16     	; 0xfee <main+0x106>
        {
            if( gAutoPressJoystick == TRUE)
     fde:	80 91 58 01 	lds	r24, 0x0158
     fe2:	81 30       	cpi	r24, 0x01	; 1
     fe4:	11 f4       	brne	.+4      	; 0xfea <main+0x102>
            {
                PinChangeInterrupt();
     fe6:	0e 94 47 10 	call	0x208e	; 0x208e <PinChangeInterrupt>
                gAutoPressJoystick = AUTO;
            }
            else    
                gAutoPressJoystick = AUTO;
     fea:	c0 92 58 01 	sts	0x0158, r12
        }

        
        
        // go to SLEEP
        if(!gPlaying )              // Do not enter Power save if using UART or playing tunes
     fee:	80 91 5f 01 	lds	r24, 0x015F
     ff2:	88 23       	and	r24, r24
     ff4:	51 f5       	brne	.+84     	; 0x104a <main+0x162>
        {
            if(PowerSave)
     ff6:	90 91 47 01 	lds	r25, 0x0147
     ffa:	99 23       	and	r25, r25
     ffc:	29 f0       	breq	.+10     	; 0x1008 <main+0x120>
                cbiBF(LCDCRA, 7);             // disable LCD
     ffe:	80 91 e4 00 	lds	r24, 0x00E4
    1002:	8f 77       	andi	r24, 0x7F	; 127
    1004:	80 93 e4 00 	sts	0x00E4, r24

            set_sleep_mode(SLEEP_MODE_PWR_SAVE);
    1008:	83 b7       	in	r24, 0x33	; 51
    100a:	81 7f       	andi	r24, 0xF1	; 241
    100c:	86 60       	ori	r24, 0x06	; 6
    100e:	83 bf       	out	0x33, r24	; 51
            sleep_mode();
    1010:	83 b7       	in	r24, 0x33	; 51
    1012:	81 60       	ori	r24, 0x01	; 1
    1014:	83 bf       	out	0x33, r24	; 51
    1016:	88 95       	sleep
    1018:	83 b7       	in	r24, 0x33	; 51
    101a:	8e 7f       	andi	r24, 0xFE	; 254
    101c:	83 bf       	out	0x33, r24	; 51

            if(PowerSave)
    101e:	99 23       	and	r25, r25
    1020:	09 f4       	brne	.+2      	; 0x1024 <main+0x13c>
    1022:	73 cf       	rjmp	.-282    	; 0xf0a <main+0x22>
            {
                if(!(PINB & 0x40))              // press UP to wake from SLEEP
    1024:	1e 99       	sbic	0x03, 6	; 3
    1026:	71 cf       	rjmp	.-286    	; 0xf0a <main+0x22>
                {
                    PowerSave = FALSE;
    1028:	10 92 47 01 	sts	0x0147, r1
    102c:	ec ee       	ldi	r30, 0xEC	; 236
    102e:	f0 e0       	ldi	r31, 0x00	; 0
                    
                    for(i = 0; i < 20; i++ ) // set all LCD segment register to the variable ucSegments
                    {
                        *(&pLCDREG_test + i) = 0x00;
    1030:	11 92       	st	Z+, r1
            {
                if(!(PINB & 0x40))              // press UP to wake from SLEEP
                {
                    PowerSave = FALSE;
                    
                    for(i = 0; i < 20; i++ ) // set all LCD segment register to the variable ucSegments
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	e0 30       	cpi	r30, 0x00	; 0
    1036:	f8 07       	cpc	r31, r24
    1038:	d9 f7       	brne	.-10     	; 0x1030 <main+0x148>
                    {
                        *(&pLCDREG_test + i) = 0x00;
                    }
                    
                    sbiBF(LCDCRA, 7);           // enable LCD
    103a:	80 91 e4 00 	lds	r24, 0x00E4
    103e:	80 68       	ori	r24, 0x80	; 128
    1040:	80 93 e4 00 	sts	0x00E4, r24
                    input = getkey();           // Read buttons
    1044:	0e 94 3c 10 	call	0x2078	; 0x2078 <getkey>
    1048:	60 cf       	rjmp	.-320    	; 0xf0a <main+0x22>
                }
            }
        }
        else
        {
           set_sleep_mode(SLEEP_MODE_IDLE);
    104a:	83 b7       	in	r24, 0x33	; 51
    104c:	81 7f       	andi	r24, 0xF1	; 241
    104e:	83 bf       	out	0x33, r24	; 51
           sleep_mode();
    1050:	83 b7       	in	r24, 0x33	; 51
    1052:	81 60       	ori	r24, 0x01	; 1
    1054:	83 bf       	out	0x33, r24	; 51
    1056:	88 95       	sleep
    1058:	83 b7       	in	r24, 0x33	; 51
    105a:	8e 7f       	andi	r24, 0xFE	; 254
    105c:	83 bf       	out	0x33, r24	; 51
    105e:	55 cf       	rjmp	.-342    	; 0xf0a <main+0x22>

00001060 <Timer0_Init>:
    //mt char i;
    uint8_t i;

    // Initialize array of callback functions
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        CallbackFunc[i] = NULL;
    1060:	10 92 6a 01 	sts	0x016A, r1
    1064:	10 92 69 01 	sts	0x0169, r1
    1068:	10 92 6c 01 	sts	0x016C, r1
    106c:	10 92 6b 01 	sts	0x016B, r1
    1070:	10 92 6e 01 	sts	0x016E, r1
    1074:	10 92 6d 01 	sts	0x016D, r1
    1078:	10 92 70 01 	sts	0x0170, r1
    107c:	10 92 6f 01 	sts	0x016F, r1

    // Initialize countdown timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        CountDownTimers[i] = 255;
    1080:	8f ef       	ldi	r24, 0xFF	; 255
    1082:	80 93 65 01 	sts	0x0165, r24
    1086:	80 93 66 01 	sts	0x0166, r24
    108a:	80 93 67 01 	sts	0x0167, r24
    108e:	80 93 68 01 	sts	0x0168, r24

    // Initialize Timer0.
    // Used to give the correct time-delays in the song

    // Enable timer0 compare interrupt
    TIMSK0 = (1<<OCIE0A);
    1092:	82 e0       	ldi	r24, 0x02	; 2
    1094:	80 93 6e 00 	sts	0x006E, r24

    // Sets the compare value
    OCR0A = 38;
    1098:	86 e2       	ldi	r24, 0x26	; 38
    109a:	87 bd       	out	0x27, r24	; 39

    // Set Clear on Timer Compare (CTC) mode, CLK/256 prescaler
    TCCR0A = (1<<WGM01)|(0<<WGM00)|(4<<CS00);
    109c:	8c e0       	ldi	r24, 0x0C	; 12
    109e:	84 bd       	out	0x24, r24	; 36
}
    10a0:	08 95       	ret

000010a2 <__vector_10>:
// #pragma vector = TIMER0_COMP_vect
// __interrupt void TIMER0_COMP_interrupt(void)
// SIGNAL(SIG_OUTPUT_COMPARE0)
ISR(TIMER0_COMP_vect)
// mtE
{
    10a2:	1f 92       	push	r1
    10a4:	0f 92       	push	r0
    10a6:	0f b6       	in	r0, 0x3f	; 63
    10a8:	0f 92       	push	r0
    10aa:	11 24       	eor	r1, r1
    10ac:	2f 93       	push	r18
    10ae:	3f 93       	push	r19
    10b0:	4f 93       	push	r20
    10b2:	5f 93       	push	r21
    10b4:	6f 93       	push	r22
    10b6:	7f 93       	push	r23
    10b8:	8f 93       	push	r24
    10ba:	9f 93       	push	r25
    10bc:	af 93       	push	r26
    10be:	bf 93       	push	r27
    10c0:	ef 93       	push	r30
    10c2:	ff 93       	push	r31
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    10c4:	e0 91 69 01 	lds	r30, 0x0169
    10c8:	f0 91 6a 01 	lds	r31, 0x016A
    10cc:	30 97       	sbiw	r30, 0x00	; 0
    10ce:	09 f0       	breq	.+2      	; 0x10d2 <__vector_10+0x30>
            CallbackFunc[i]();
    10d0:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    10d2:	e0 91 6b 01 	lds	r30, 0x016B
    10d6:	f0 91 6c 01 	lds	r31, 0x016C
    10da:	30 97       	sbiw	r30, 0x00	; 0
    10dc:	09 f0       	breq	.+2      	; 0x10e0 <__vector_10+0x3e>
            CallbackFunc[i]();
    10de:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    10e0:	e0 91 6d 01 	lds	r30, 0x016D
    10e4:	f0 91 6e 01 	lds	r31, 0x016E
    10e8:	30 97       	sbiw	r30, 0x00	; 0
    10ea:	09 f0       	breq	.+2      	; 0x10ee <__vector_10+0x4c>
            CallbackFunc[i]();
    10ec:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    10ee:	e0 91 6f 01 	lds	r30, 0x016F
    10f2:	f0 91 70 01 	lds	r31, 0x0170
    10f6:	30 97       	sbiw	r30, 0x00	; 0
    10f8:	09 f0       	breq	.+2      	; 0x10fc <__vector_10+0x5a>
            CallbackFunc[i]();
    10fa:	09 95       	icall
    10fc:	e5 e6       	ldi	r30, 0x65	; 101
    10fe:	f1 e0       	ldi	r31, 0x01	; 1
    
    // Count down timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        if (CountDownTimers[i] != 255 && CountDownTimers[i] != 0)
    1100:	80 81       	ld	r24, Z
    1102:	81 50       	subi	r24, 0x01	; 1
    1104:	8e 3f       	cpi	r24, 0xFE	; 254
    1106:	08 f4       	brcc	.+2      	; 0x110a <__vector_10+0x68>
            CountDownTimers[i]--;
    1108:	80 83       	st	Z, r24
    110a:	31 96       	adiw	r30, 0x01	; 1
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
            CallbackFunc[i]();
    
    // Count down timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
    110c:	81 e0       	ldi	r24, 0x01	; 1
    110e:	e9 36       	cpi	r30, 0x69	; 105
    1110:	f8 07       	cpc	r31, r24
    1112:	b1 f7       	brne	.-20     	; 0x1100 <__vector_10+0x5e>
        if (CountDownTimers[i] != 255 && CountDownTimers[i] != 0)
            CountDownTimers[i]--;

}
    1114:	ff 91       	pop	r31
    1116:	ef 91       	pop	r30
    1118:	bf 91       	pop	r27
    111a:	af 91       	pop	r26
    111c:	9f 91       	pop	r25
    111e:	8f 91       	pop	r24
    1120:	7f 91       	pop	r23
    1122:	6f 91       	pop	r22
    1124:	5f 91       	pop	r21
    1126:	4f 91       	pop	r20
    1128:	3f 91       	pop	r19
    112a:	2f 91       	pop	r18
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	0f 90       	pop	r0
    1132:	1f 90       	pop	r1
    1134:	18 95       	reti

00001136 <Timer0_RegisterCallbackFunction>:
*   Purpose :       Set up functions to be called from the 
*                   TIMER0_COMP_interrupt
*
*****************************************************************************/
BOOL Timer0_RegisterCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    1136:	9c 01       	movw	r18, r24
    1138:	a9 e6       	ldi	r26, 0x69	; 105
    113a:	b1 e0       	ldi	r27, 0x01	; 1
    113c:	fd 01       	movw	r30, r26
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == pFunc)
    113e:	80 81       	ld	r24, Z
    1140:	91 81       	ldd	r25, Z+1	; 0x01
    1142:	82 17       	cp	r24, r18
    1144:	93 07       	cpc	r25, r19
    1146:	91 f0       	breq	.+36     	; 0x116c <Timer0_RegisterCallbackFunction+0x36>
    1148:	32 96       	adiw	r30, 0x02	; 2
BOOL Timer0_RegisterCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	e1 37       	cpi	r30, 0x71	; 113
    114e:	f8 07       	cpc	r31, r24
    1150:	b1 f7       	brne	.-20     	; 0x113e <Timer0_RegisterCallbackFunction+0x8>
    1152:	e0 e0       	ldi	r30, 0x00	; 0
    1154:	f0 e0       	ldi	r31, 0x00	; 0
            return TRUE;
    }
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == NULL)
    1156:	8d 91       	ld	r24, X+
    1158:	9c 91       	ld	r25, X
    115a:	11 97       	sbiw	r26, 0x01	; 1
    115c:	89 2b       	or	r24, r25
    115e:	41 f4       	brne	.+16     	; 0x1170 <Timer0_RegisterCallbackFunction+0x3a>
        {
            CallbackFunc[i] = pFunc;
    1160:	ee 0f       	add	r30, r30
    1162:	ff 1f       	adc	r31, r31
    1164:	e7 59       	subi	r30, 0x97	; 151
    1166:	fe 4f       	sbci	r31, 0xFE	; 254
    1168:	31 83       	std	Z+1, r19	; 0x01
    116a:	20 83       	st	Z, r18
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	08 95       	ret
            return TRUE;
    1170:	31 96       	adiw	r30, 0x01	; 1
    1172:	12 96       	adiw	r26, 0x02	; 2
    {
        if (CallbackFunc[i] == pFunc)
            return TRUE;
    }
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    1174:	e4 30       	cpi	r30, 0x04	; 4
    1176:	f1 05       	cpc	r31, r1
    1178:	71 f7       	brne	.-36     	; 0x1156 <Timer0_RegisterCallbackFunction+0x20>
    117a:	80 e0       	ldi	r24, 0x00	; 0
            return TRUE;
        }   
    }
    
    return FALSE;
}
    117c:	08 95       	ret

0000117e <Timer0_RemoveCallbackFunction>:
*   Purpose :       Remove functions from the list which is called int the
*                   TIMER0_COMP_interrupt
*
*****************************************************************************/
BOOL Timer0_RemoveCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    117e:	9c 01       	movw	r18, r24
    1180:	a9 e6       	ldi	r26, 0x69	; 105
    1182:	b1 e0       	ldi	r27, 0x01	; 1
    1184:	e0 e0       	ldi	r30, 0x00	; 0
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == pFunc)
    1188:	8d 91       	ld	r24, X+
    118a:	9c 91       	ld	r25, X
    118c:	11 97       	sbiw	r26, 0x01	; 1
    118e:	82 17       	cp	r24, r18
    1190:	93 07       	cpc	r25, r19
    1192:	41 f4       	brne	.+16     	; 0x11a4 <Timer0_RemoveCallbackFunction+0x26>
        {
            CallbackFunc[i] = NULL;
    1194:	ee 0f       	add	r30, r30
    1196:	ff 1f       	adc	r31, r31
    1198:	e7 59       	subi	r30, 0x97	; 151
    119a:	fe 4f       	sbci	r31, 0xFE	; 254
    119c:	11 82       	std	Z+1, r1	; 0x01
    119e:	10 82       	st	Z, r1
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	08 95       	ret
            return TRUE;
    11a4:	31 96       	adiw	r30, 0x01	; 1
    11a6:	12 96       	adiw	r26, 0x02	; 2
BOOL Timer0_RemoveCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    11a8:	e4 30       	cpi	r30, 0x04	; 4
    11aa:	f1 05       	cpc	r31, r1
    11ac:	69 f7       	brne	.-38     	; 0x1188 <Timer0_RemoveCallbackFunction+0xa>
    11ae:	80 e0       	ldi	r24, 0x00	; 0
            return TRUE;
        }
    }
        
    return FALSE;
}
    11b0:	08 95       	ret

000011b2 <Timer0_AllocateCountdownTimer>:


char Timer0_AllocateCountdownTimer()
{
    11b2:	20 e0       	ldi	r18, 0x00	; 0
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    // mt char i;
    uint8_t i;

    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        if (CountDownTimers[i] == 255)
    11b6:	f9 01       	movw	r30, r18
    11b8:	eb 59       	subi	r30, 0x9B	; 155
    11ba:	fe 4f       	sbci	r31, 0xFE	; 254
    11bc:	80 81       	ld	r24, Z
    11be:	8f 3f       	cpi	r24, 0xFF	; 255
    11c0:	21 f4       	brne	.+8      	; 0x11ca <Timer0_AllocateCountdownTimer+0x18>
        {
            CountDownTimers[i] = 0;
    11c2:	10 82       	st	Z, r1
            return i+1;
    11c4:	82 2f       	mov	r24, r18
    11c6:	8f 5f       	subi	r24, 0xFF	; 255
    11c8:	08 95       	ret
    11ca:	2f 5f       	subi	r18, 0xFF	; 255
    11cc:	3f 4f       	sbci	r19, 0xFF	; 255
char Timer0_AllocateCountdownTimer()
{
    // mt char i;
    uint8_t i;

    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
    11ce:	24 30       	cpi	r18, 0x04	; 4
    11d0:	31 05       	cpc	r19, r1
    11d2:	89 f7       	brne	.-30     	; 0x11b6 <Timer0_AllocateCountdownTimer+0x4>
    11d4:	80 e0       	ldi	r24, 0x00	; 0
            CountDownTimers[i] = 0;
            return i+1;
        }

    return 0;
}
    11d6:	08 95       	ret

000011d8 <CHAR2BCD2>:
*                   The result is byte where the high and low nibbles
*                   contain the tens and ones of the input.
*
*****************************************************************************/
char CHAR2BCD2(char input)
{
    11d8:	98 2f       	mov	r25, r24
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	02 c0       	rjmp	.+4      	; 0x11e2 <CHAR2BCD2+0xa>
    char high = 0;
    
    
    while (input >= 10)                 // Count tens
    {
        high++;
    11de:	8f 5f       	subi	r24, 0xFF	; 255
        input -= 10;
    11e0:	9a 50       	subi	r25, 0x0A	; 10
char CHAR2BCD2(char input)
{
    char high = 0;
    
    
    while (input >= 10)                 // Count tens
    11e2:	9a 30       	cpi	r25, 0x0A	; 10
    11e4:	e0 f7       	brcc	.-8      	; 0x11de <CHAR2BCD2+0x6>
    11e6:	82 95       	swap	r24
    11e8:	80 7f       	andi	r24, 0xF0	; 240
        high++;
        input -= 10;
    }

    return  (high << 4) | input;        // Add ones and return answer
}
    11ea:	89 2b       	or	r24, r25
    11ec:	08 95       	ret

000011ee <CHAR2BCD3>:
*                   The result is an integer where the three lowest nibbles
*                   contain the ones, tens and hundreds of the input.
*
*****************************************************************************/
unsigned int CHAR2BCD3(char input)
{
    11ee:	20 e0       	ldi	r18, 0x00	; 0
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	03 c0       	rjmp	.+6      	; 0x11fa <CHAR2BCD3+0xc>
    int high = 0;
        
    while (input >= 100)                // Count hundreds
    {
        high++;
    11f4:	2f 5f       	subi	r18, 0xFF	; 255
    11f6:	3f 4f       	sbci	r19, 0xFF	; 255
        input -= 100;
    11f8:	84 56       	subi	r24, 0x64	; 100
*****************************************************************************/
unsigned int CHAR2BCD3(char input)
{
    int high = 0;
        
    while (input >= 100)                // Count hundreds
    11fa:	84 36       	cpi	r24, 0x64	; 100
    11fc:	d8 f7       	brcc	.-10     	; 0x11f4 <CHAR2BCD3+0x6>
    {
        high++;
        input -= 100;
    }

    high <<= 4;
    11fe:	54 e0       	ldi	r21, 0x04	; 4
    1200:	22 0f       	add	r18, r18
    1202:	33 1f       	adc	r19, r19
    1204:	5a 95       	dec	r21
    1206:	e1 f7       	brne	.-8      	; 0x1200 <CHAR2BCD3+0x12>
    1208:	03 c0       	rjmp	.+6      	; 0x1210 <CHAR2BCD3+0x22>
    
    while (input >= 10)                 // Count tens
    {
        high++;
    120a:	2f 5f       	subi	r18, 0xFF	; 255
    120c:	3f 4f       	sbci	r19, 0xFF	; 255
        input -= 10;
    120e:	8a 50       	subi	r24, 0x0A	; 10
        input -= 100;
    }

    high <<= 4;
    
    while (input >= 10)                 // Count tens
    1210:	8a 30       	cpi	r24, 0x0A	; 10
    1212:	d8 f7       	brcc	.-10     	; 0x120a <CHAR2BCD3+0x1c>
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	44 e0       	ldi	r20, 0x04	; 4
    1218:	22 0f       	add	r18, r18
    121a:	33 1f       	adc	r19, r19
    121c:	4a 95       	dec	r20
    121e:	e1 f7       	brne	.-8      	; 0x1218 <CHAR2BCD3+0x2a>
        high++;
        input -= 10;
    }

    return  (high << 4) | input;        // Add ones and return answer
}
    1220:	82 2b       	or	r24, r18
    1222:	93 2b       	or	r25, r19
    1224:	08 95       	ret

00001226 <USART_Init>:
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    1226:	29 2f       	mov	r18, r25
    1228:	33 27       	eor	r19, r19
    122a:	20 93 c5 00 	sts	0x00C5, r18
    UBRRL = (unsigned char)baudrate;
    122e:	80 93 c4 00 	sts	0x00C4, r24

    // Enable 2x speed
    UCSRA = (1<<U2X);
    1232:	82 e0       	ldi	r24, 0x02	; 2
    1234:	80 93 c0 00 	sts	0x00C0, r24
    UCSRB = (1<<RXEN)|(1<<TXEN)|(0<<RXCIE)|(0<<UDRIE);
#else
    // Enable receive. transmit stays disabled
    // In the default BF demo-application no data gets 
    // send (only receive in vcard).
    UCSRB = (1<<RXEN)|(0<<TXEN)|(0<<RXCIE)|(0<<UDRIE);
    1238:	80 e1       	ldi	r24, 0x10	; 16
    123a:	80 93 c1 00 	sts	0x00C1, r24
#endif

    // Async. mode, 8N1
    UCSRC = (0<<UMSEL)|(0<<UPM0)|(0<<USBS)|(3<<UCSZ0)|(0<<UCPOL);
    123e:	86 e0       	ldi	r24, 0x06	; 6
    1240:	80 93 c2 00 	sts	0x00C2, r24
}
    1244:	08 95       	ret

00001246 <ADC_read>:
    // mt int ADC = 0 ;
    int ADCr = 0;
    
    // To save power, the voltage over the LDR and the NTC is turned off when not used
    // This is done by controlling the voltage from a I/O-pin (PORTF3)
    sbiBF(PORTF, PF3); // mt sbi(PORTF, PORTF3);     // Enable the VCP (VC-peripheral)
    1246:	8b 9a       	sbi	0x11, 3	; 17
    sbiBF(DDRF, DDF3); // sbi(DDRF, PORTF3);        
    1248:	83 9a       	sbi	0x10, 3	; 16

    sbiBF(ADCSRA, ADEN);     // Enable the ADC
    124a:	80 91 7a 00 	lds	r24, 0x007A
    124e:	80 68       	ori	r24, 0x80	; 128
    1250:	80 93 7a 00 	sts	0x007A, r24

    //do a dummy readout first
    ADCSRA |= (1<<ADSC);        // do single conversion
    1254:	80 91 7a 00 	lds	r24, 0x007A
    1258:	80 64       	ori	r24, 0x40	; 64
    125a:	80 93 7a 00 	sts	0x007A, r24
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
    125e:	80 91 7a 00 	lds	r24, 0x007A
    1262:	84 ff       	sbrs	r24, 4
    1264:	fc cf       	rjmp	.-8      	; 0x125e <ADC_read+0x18>
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	40 e0       	ldi	r20, 0x00	; 0
    126a:	50 e0       	ldi	r21, 0x00	; 0
        
    for(i=0;i<8;i++)            // do the ADC conversion 8 times for better accuracy 
    {
        ADCSRA |= (1<<ADSC);        // do single conversion
    126c:	80 91 7a 00 	lds	r24, 0x007A
    1270:	80 64       	ori	r24, 0x40	; 64
    1272:	80 93 7a 00 	sts	0x007A, r24
        while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
    1276:	80 91 7a 00 	lds	r24, 0x007A
    127a:	84 ff       	sbrs	r24, 4
    127c:	fc cf       	rjmp	.-8      	; 0x1276 <ADC_read+0x30>
        
        ADC_temp = ADCL;            // read out ADCL register
    127e:	20 91 78 00 	lds	r18, 0x0078
        ADC_temp += (ADCH << 8);    // read out ADCH register        
    1282:	80 91 79 00 	lds	r24, 0x0079

        ADCr += ADC_temp;      // accumulate result (8 samples) for later averaging
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	98 2f       	mov	r25, r24
    128a:	88 27       	eor	r24, r24
    128c:	82 0f       	add	r24, r18
    128e:	91 1d       	adc	r25, r1
    1290:	48 0f       	add	r20, r24
    1292:	59 1f       	adc	r21, r25

    //do a dummy readout first
    ADCSRA |= (1<<ADSC);        // do single conversion
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
        
    for(i=0;i<8;i++)            // do the ADC conversion 8 times for better accuracy 
    1294:	3f 5f       	subi	r19, 0xFF	; 255
    1296:	38 30       	cpi	r19, 0x08	; 8
    1298:	49 f7       	brne	.-46     	; 0x126c <ADC_read+0x26>
        ADCr += ADC_temp;      // accumulate result (8 samples) for later averaging
    }

    ADCr = ADCr >> 3;     // average the 8 samples
        
    cbiBF(PORTF,PF3); // mt cbi(PORTF, PORTF3);     // disable the VCP
    129a:	8b 98       	cbi	0x11, 3	; 17
    cbiBF(DDRF,DDF3); // mt cbi(DDRF, PORTF3);  
    129c:	83 98       	cbi	0x10, 3	; 16
    
    cbiBF(ADCSRA, ADEN);      // disable the ADC
    129e:	80 91 7a 00 	lds	r24, 0x007A
    12a2:	8f 77       	andi	r24, 0x7F	; 127
    12a4:	80 93 7a 00 	sts	0x007A, r24

    return ADCr;
}
    12a8:	ca 01       	movw	r24, r20
    12aa:	23 e0       	ldi	r18, 0x03	; 3
    12ac:	95 95       	asr	r25
    12ae:	87 95       	ror	r24
    12b0:	2a 95       	dec	r18
    12b2:	e1 f7       	brne	.-8      	; 0x12ac <ADC_read+0x66>
    12b4:	08 95       	ret

000012b6 <ADC_init>:
*
*****************************************************************************/
void ADC_init(char input)
{
  
    ADMUX = input;    // external AREF and ADCx
    12b6:	80 93 7c 00 	sts	0x007C, r24
    
    ADCSRA = (1<<ADEN) | (1<<ADPS1) | (1<<ADPS0);    // set ADC prescaler to , 1MHz / 8 = 125kHz    
    12ba:	83 e8       	ldi	r24, 0x83	; 131
    12bc:	80 93 7a 00 	sts	0x007A, r24

    input = ADC_read();        // dummy 
}
    12c0:	c2 cf       	rjmp	.-124    	; 0x1246 <ADC_read>

000012c2 <LightFunc>:
*
*   Purpose :       Enable or disable light measurements
*
*****************************************************************************/
char LightFunc(char input)
{
    12c2:	1f 93       	push	r17
    12c4:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    12c6:	80 91 0b 01 	lds	r24, 0x010B
    12ca:	88 23       	and	r24, r24
    12cc:	41 f0       	breq	.+16     	; 0x12de <LightFunc+0x1c>
    {
    
        enter = 0;
    12ce:	10 92 0b 01 	sts	0x010B, r1
        
        ADC_init(LIGHT_SENSOR);     // Init the ADC
    12d2:	82 e0       	ldi	r24, 0x02	; 2
    12d4:	f0 df       	rcall	.-32     	; 0x12b6 <ADC_init>
        
        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)  
        Timer0_RegisterCallbackFunction(ADC_periphery);        
    12d6:	8f ec       	ldi	r24, 0xCF	; 207
    12d8:	99 e0       	ldi	r25, 0x09	; 9
    12da:	2d df       	rcall	.-422    	; 0x1136 <Timer0_RegisterCallbackFunction>
    12dc:	03 c0       	rjmp	.+6      	; 0x12e4 <LightFunc+0x22>
    }
    else
        LCD_UpdateRequired(TRUE, 0); 
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	60 e0       	ldi	r22, 0x00	; 0
    12e2:	ae d7       	rcall	.+3932   	; 0x2240 <LCD_UpdateRequired>

    if (input == KEY_PREV)
    12e4:	13 30       	cpi	r17, 0x03	; 3
    12e6:	11 f0       	breq	.+4      	; 0x12ec <LightFunc+0x2a>
    12e8:	81 e5       	ldi	r24, 0x51	; 81
    12ea:	07 c0       	rjmp	.+14     	; 0x12fa <LightFunc+0x38>
    {
        // Disable the auto-run of the ADC_periphery      
        Timer0_RemoveCallbackFunction(ADC_periphery);
    12ec:	8f ec       	ldi	r24, 0xCF	; 207
    12ee:	99 e0       	ldi	r25, 0x09	; 9
    12f0:	46 df       	rcall	.-372    	; 0x117e <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	80 93 0b 01 	sts	0x010B, r24
    12f8:	80 e5       	ldi	r24, 0x50	; 80
    
        return ST_LIGHT;
    }
    else
        return ST_LIGHT_FUNC;    
}
    12fa:	1f 91       	pop	r17
    12fc:	08 95       	ret

000012fe <VoltageFunc>:
*
*   Purpose :       Enable or disable voltage measurements
*
*****************************************************************************/
char VoltageFunc(char input)
{
    12fe:	1f 93       	push	r17
    1300:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    1302:	80 91 0c 01 	lds	r24, 0x010C
    1306:	88 23       	and	r24, r24
    1308:	41 f0       	breq	.+16     	; 0x131a <VoltageFunc+0x1c>
    {
        enter = 0;
    130a:	10 92 0c 01 	sts	0x010C, r1

        ADC_init(VOLTAGE_SENSOR);       // Init the ADC
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	d2 df       	rcall	.-92     	; 0x12b6 <ADC_init>
        
        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)        
        Timer0_RegisterCallbackFunction(ADC_periphery);        
    1312:	8f ec       	ldi	r24, 0xCF	; 207
    1314:	99 e0       	ldi	r25, 0x09	; 9
    1316:	0f df       	rcall	.-482    	; 0x1136 <Timer0_RegisterCallbackFunction>
    1318:	03 c0       	rjmp	.+6      	; 0x1320 <VoltageFunc+0x22>
    }
    else
        LCD_UpdateRequired(TRUE, 0); 
    131a:	81 e0       	ldi	r24, 0x01	; 1
    131c:	60 e0       	ldi	r22, 0x00	; 0
    131e:	90 d7       	rcall	.+3872   	; 0x2240 <LCD_UpdateRequired>

    if (input == KEY_PREV)
    1320:	13 30       	cpi	r17, 0x03	; 3
    1322:	11 f0       	breq	.+4      	; 0x1328 <VoltageFunc+0x2a>
    1324:	87 e4       	ldi	r24, 0x47	; 71
    1326:	07 c0       	rjmp	.+14     	; 0x1336 <VoltageFunc+0x38>
    {
        // Disable the auto-run of the ADC_periphery        
        Timer0_RemoveCallbackFunction(ADC_periphery);
    1328:	8f ec       	ldi	r24, 0xCF	; 207
    132a:	99 e0       	ldi	r25, 0x09	; 9
    132c:	28 df       	rcall	.-432    	; 0x117e <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	80 93 0c 01 	sts	0x010C, r24
    1334:	86 e4       	ldi	r24, 0x46	; 70
        
        return ST_VOLTAGE;
    }
    else
        return ST_VOLTAGE_FUNC;    
}
    1336:	1f 91       	pop	r17
    1338:	08 95       	ret

0000133a <TemperatureFunc>:
*
*   Purpose :       Enable or disable temperature measurements
*
*****************************************************************************/
char TemperatureFunc(char input)
{
    133a:	1f 93       	push	r17
    133c:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    133e:	80 91 0d 01 	lds	r24, 0x010D
    1342:	88 23       	and	r24, r24
    1344:	41 f0       	breq	.+16     	; 0x1356 <TemperatureFunc+0x1c>
    {
        enter = 0;
    1346:	10 92 0d 01 	sts	0x010D, r1
        
        ADC_init(TEMPERATURE_SENSOR);       // Init the ADC
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	b4 df       	rcall	.-152    	; 0x12b6 <ADC_init>

        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)
        Timer0_RegisterCallbackFunction(ADC_periphery); 
    134e:	8f ec       	ldi	r24, 0xCF	; 207
    1350:	99 e0       	ldi	r25, 0x09	; 9
    1352:	f1 de       	rcall	.-542    	; 0x1136 <Timer0_RegisterCallbackFunction>
    1354:	03 c0       	rjmp	.+6      	; 0x135c <TemperatureFunc+0x22>
    }
    else
        LCD_UpdateRequired(TRUE, 0);        // New data to be presented
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	60 e0       	ldi	r22, 0x00	; 0
    135a:	72 d7       	rcall	.+3812   	; 0x2240 <LCD_UpdateRequired>
    
    if (input == KEY_PREV)
    135c:	13 30       	cpi	r17, 0x03	; 3
    135e:	41 f4       	brne	.+16     	; 0x1370 <TemperatureFunc+0x36>
    {
        // Disable the auto-run of the ADC_periphery
        Timer0_RemoveCallbackFunction(ADC_periphery);
    1360:	8f ec       	ldi	r24, 0xCF	; 207
    1362:	99 e0       	ldi	r25, 0x09	; 9
    1364:	0c df       	rcall	.-488    	; 0x117e <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	80 93 0d 01 	sts	0x010D, r24
    136c:	8c e3       	ldi	r24, 0x3C	; 60
    136e:	15 c0       	rjmp	.+42     	; 0x139a <TemperatureFunc+0x60>
        
        return ST_TEMPERATURE;
    }
    else if (input == KEY_PLUS)
    1370:	14 30       	cpi	r17, 0x04	; 4
    1372:	39 f4       	brne	.+14     	; 0x1382 <TemperatureFunc+0x48>
    {   
        if (degree == FAHRENHEIT)
    1374:	80 91 0a 01 	lds	r24, 0x010A
    1378:	84 30       	cpi	r24, 0x04	; 4
    137a:	49 f0       	breq	.+18     	; 0x138e <TemperatureFunc+0x54>
            degree = CELSIUS;
        else
            degree = FAHRENHEIT;
    137c:	10 93 0a 01 	sts	0x010A, r17
    1380:	0b c0       	rjmp	.+22     	; 0x1398 <TemperatureFunc+0x5e>
    }
    else if (input == KEY_MINUS)
    1382:	15 30       	cpi	r17, 0x05	; 5
    1384:	49 f4       	brne	.+18     	; 0x1398 <TemperatureFunc+0x5e>
    {
        if (degree == FAHRENHEIT)
    1386:	80 91 0a 01 	lds	r24, 0x010A
    138a:	84 30       	cpi	r24, 0x04	; 4
    138c:	11 f4       	brne	.+4      	; 0x1392 <TemperatureFunc+0x58>
            degree = CELSIUS;
    138e:	83 e0       	ldi	r24, 0x03	; 3
    1390:	01 c0       	rjmp	.+2      	; 0x1394 <TemperatureFunc+0x5a>
        else
            degree = FAHRENHEIT;
    1392:	84 e0       	ldi	r24, 0x04	; 4
    1394:	80 93 0a 01 	sts	0x010A, r24
    1398:	8d e3       	ldi	r24, 0x3D	; 61
    }
    
    return ST_TEMPERATURE_FUNC;
}
    139a:	1f 91       	pop	r17
    139c:	08 95       	ret

0000139e <ADC_periphery>:
*   Purpose :       Calculates the Temperature/Voltage/Ligth from the ADC_read
*                   and puts it out on the LCD.
*
*****************************************************************************/
void ADC_periphery(void)
{
    139e:	9f 92       	push	r9
    13a0:	af 92       	push	r10
    13a2:	bf 92       	push	r11
    13a4:	cf 92       	push	r12
    13a6:	df 92       	push	r13
    13a8:	ef 92       	push	r14
    13aa:	ff 92       	push	r15
    13ac:	0f 93       	push	r16
    13ae:	1f 93       	push	r17
    13b0:	cf 93       	push	r28
    13b2:	df 93       	push	r29

    float V_ADC;
    char VoltageHB;
    char VoltageLB;
    
    ADCresult = ADC_read();         // Find the ADC value
    13b4:	48 df       	rcall	.-368    	; 0x1246 <ADC_read>
    13b6:	ec 01       	movw	r28, r24
     
    if( ADMUX == TEMPERATURE_SENSOR )
    13b8:	80 91 7c 00 	lds	r24, 0x007C
    13bc:	88 23       	and	r24, r24
    13be:	09 f0       	breq	.+2      	; 0x13c2 <ADC_periphery+0x24>
    13c0:	87 c0       	rjmp	.+270    	; 0x14d0 <ADC_periphery+0x132>
    {
        if(degree == CELSIUS)
    13c2:	80 91 0a 01 	lds	r24, 0x010A
    13c6:	83 30       	cpi	r24, 0x03	; 3
    13c8:	09 f0       	breq	.+2      	; 0x13cc <ADC_periphery+0x2e>
    13ca:	46 c0       	rjmp	.+140    	; 0x1458 <ADC_periphery+0xba>
        {
            if(ADCresult > 810)         // If it's a negtive temperature
    13cc:	83 e0       	ldi	r24, 0x03	; 3
    13ce:	cb 32       	cpi	r28, 0x2B	; 43
    13d0:	d8 07       	cpc	r29, r24
    13d2:	8c f0       	brlt	.+34     	; 0x13f6 <ADC_periphery+0x58>
    13d4:	2b e4       	ldi	r18, 0x4B	; 75
    13d6:	33 e0       	ldi	r19, 0x03	; 3
    13d8:	10 e0       	ldi	r17, 0x00	; 0
            {    
                for (i=0; i<=25; i++)   // Find the temperature
                {
                    // mt if (ADCresult <= TEMP_Celcius_neg[i])
                    if (ADCresult <= (int)pgm_read_word(&TEMP_Celsius_neg[i]))
    13da:	f9 01       	movw	r30, r18
    13dc:	85 91       	lpm	r24, Z+
    13de:	94 91       	lpm	r25, Z+
    13e0:	8c 17       	cp	r24, r28
    13e2:	9d 07       	cpc	r25, r29
    13e4:	2c f4       	brge	.+10     	; 0x13f0 <ADC_periphery+0x52>
    {
        if(degree == CELSIUS)
        {
            if(ADCresult > 810)         // If it's a negtive temperature
            {    
                for (i=0; i<=25; i++)   // Find the temperature
    13e6:	1f 5f       	subi	r17, 0xFF	; 255
    13e8:	2e 5f       	subi	r18, 0xFE	; 254
    13ea:	3f 4f       	sbci	r19, 0xFF	; 255
    13ec:	1a 31       	cpi	r17, 0x1A	; 26
    13ee:	a9 f7       	brne	.-22     	; 0x13da <ADC_periphery+0x3c>
                    {
                        break;
                    }
                }
                
                LCD_putc(1, '-');       // Put a minus sign in front of the temperature
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	6d e2       	ldi	r22, 0x2D	; 45
    13f4:	14 c0       	rjmp	.+40     	; 0x141e <ADC_periphery+0x80>
            }
            else if (ADCresult < 800)   // If it's a positive temperature
    13f6:	93 e0       	ldi	r25, 0x03	; 3
    13f8:	c0 32       	cpi	r28, 0x20	; 32
    13fa:	d9 07       	cpc	r29, r25
    13fc:	94 f4       	brge	.+36     	; 0x1422 <ADC_periphery+0x84>
    13fe:	21 ed       	ldi	r18, 0xD1	; 209
    1400:	32 e0       	ldi	r19, 0x02	; 2
    1402:	10 e0       	ldi	r17, 0x00	; 0
            {
                for (i=0; i<100; i++)  
                {
                    // mt if (ADCresult >= TEMP_Celcius_pos[i])
                    if (ADCresult >= (int)pgm_read_word(&TEMP_Celsius_pos[i]))
    1404:	f9 01       	movw	r30, r18
    1406:	85 91       	lpm	r24, Z+
    1408:	94 91       	lpm	r25, Z+
    140a:	c8 17       	cp	r28, r24
    140c:	d9 07       	cpc	r29, r25
    140e:	2c f4       	brge	.+10     	; 0x141a <ADC_periphery+0x7c>
                
                LCD_putc(1, '-');       // Put a minus sign in front of the temperature
            }
            else if (ADCresult < 800)   // If it's a positive temperature
            {
                for (i=0; i<100; i++)  
    1410:	1f 5f       	subi	r17, 0xFF	; 255
    1412:	2e 5f       	subi	r18, 0xFE	; 254
    1414:	3f 4f       	sbci	r19, 0xFF	; 255
    1416:	14 36       	cpi	r17, 0x64	; 100
    1418:	a9 f7       	brne	.-22     	; 0x1404 <ADC_periphery+0x66>
                    {
                        break;
                    }
                }        
            
                LCD_putc(1, '+');       // Put a plus sign in front of the temperature
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	6b e2       	ldi	r22, 0x2B	; 43
    141e:	f7 d6       	rcall	.+3566   	; 0x220e <LCD_putc>
    1420:	04 c0       	rjmp	.+8      	; 0x142a <ADC_periphery+0x8c>
            }
            else                        //If the temperature is zero degrees
            {
                i = 0;
                LCD_putc(1, ' ');
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	60 e2       	ldi	r22, 0x20	; 32
    1426:	f3 d6       	rcall	.+3558   	; 0x220e <LCD_putc>
    1428:	10 e0       	ldi	r17, 0x00	; 0
            }
            
            Temp = CHAR2BCD2(i);        // Convert from char to bin
    142a:	81 2f       	mov	r24, r17
    142c:	d5 de       	rcall	.-598    	; 0x11d8 <CHAR2BCD2>
    142e:	18 2f       	mov	r17, r24
    
            TL = (Temp & 0x0F) + '0';   // Find the low-byte
            TH = (Temp >> 4) + '0';     // Find the high-byte
            
            LCD_putc(0, ' ');
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	60 e2       	ldi	r22, 0x20	; 32
    1434:	ec d6       	rcall	.+3544   	; 0x220e <LCD_putc>
            //LCD character 1 is allready written to
            LCD_putc(2, TH);
    1436:	61 2f       	mov	r22, r17
    1438:	62 95       	swap	r22
    143a:	6f 70       	andi	r22, 0x0F	; 15
    143c:	60 5d       	subi	r22, 0xD0	; 208
    143e:	82 e0       	ldi	r24, 0x02	; 2
    1440:	e6 d6       	rcall	.+3532   	; 0x220e <LCD_putc>
            LCD_putc(3, TL);
    1442:	1f 70       	andi	r17, 0x0F	; 15
    1444:	10 5d       	subi	r17, 0xD0	; 208
    1446:	83 e0       	ldi	r24, 0x03	; 3
    1448:	61 2f       	mov	r22, r17
    144a:	e1 d6       	rcall	.+3522   	; 0x220e <LCD_putc>
            LCD_putc(4, '*');
    144c:	84 e0       	ldi	r24, 0x04	; 4
    144e:	6a e2       	ldi	r22, 0x2A	; 42
    1450:	de d6       	rcall	.+3516   	; 0x220e <LCD_putc>
            LCD_putc(5, 'C');
    1452:	85 e0       	ldi	r24, 0x05	; 5
    1454:	63 e4       	ldi	r22, 0x43	; 67
    1456:	0a c1       	rjmp	.+532    	; 0x166c <ADC_periphery+0x2ce>
            LCD_putc(6, '\0');
        }
        else if (degree == FAHRENHEIT)
    1458:	84 30       	cpi	r24, 0x04	; 4
    145a:	09 f0       	breq	.+2      	; 0x145e <ADC_periphery+0xc0>
    145c:	0b c1       	rjmp	.+534    	; 0x1674 <ADC_periphery+0x2d6>
    145e:	29 e6       	ldi	r18, 0x69	; 105
    1460:	33 e0       	ldi	r19, 0x03	; 3
    1462:	10 e0       	ldi	r17, 0x00	; 0
        {
            for (i=0; i<=141; i++)   // Find the temperature
            {
                // mt if (ADCresult > TEMP_Farenheit_pos[i])
                if (ADCresult > (int)pgm_read_word(&TEMP_Fahrenheit_pos[i]))
    1464:	f9 01       	movw	r30, r18
    1466:	85 91       	lpm	r24, Z+
    1468:	94 91       	lpm	r25, Z+
    146a:	8c 17       	cp	r24, r28
    146c:	9d 07       	cpc	r25, r29
    146e:	2c f0       	brlt	.+10     	; 0x147a <ADC_periphery+0xdc>
            LCD_putc(5, 'C');
            LCD_putc(6, '\0');
        }
        else if (degree == FAHRENHEIT)
        {
            for (i=0; i<=141; i++)   // Find the temperature
    1470:	1f 5f       	subi	r17, 0xFF	; 255
    1472:	2e 5f       	subi	r18, 0xFE	; 254
    1474:	3f 4f       	sbci	r19, 0xFF	; 255
    1476:	1e 38       	cpi	r17, 0x8E	; 142
    1478:	a9 f7       	brne	.-22     	; 0x1464 <ADC_periphery+0xc6>
                {
                    break;
                }
            }        
        
            Temp_int = CHAR2BCD3(i);
    147a:	81 2f       	mov	r24, r17
    147c:	b8 de       	rcall	.-656    	; 0x11ee <CHAR2BCD3>
    147e:	ec 01       	movw	r28, r24
        
            if (i > 99) // if there are three digits
    1480:	14 36       	cpi	r17, 0x64	; 100
    1482:	50 f0       	brcs	.+20     	; 0x1498 <ADC_periphery+0xfa>
            {
                LCD_putc(0, '+');
    1484:	80 e0       	ldi	r24, 0x00	; 0
    1486:	6b e2       	ldi	r22, 0x2B	; 43
    1488:	c2 d6       	rcall	.+3460   	; 0x220e <LCD_putc>
                TH = (Temp_int >> 8) + '0';   // Find the high-byte
                LCD_putc(1, TH);
    148a:	6d 2f       	mov	r22, r29
    148c:	77 27       	eor	r23, r23
    148e:	67 fd       	sbrc	r22, 7
    1490:	7a 95       	dec	r23
    1492:	60 5d       	subi	r22, 0xD0	; 208
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	05 c0       	rjmp	.+10     	; 0x14a2 <ADC_periphery+0x104>
            }
            else    // if only two digits
            {
                LCD_putc(0, ' ');
    1498:	80 e0       	ldi	r24, 0x00	; 0
    149a:	60 e2       	ldi	r22, 0x20	; 32
    149c:	b8 d6       	rcall	.+3440   	; 0x220e <LCD_putc>
                LCD_putc(1, '+');
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	6b e2       	ldi	r22, 0x2B	; 43
    14a2:	b5 d6       	rcall	.+3434   	; 0x220e <LCD_putc>
            }
            
            TL = (Temp_int & 0x0F) + '0';   // Find the low-byte
            TH = ( (Temp_int >> 4) & 0x0F ) + '0';     // Find the high-byte                

            LCD_putc(2, TH);
    14a4:	be 01       	movw	r22, r28
    14a6:	e4 e0       	ldi	r30, 0x04	; 4
    14a8:	75 95       	asr	r23
    14aa:	67 95       	ror	r22
    14ac:	ea 95       	dec	r30
    14ae:	e1 f7       	brne	.-8      	; 0x14a8 <ADC_periphery+0x10a>
    14b0:	6f 70       	andi	r22, 0x0F	; 15
    14b2:	60 5d       	subi	r22, 0xD0	; 208
    14b4:	82 e0       	ldi	r24, 0x02	; 2
    14b6:	ab d6       	rcall	.+3414   	; 0x220e <LCD_putc>
            LCD_putc(3, TL);
    14b8:	ce 01       	movw	r24, r28
    14ba:	8f 70       	andi	r24, 0x0F	; 15
    14bc:	68 2f       	mov	r22, r24
    14be:	60 5d       	subi	r22, 0xD0	; 208
    14c0:	83 e0       	ldi	r24, 0x03	; 3
    14c2:	a5 d6       	rcall	.+3402   	; 0x220e <LCD_putc>
            LCD_putc(4, '*');
    14c4:	84 e0       	ldi	r24, 0x04	; 4
    14c6:	6a e2       	ldi	r22, 0x2A	; 42
    14c8:	a2 d6       	rcall	.+3396   	; 0x220e <LCD_putc>
            LCD_putc(5, 'F');
    14ca:	85 e0       	ldi	r24, 0x05	; 5
    14cc:	66 e4       	ldi	r22, 0x46	; 70
    14ce:	ce c0       	rjmp	.+412    	; 0x166c <ADC_periphery+0x2ce>

//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);        

    }
    else if( ADMUX == VOLTAGE_SENSOR )
    14d0:	80 91 7c 00 	lds	r24, 0x007C
    14d4:	81 30       	cpi	r24, 0x01	; 1
    14d6:	09 f0       	breq	.+2      	; 0x14da <ADC_periphery+0x13c>
    14d8:	9e c0       	rjmp	.+316    	; 0x1616 <ADC_periphery+0x278>
        //  Do a Light-measurement first to determine the Vref, 
        //  because the LDR affects the Vref 

        ADCresult_temp = ADCresult;     // Store the ADCresult from the voltage reading
          
        ADC_init(LIGHT_SENSOR);         // Init the ADC to measure light
    14da:	82 e0       	ldi	r24, 0x02	; 2
    14dc:	ec de       	rcall	.-552    	; 0x12b6 <ADC_init>
            
        ADCresult = ADC_read();         // Read the light value
    14de:	b3 de       	rcall	.-666    	; 0x1246 <ADC_read>
    14e0:	bc 01       	movw	r22, r24
    14e2:	23 e8       	ldi	r18, 0x83	; 131
    14e4:	34 e0       	ldi	r19, 0x04	; 4
    14e6:	40 e0       	ldi	r20, 0x00	; 0

        // Find Vref
        for (i=0; i<=22; i++)
        {
            // mt if (ADCresult <= LIGHT_ADC[i])
            if (ADCresult <= (int)pgm_read_word(&LIGHT_ADC[i]))
    14e8:	f9 01       	movw	r30, r18
    14ea:	85 91       	lpm	r24, Z+
    14ec:	94 91       	lpm	r25, Z+
    14ee:	86 17       	cp	r24, r22
    14f0:	97 07       	cpc	r25, r23
    14f2:	34 f4       	brge	.+12     	; 0x1500 <ADC_periphery+0x162>
        ADC_init(LIGHT_SENSOR);         // Init the ADC to measure light
            
        ADCresult = ADC_read();         // Read the light value

        // Find Vref
        for (i=0; i<=22; i++)
    14f4:	4f 5f       	subi	r20, 0xFF	; 255
    14f6:	2e 5f       	subi	r18, 0xFE	; 254
    14f8:	3f 4f       	sbci	r19, 0xFF	; 255
    14fa:	47 31       	cpi	r20, 0x17	; 23
    14fc:	a9 f7       	brne	.-22     	; 0x14e8 <ADC_periphery+0x14a>
    14fe:	09 c0       	rjmp	.+18     	; 0x1512 <ADC_periphery+0x174>
            if (ADCresult <= (int)pgm_read_word(&LIGHT_ADC[i]))
            {
                break;
            }
        }
        if(!i)              // if it's very bright
    1500:	44 23       	and	r20, r20
    1502:	29 f4       	brne	.+10     	; 0x150e <ADC_periphery+0x170>
            Vref = 2.815;
    1504:	86 ef       	ldi	r24, 0xF6	; 246
    1506:	98 e2       	ldi	r25, 0x28	; 40
    1508:	a4 e3       	ldi	r26, 0x34	; 52
    150a:	b0 e4       	ldi	r27, 0x40	; 64
    150c:	06 c0       	rjmp	.+12     	; 0x151a <ADC_periphery+0x17c>
        else if(i >= 21)
    150e:	45 31       	cpi	r20, 0x15	; 21
    1510:	68 f0       	brcs	.+26     	; 0x152c <ADC_periphery+0x18e>
            Vref = 2.942;   // if it's totally dark
    1512:	8a eb       	ldi	r24, 0xBA	; 186
    1514:	99 e4       	ldi	r25, 0x49	; 73
    1516:	ac e3       	ldi	r26, 0x3C	; 60
    1518:	b0 e4       	ldi	r27, 0x40	; 64
    151a:	80 93 06 01 	sts	0x0106, r24
    151e:	90 93 07 01 	sts	0x0107, r25
    1522:	a0 93 08 01 	sts	0x0108, r26
    1526:	b0 93 09 01 	sts	0x0109, r27
    152a:	18 c0       	rjmp	.+48     	; 0x155c <ADC_periphery+0x1be>
        else {
            // mt: Vref = LIGHT_VOLTAGE[i];   
            // mt using helper from pgmspacehlp.h - new code
            Vref = pgm_read_float_hlp(&LIGHT_VOLTAGE[i]);
    152c:	84 2f       	mov	r24, r20
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	88 0f       	add	r24, r24
    1532:	99 1f       	adc	r25, r25
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	83 55       	subi	r24, 0x53	; 83
    153a:	9b 4f       	sbci	r25, 0xFB	; 251
	{
		uint16_t i[2];
		float f;
	} u;
	
	u.i[0]=pgm_read_word((PGM_P)addr);
    153c:	fc 01       	movw	r30, r24
    153e:	65 91       	lpm	r22, Z+
    1540:	74 91       	lpm	r23, Z+
    1542:	9b 01       	movw	r18, r22
	u.i[1]=pgm_read_word((PGM_P)addr+2);
    1544:	fc 01       	movw	r30, r24
    1546:	32 96       	adiw	r30, 0x02	; 2
    1548:	45 91       	lpm	r20, Z+
    154a:	54 91       	lpm	r21, Z+
    154c:	20 93 06 01 	sts	0x0106, r18
    1550:	30 93 07 01 	sts	0x0107, r19
    1554:	40 93 08 01 	sts	0x0108, r20
    1558:	50 93 09 01 	sts	0x0109, r21
        }
          
        ADMUX = VOLTAGE_SENSOR;     
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	80 93 7c 00 	sts	0x007C, r24
        ADCresult = ADCresult_temp; // Get the ADCresult from the voltage reading

        // Light-measurement finished

        V_ADC = ( ADCresult * Vref ) / 1024; // Calculate the voltage
    1562:	be 01       	movw	r22, r28
    1564:	88 27       	eor	r24, r24
    1566:	77 fd       	sbrc	r23, 7
    1568:	80 95       	com	r24
    156a:	98 2f       	mov	r25, r24
    156c:	0e 94 21 16 	call	0x2c42	; 0x2c42 <__floatsisf>
    1570:	20 91 06 01 	lds	r18, 0x0106
    1574:	30 91 07 01 	lds	r19, 0x0107
    1578:	40 91 08 01 	lds	r20, 0x0108
    157c:	50 91 09 01 	lds	r21, 0x0109
    1580:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <__mulsf3>
    1584:	20 e0       	ldi	r18, 0x00	; 0
    1586:	30 e0       	ldi	r19, 0x00	; 0
    1588:	40 e8       	ldi	r20, 0x80	; 128
    158a:	5a e3       	ldi	r21, 0x3A	; 58
    158c:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <__mulsf3>
           
        V_ADC = ( V_ADC * 6 );      // Multiply by 6 cause of the voltage division
    1590:	20 e0       	ldi	r18, 0x00	; 0
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	40 ec       	ldi	r20, 0xC0	; 192
    1596:	50 e4       	ldi	r21, 0x40	; 64
    1598:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <__mulsf3>
    159c:	5b 01       	movw	r10, r22
    159e:	6c 01       	movw	r12, r24
            
        VoltageHB = V_ADC;              // Store the high-byte
    15a0:	0e 94 f3 15 	call	0x2be6	; 0x2be6 <__fixunssfsi>
    15a4:	dc 01       	movw	r26, r24
    15a6:	cb 01       	movw	r24, r22
    15a8:	e8 2e       	mov	r14, r24
        V_ADC = ( V_ADC - VoltageHB );
        VoltageLB = ( V_ADC * 100 );    // Store the low-byte
     
        Temp = CHAR2BCD2(VoltageHB);    // Convert from char to bin
    15aa:	16 de       	rcall	.-980    	; 0x11d8 <CHAR2BCD2>
    15ac:	98 2e       	mov	r9, r24
    
        TL = (Temp & 0x0F) + '0';
        TH = (Temp >> 4) + '0';
            
        Temp = CHAR2BCD2(VoltageLB);    // Convert from char to bin
    15ae:	ff 24       	eor	r15, r15
    15b0:	00 27       	eor	r16, r16
    15b2:	f7 fc       	sbrc	r15, 7
    15b4:	00 95       	com	r16
    15b6:	10 2f       	mov	r17, r16
    15b8:	c8 01       	movw	r24, r16
    15ba:	b7 01       	movw	r22, r14
    15bc:	0e 94 21 16 	call	0x2c42	; 0x2c42 <__floatsisf>
    15c0:	9b 01       	movw	r18, r22
    15c2:	ac 01       	movw	r20, r24
    15c4:	c6 01       	movw	r24, r12
    15c6:	b5 01       	movw	r22, r10
    15c8:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <__subsf3>
    15cc:	20 e0       	ldi	r18, 0x00	; 0
    15ce:	30 e0       	ldi	r19, 0x00	; 0
    15d0:	48 ec       	ldi	r20, 0xC8	; 200
    15d2:	52 e4       	ldi	r21, 0x42	; 66
    15d4:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <__mulsf3>
    15d8:	0e 94 f3 15 	call	0x2be6	; 0x2be6 <__fixunssfsi>
    15dc:	dc 01       	movw	r26, r24
    15de:	cb 01       	movw	r24, r22
    15e0:	fb dd       	rcall	.-1034   	; 0x11d8 <CHAR2BCD2>
    15e2:	18 2f       	mov	r17, r24
   
        VL = (Temp >> 4) + '0';

        LCD_putc(0, ' ');
    15e4:	80 e0       	ldi	r24, 0x00	; 0
    15e6:	60 e2       	ldi	r22, 0x20	; 32
    15e8:	12 d6       	rcall	.+3108   	; 0x220e <LCD_putc>
        LCD_putc(1, ' ');
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	60 e2       	ldi	r22, 0x20	; 32
    15ee:	0f d6       	rcall	.+3102   	; 0x220e <LCD_putc>
        LCD_putc(2, ' ');
    15f0:	82 e0       	ldi	r24, 0x02	; 2
    15f2:	60 e2       	ldi	r22, 0x20	; 32
    15f4:	0c d6       	rcall	.+3096   	; 0x220e <LCD_putc>
        LCD_putc(3, TL);
    15f6:	9f e0       	ldi	r25, 0x0F	; 15
    15f8:	99 22       	and	r9, r25
    15fa:	80 e3       	ldi	r24, 0x30	; 48
    15fc:	98 0e       	add	r9, r24
    15fe:	83 e0       	ldi	r24, 0x03	; 3
    1600:	69 2d       	mov	r22, r9
    1602:	05 d6       	rcall	.+3082   	; 0x220e <LCD_putc>
        LCD_putc(4, 'V');
    1604:	84 e0       	ldi	r24, 0x04	; 4
    1606:	66 e5       	ldi	r22, 0x56	; 86
    1608:	02 d6       	rcall	.+3076   	; 0x220e <LCD_putc>
        LCD_putc(5, VL);
    160a:	12 95       	swap	r17
    160c:	1f 70       	andi	r17, 0x0F	; 15
    160e:	10 5d       	subi	r17, 0xD0	; 208
    1610:	85 e0       	ldi	r24, 0x05	; 5
    1612:	61 2f       	mov	r22, r17
    1614:	2b c0       	rjmp	.+86     	; 0x166c <ADC_periphery+0x2ce>
        
//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);
                             
    }
    else if( ADMUX == LIGHT_SENSOR )
    1616:	80 91 7c 00 	lds	r24, 0x007C
    161a:	82 30       	cpi	r24, 0x02	; 2
    161c:	59 f5       	brne	.+86     	; 0x1674 <ADC_periphery+0x2d6>
    {
        // The relation between ADC-value and lux is yet to be found, 
        // for now the ADC-value is presented on the LCD
        
        VoltageHB = CHAR2BCD2(ADCH);    // Convert from char to bin
    161e:	80 91 79 00 	lds	r24, 0x0079
    1622:	da dd       	rcall	.-1100   	; 0x11d8 <CHAR2BCD2>

        Temp = ADCL;                
    1624:	90 91 78 00 	lds	r25, 0x0078
    
        TL = (Temp & 0x0F) + '0';       
    1628:	89 2f       	mov	r24, r25
    162a:	8f 70       	andi	r24, 0x0F	; 15
    162c:	08 2f       	mov	r16, r24
    162e:	00 5d       	subi	r16, 0xD0	; 208
        if(TL > '9')        // if the hex-value is over 9, add 7 in order to go 
    1630:	0a 33       	cpi	r16, 0x3A	; 58
    1632:	08 f0       	brcs	.+2      	; 0x1636 <ADC_periphery+0x298>
            TL += 7;        // jump to the character in the ASCII-table
    1634:	09 5f       	subi	r16, 0xF9	; 249
                
        TH = (Temp >> 4) + '0';
    1636:	89 2f       	mov	r24, r25
    1638:	82 95       	swap	r24
    163a:	8f 70       	andi	r24, 0x0F	; 15
    163c:	18 2f       	mov	r17, r24
    163e:	10 5d       	subi	r17, 0xD0	; 208
        if(TH > '9')        // if the hex-value is over 9, add 7 in order to go 
    1640:	1a 33       	cpi	r17, 0x3A	; 58
    1642:	08 f0       	brcs	.+2      	; 0x1646 <ADC_periphery+0x2a8>
            TH += 7;        // jump to the character in the ASCII-table
    1644:	19 5f       	subi	r17, 0xF9	; 249
            
        LCD_putc(0, 'A');
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	61 e4       	ldi	r22, 0x41	; 65
    164a:	e1 d5       	rcall	.+3010   	; 0x220e <LCD_putc>
        LCD_putc(1, 'D');
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	64 e4       	ldi	r22, 0x44	; 68
    1650:	de d5       	rcall	.+3004   	; 0x220e <LCD_putc>
        LCD_putc(2, 'C');
    1652:	82 e0       	ldi	r24, 0x02	; 2
    1654:	63 e4       	ldi	r22, 0x43	; 67
    1656:	db d5       	rcall	.+2998   	; 0x220e <LCD_putc>
        LCD_putc(3, (ADCH + 0x30));
    1658:	60 91 79 00 	lds	r22, 0x0079
    165c:	60 5d       	subi	r22, 0xD0	; 208
    165e:	83 e0       	ldi	r24, 0x03	; 3
    1660:	d6 d5       	rcall	.+2988   	; 0x220e <LCD_putc>
        LCD_putc(4, TH);
    1662:	84 e0       	ldi	r24, 0x04	; 4
    1664:	61 2f       	mov	r22, r17
    1666:	d3 d5       	rcall	.+2982   	; 0x220e <LCD_putc>
        LCD_putc(5, TL);
    1668:	85 e0       	ldi	r24, 0x05	; 5
    166a:	60 2f       	mov	r22, r16
    166c:	d0 d5       	rcall	.+2976   	; 0x220e <LCD_putc>
        LCD_putc(6, '\0');
    166e:	86 e0       	ldi	r24, 0x06	; 6
    1670:	60 e0       	ldi	r22, 0x00	; 0
    1672:	cd d5       	rcall	.+2970   	; 0x220e <LCD_putc>

//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);        

    }
}
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	1f 91       	pop	r17
    167a:	0f 91       	pop	r16
    167c:	ff 90       	pop	r15
    167e:	ef 90       	pop	r14
    1680:	df 90       	pop	r13
    1682:	cf 90       	pop	r12
    1684:	bf 90       	pop	r11
    1686:	af 90       	pop	r10
    1688:	9f 90       	pop	r9
    168a:	08 95       	ret

0000168c <__vector_5>:
// #pragma vector = TIMER2_OVF_vect
// __interrupt void TIMER2_OVF_interrupt(void)
// SIGNAL(SIG_OVERFLOW2)
ISR(TIMER2_OVF_vect)
// mtE
{
    168c:	1f 92       	push	r1
    168e:	0f 92       	push	r0
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	0f 92       	push	r0
    1694:	11 24       	eor	r1, r1
    1696:	2f 93       	push	r18
    1698:	3f 93       	push	r19
    169a:	4f 93       	push	r20
    169c:	5f 93       	push	r21
    169e:	6f 93       	push	r22
    16a0:	7f 93       	push	r23
    16a2:	8f 93       	push	r24
    16a4:	9f 93       	push	r25
    16a6:	af 93       	push	r26
    16a8:	bf 93       	push	r27
    16aa:	ef 93       	push	r30
    16ac:	ff 93       	push	r31
    static char LeapMonth;

    gSECOND++;               // increment second
    16ae:	80 91 72 01 	lds	r24, 0x0172
    16b2:	8f 5f       	subi	r24, 0xFF	; 255
    16b4:	80 93 72 01 	sts	0x0172, r24

    if (gSECOND == 60)
    16b8:	80 91 72 01 	lds	r24, 0x0172
    16bc:	8c 33       	cpi	r24, 0x3C	; 60
    16be:	09 f0       	breq	.+2      	; 0x16c2 <__vector_5+0x36>
    16c0:	72 c0       	rjmp	.+228    	; 0x17a6 <__vector_5+0x11a>
    {
        gSECOND = 0;
    16c2:	10 92 72 01 	sts	0x0172, r1
        gMINUTE++;
    16c6:	80 91 77 01 	lds	r24, 0x0177
    16ca:	8f 5f       	subi	r24, 0xFF	; 255
    16cc:	80 93 77 01 	sts	0x0177, r24
        
        gPowerSaveTimer++;
    16d0:	80 91 48 01 	lds	r24, 0x0148
    16d4:	8f 5f       	subi	r24, 0xFF	; 255
    16d6:	80 93 48 01 	sts	0x0148, r24
        
        if (gMINUTE > 59)
    16da:	80 91 77 01 	lds	r24, 0x0177
    16de:	8c 33       	cpi	r24, 0x3C	; 60
    16e0:	08 f4       	brcc	.+2      	; 0x16e4 <__vector_5+0x58>
    16e2:	61 c0       	rjmp	.+194    	; 0x17a6 <__vector_5+0x11a>
        {
            gMINUTE = 0;
    16e4:	10 92 77 01 	sts	0x0177, r1
            gHOUR++;
    16e8:	80 91 71 01 	lds	r24, 0x0171
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	80 93 71 01 	sts	0x0171, r24
            
            if (gHOUR > 23)
    16f2:	80 91 71 01 	lds	r24, 0x0171
    16f6:	88 31       	cpi	r24, 0x18	; 24
    16f8:	08 f4       	brcc	.+2      	; 0x16fc <__vector_5+0x70>
    16fa:	55 c0       	rjmp	.+170    	; 0x17a6 <__vector_5+0x11a>
            {
                
                gHOUR = 0;
    16fc:	10 92 71 01 	sts	0x0171, r1
                gDAY++;
    1700:	80 91 73 01 	lds	r24, 0x0173
    1704:	8f 5f       	subi	r24, 0xFF	; 255
    1706:	80 93 73 01 	sts	0x0173, r24

                // Check for leap year if month == February
                if (gMONTH == 2)
    170a:	80 91 76 01 	lds	r24, 0x0176
    170e:	82 30       	cpi	r24, 0x02	; 2
    1710:	01 f5       	brne	.+64     	; 0x1752 <__vector_5+0xc6>
                    if (!(gYEAR & 0x0003))              // if (gYEAR%4 == 0)
    1712:	80 91 74 01 	lds	r24, 0x0174
    1716:	90 91 75 01 	lds	r25, 0x0175
    171a:	83 70       	andi	r24, 0x03	; 3
    171c:	90 70       	andi	r25, 0x00	; 0
    171e:	89 2b       	or	r24, r25
    1720:	c1 f4       	brne	.+48     	; 0x1752 <__vector_5+0xc6>
                        if (gYEAR%100 == 0)
    1722:	80 91 74 01 	lds	r24, 0x0174
    1726:	90 91 75 01 	lds	r25, 0x0175
    172a:	64 e6       	ldi	r22, 0x64	; 100
    172c:	70 e0       	ldi	r23, 0x00	; 0
    172e:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__udivmodhi4>
    1732:	89 2b       	or	r24, r25
    1734:	51 f4       	brne	.+20     	; 0x174a <__vector_5+0xbe>
                            if (gYEAR%400 == 0)
    1736:	80 91 74 01 	lds	r24, 0x0174
    173a:	90 91 75 01 	lds	r25, 0x0175
    173e:	60 e9       	ldi	r22, 0x90	; 144
    1740:	71 e0       	ldi	r23, 0x01	; 1
    1742:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__udivmodhi4>
    1746:	89 2b       	or	r24, r25
    1748:	21 f4       	brne	.+8      	; 0x1752 <__vector_5+0xc6>
                                LeapMonth = 1;
                            else
                                LeapMonth = 0;
                        else
                            LeapMonth = 1;
    174a:	81 e0       	ldi	r24, 0x01	; 1
    174c:	80 93 4a 01 	sts	0x014A, r24
    1750:	02 c0       	rjmp	.+4      	; 0x1756 <__vector_5+0xca>
                    else
                        LeapMonth = 0;
                else
                    LeapMonth = 0;
    1752:	10 92 4a 01 	sts	0x014A, r1

                // Now, we can check for month length
                if (gDAY > (MonthLength[gMONTH] + LeapMonth))
    1756:	20 91 73 01 	lds	r18, 0x0173
    175a:	e0 91 76 01 	lds	r30, 0x0176
    175e:	30 e0       	ldi	r19, 0x00	; 0
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	e2 5f       	subi	r30, 0xF2	; 242
    1764:	fe 4f       	sbci	r31, 0xFE	; 254
    1766:	40 81       	ld	r20, Z
    1768:	80 91 4a 01 	lds	r24, 0x014A
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	84 0f       	add	r24, r20
    1770:	91 1d       	adc	r25, r1
    1772:	82 17       	cp	r24, r18
    1774:	93 07       	cpc	r25, r19
    1776:	bc f4       	brge	.+46     	; 0x17a6 <__vector_5+0x11a>
                {
                    gDAY = 1;
    1778:	91 e0       	ldi	r25, 0x01	; 1
    177a:	90 93 73 01 	sts	0x0173, r25
                    gMONTH++;
    177e:	80 91 76 01 	lds	r24, 0x0176
    1782:	8f 5f       	subi	r24, 0xFF	; 255
    1784:	80 93 76 01 	sts	0x0176, r24

                    if (gMONTH > 12)
    1788:	80 91 76 01 	lds	r24, 0x0176
    178c:	8d 30       	cpi	r24, 0x0D	; 13
    178e:	58 f0       	brcs	.+22     	; 0x17a6 <__vector_5+0x11a>
                    {
                        gMONTH = 1;
    1790:	90 93 76 01 	sts	0x0176, r25
                        gYEAR++;
    1794:	80 91 74 01 	lds	r24, 0x0174
    1798:	90 91 75 01 	lds	r25, 0x0175
    179c:	01 96       	adiw	r24, 0x01	; 1
    179e:	90 93 75 01 	sts	0x0175, r25
    17a2:	80 93 74 01 	sts	0x0174, r24
                    }
                }
            }
        }
    }
}
    17a6:	ff 91       	pop	r31
    17a8:	ef 91       	pop	r30
    17aa:	bf 91       	pop	r27
    17ac:	af 91       	pop	r26
    17ae:	9f 91       	pop	r25
    17b0:	8f 91       	pop	r24
    17b2:	7f 91       	pop	r23
    17b4:	6f 91       	pop	r22
    17b6:	5f 91       	pop	r21
    17b8:	4f 91       	pop	r20
    17ba:	3f 91       	pop	r19
    17bc:	2f 91       	pop	r18
    17be:	0f 90       	pop	r0
    17c0:	0f be       	out	0x3f, r0	; 63
    17c2:	0f 90       	pop	r0
    17c4:	1f 90       	pop	r1
    17c6:	18 95       	reti

000017c8 <SetDateFormat>:
*
*   Purpose :       Adjusts the Dateformat
*
*****************************************************************************/
char SetDateFormat(char input)
{
    17c8:	1f 93       	push	r17
    17ca:	18 2f       	mov	r17, r24
    static char enter = 1;

    if(enter)
    17cc:	80 91 3a 01 	lds	r24, 0x013A
    17d0:	88 23       	and	r24, r24
    17d2:	69 f0       	breq	.+26     	; 0x17ee <SetDateFormat+0x26>
    {
        enter = 0;
    17d4:	10 92 3a 01 	sts	0x013A, r1

        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);
    17d8:	e0 91 49 01 	lds	r30, 0x0149
    17dc:	f0 e0       	ldi	r31, 0x00	; 0
    17de:	ee 0f       	add	r30, r30
    17e0:	ff 1f       	adc	r31, r31
    17e2:	ec 5c       	subi	r30, 0xCC	; 204
    17e4:	fe 4f       	sbci	r31, 0xFE	; 254
    17e6:	80 81       	ld	r24, Z
    17e8:	91 81       	ldd	r25, Z+1	; 0x01
    17ea:	61 e0       	ldi	r22, 0x01	; 1
    17ec:	e0 d4       	rcall	.+2496   	; 0x21ae <LCD_puts_f>
    }
    if (input == KEY_PLUS)
    17ee:	14 30       	cpi	r17, 0x04	; 4
    17f0:	49 f4       	brne	.+18     	; 0x1804 <SetDateFormat+0x3c>
    {
        if(dateformat >= 2)
    17f2:	80 91 49 01 	lds	r24, 0x0149
    17f6:	82 30       	cpi	r24, 0x02	; 2
    17f8:	18 f0       	brcs	.+6      	; 0x1800 <SetDateFormat+0x38>
            dateformat = 0;
    17fa:	10 92 49 01 	sts	0x0149, r1
    17fe:	0d c0       	rjmp	.+26     	; 0x181a <SetDateFormat+0x52>
        else
            dateformat++;
    1800:	8f 5f       	subi	r24, 0xFF	; 255
    1802:	09 c0       	rjmp	.+18     	; 0x1816 <SetDateFormat+0x4e>

        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);        
    }
    else if (input == KEY_MINUS)
    1804:	15 30       	cpi	r17, 0x05	; 5
    1806:	a9 f4       	brne	.+42     	; 0x1832 <SetDateFormat+0x6a>
    {
        if(dateformat == 0)
    1808:	80 91 49 01 	lds	r24, 0x0149
    180c:	88 23       	and	r24, r24
    180e:	11 f4       	brne	.+4      	; 0x1814 <SetDateFormat+0x4c>
            dateformat = 2;
    1810:	82 e0       	ldi	r24, 0x02	; 2
    1812:	01 c0       	rjmp	.+2      	; 0x1816 <SetDateFormat+0x4e>
        else
            dateformat--;
    1814:	81 50       	subi	r24, 0x01	; 1
    1816:	80 93 49 01 	sts	0x0149, r24
            
        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);            
    181a:	e0 91 49 01 	lds	r30, 0x0149
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	ee 0f       	add	r30, r30
    1822:	ff 1f       	adc	r31, r31
    1824:	ec 5c       	subi	r30, 0xCC	; 204
    1826:	fe 4f       	sbci	r31, 0xFE	; 254
    1828:	80 81       	ld	r24, Z
    182a:	91 81       	ldd	r25, Z+1	; 0x01
    182c:	61 e0       	ldi	r22, 0x01	; 1
    182e:	bf d4       	rcall	.+2430   	; 0x21ae <LCD_puts_f>
    1830:	02 c0       	rjmp	.+4      	; 0x1836 <SetDateFormat+0x6e>
    }
    else if (input == KEY_ENTER)    
    1832:	11 30       	cpi	r17, 0x01	; 1
    1834:	11 f0       	breq	.+4      	; 0x183a <SetDateFormat+0x72>
    1836:	80 e2       	ldi	r24, 0x20	; 32
    1838:	03 c0       	rjmp	.+6      	; 0x1840 <SetDateFormat+0x78>
    {
        enter = 1;
    183a:	10 93 3a 01 	sts	0x013A, r17
    183e:	8c e1       	ldi	r24, 0x1C	; 28
        return ST_TIME_DATE_FUNC;
    }        
    return ST_TIME_DATEFORMAT_ADJUST_FUNC;
}
    1840:	1f 91       	pop	r17
    1842:	08 95       	ret

00001844 <SetClockFormat>:
*
*   Purpose :       Adjusts the Clockformat
*
*****************************************************************************/
char SetClockFormat(char input)
{
    1844:	1f 93       	push	r17
    1846:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if(enter)
    1848:	80 91 3d 01 	lds	r24, 0x013D
    184c:	88 23       	and	r24, r24
    184e:	69 f0       	breq	.+26     	; 0x186a <SetClockFormat+0x26>
    {
        enter = 0;
    1850:	10 92 3d 01 	sts	0x013D, r1
        
        if(clockformat == CLOCK_24)
    1854:	80 91 33 01 	lds	r24, 0x0133
    1858:	81 30       	cpi	r24, 0x01	; 1
    185a:	19 f4       	brne	.+6      	; 0x1862 <SetClockFormat+0x1e>
            LCD_puts_f(PSTR("24H"), 1);	 // mt LCD_puts("24H", 1);            
    185c:	82 e4       	ldi	r24, 0x42	; 66
    185e:	95 e0       	ldi	r25, 0x05	; 5
    1860:	02 c0       	rjmp	.+4      	; 0x1866 <SetClockFormat+0x22>
        else
            LCD_puts_f(PSTR("12H"), 1);	// mt LCD_puts("12H", 1);		
    1862:	8e e3       	ldi	r24, 0x3E	; 62
    1864:	95 e0       	ldi	r25, 0x05	; 5
    1866:	61 e0       	ldi	r22, 0x01	; 1
    1868:	a2 d4       	rcall	.+2372   	; 0x21ae <LCD_puts_f>

    }
    if (input == KEY_PLUS)
    186a:	14 30       	cpi	r17, 0x04	; 4
    186c:	79 f4       	brne	.+30     	; 0x188c <SetClockFormat+0x48>
    {
        if(clockformat == CLOCK_24)
    186e:	80 91 33 01 	lds	r24, 0x0133
    1872:	81 30       	cpi	r24, 0x01	; 1
    1874:	29 f4       	brne	.+10     	; 0x1880 <SetClockFormat+0x3c>
        {
            clockformat = CLOCK_12;
    1876:	10 92 33 01 	sts	0x0133, r1
            LCD_puts_f(PSTR("12H"), 1); // mt LCD_puts("12H", 1);
    187a:	8a e3       	ldi	r24, 0x3A	; 58
    187c:	95 e0       	ldi	r25, 0x05	; 5
    187e:	16 c0       	rjmp	.+44     	; 0x18ac <SetClockFormat+0x68>
        }
        else
        {
            clockformat = CLOCK_24;
    1880:	81 e0       	ldi	r24, 0x01	; 1
    1882:	80 93 33 01 	sts	0x0133, r24
            LCD_puts_f(PSTR("24H"), 1); // mt LCD_puts("24H", 1);            
    1886:	86 e3       	ldi	r24, 0x36	; 54
    1888:	95 e0       	ldi	r25, 0x05	; 5
    188a:	10 c0       	rjmp	.+32     	; 0x18ac <SetClockFormat+0x68>
        }
    }
    else if (input == KEY_MINUS)
    188c:	15 30       	cpi	r17, 0x05	; 5
    188e:	91 f4       	brne	.+36     	; 0x18b4 <SetClockFormat+0x70>
    {
        if(clockformat == CLOCK_12)
    1890:	80 91 33 01 	lds	r24, 0x0133
    1894:	88 23       	and	r24, r24
    1896:	31 f4       	brne	.+12     	; 0x18a4 <SetClockFormat+0x60>
        {
            clockformat = CLOCK_24;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	80 93 33 01 	sts	0x0133, r24
            LCD_puts_f(PSTR("24H"), 1);	// mt LCD_puts("24H", 1);
    189e:	82 e3       	ldi	r24, 0x32	; 50
    18a0:	95 e0       	ldi	r25, 0x05	; 5
    18a2:	04 c0       	rjmp	.+8      	; 0x18ac <SetClockFormat+0x68>
        }
        else
        {
            clockformat = CLOCK_12;
    18a4:	10 92 33 01 	sts	0x0133, r1
            LCD_puts_f(PSTR("12H"), 1);   // mt LCD_puts("12H", 1);            
    18a8:	8e e2       	ldi	r24, 0x2E	; 46
    18aa:	95 e0       	ldi	r25, 0x05	; 5
    18ac:	61 e0       	ldi	r22, 0x01	; 1
    18ae:	7f d4       	rcall	.+2302   	; 0x21ae <LCD_puts_f>
    18b0:	84 e2       	ldi	r24, 0x24	; 36
    18b2:	05 c0       	rjmp	.+10     	; 0x18be <SetClockFormat+0x7a>
        }
    }
    else if (input == KEY_ENTER)    
    18b4:	11 30       	cpi	r17, 0x01	; 1
    18b6:	e1 f7       	brne	.-8      	; 0x18b0 <SetClockFormat+0x6c>
    {
        enter = 1;
    18b8:	10 93 3d 01 	sts	0x013D, r17
    18bc:	86 e1       	ldi	r24, 0x16	; 22
        return ST_TIME_CLOCK_FUNC;
    }        
    return ST_TIME_CLOCKFORMAT_ADJUST_FUNC;
}
    18be:	1f 91       	pop	r17
    18c0:	08 95       	ret

000018c2 <SetDate>:
*
*   Purpose :       Adjusts the date
*
*****************************************************************************/
char SetDate(char input)
{
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
    18c6:	1f 93       	push	r17
    18c8:	f8 2e       	mov	r15, r24
	uint8_t YH, YL, MH, ML, DH, DL;
	uint8_t MonthLength_temp;
	uint8_t LeapMonth;
	// mtE

    if (enter_function)
    18ca:	80 91 3c 01 	lds	r24, 0x013C
    18ce:	88 23       	and	r24, r24
    18d0:	71 f0       	breq	.+28     	; 0x18ee <SetDate+0x2c>
    {
        date[YEAR] = gYEAR;
    18d2:	80 91 74 01 	lds	r24, 0x0174
    18d6:	90 91 75 01 	lds	r25, 0x0175
    18da:	80 93 4b 01 	sts	0x014B, r24
        date[MONTH] = gMONTH;
    18de:	80 91 76 01 	lds	r24, 0x0176
    18e2:	80 93 4c 01 	sts	0x014C, r24
        date[DAY] = gDAY;
    18e6:	80 91 73 01 	lds	r24, 0x0173
    18ea:	80 93 4d 01 	sts	0x014D, r24
    }

    if (mode == YEAR)
    18ee:	80 91 3b 01 	lds	r24, 0x013B
    18f2:	88 23       	and	r24, r24
    18f4:	99 f4       	brne	.+38     	; 0x191c <SetDate+0x5a>
    {
        YH = CHAR2BCD2(date[YEAR]);
    18f6:	80 91 4b 01 	lds	r24, 0x014B
    18fa:	6e dc       	rcall	.-1828   	; 0x11d8 <CHAR2BCD2>
    18fc:	18 2f       	mov	r17, r24
        YL = (YH & 0x0F) + '0';
        YH = (YH >> 4) + '0';
    18fe:	08 2f       	mov	r16, r24
    1900:	02 95       	swap	r16
    1902:	0f 70       	andi	r16, 0x0F	; 15
        
        LCD_putc( 0, ' ');
    1904:	80 e0       	ldi	r24, 0x00	; 0
    1906:	60 e2       	ldi	r22, 0x20	; 32
    1908:	82 d4       	rcall	.+2308   	; 0x220e <LCD_putc>
        LCD_putc( 1, ' ');   
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	60 e2       	ldi	r22, 0x20	; 32
    190e:	7f d4       	rcall	.+2302   	; 0x220e <LCD_putc>
        LCD_putc( 2, 'Y');
    1910:	82 e0       	ldi	r24, 0x02	; 2
    1912:	69 e5       	ldi	r22, 0x59	; 89
    1914:	7c d4       	rcall	.+2296   	; 0x220e <LCD_putc>
        LCD_putc( 3, 'Y');        
    1916:	83 e0       	ldi	r24, 0x03	; 3
    1918:	69 e5       	ldi	r22, 0x59	; 89
    191a:	29 c0       	rjmp	.+82     	; 0x196e <SetDate+0xac>
        LCD_putc( 4, YH);
        LCD_putc( 5, YL);
    }
    else if (mode == MONTH)
    191c:	81 30       	cpi	r24, 0x01	; 1
    191e:	99 f4       	brne	.+38     	; 0x1946 <SetDate+0x84>
    {
        MH = CHAR2BCD2(date[MONTH]);
    1920:	80 91 4c 01 	lds	r24, 0x014C
    1924:	59 dc       	rcall	.-1870   	; 0x11d8 <CHAR2BCD2>
    1926:	18 2f       	mov	r17, r24
        ML = (MH & 0x0F) + '0';
        MH = (MH >> 4) + '0';
    1928:	08 2f       	mov	r16, r24
    192a:	02 95       	swap	r16
    192c:	0f 70       	andi	r16, 0x0F	; 15

        LCD_putc( 0, ' ');
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	60 e2       	ldi	r22, 0x20	; 32
    1932:	6d d4       	rcall	.+2266   	; 0x220e <LCD_putc>
        LCD_putc( 1, ' ');   
    1934:	81 e0       	ldi	r24, 0x01	; 1
    1936:	60 e2       	ldi	r22, 0x20	; 32
    1938:	6a d4       	rcall	.+2260   	; 0x220e <LCD_putc>
        LCD_putc( 2, 'M');
    193a:	82 e0       	ldi	r24, 0x02	; 2
    193c:	6d e4       	ldi	r22, 0x4D	; 77
    193e:	67 d4       	rcall	.+2254   	; 0x220e <LCD_putc>
        LCD_putc( 3, 'M');        
    1940:	83 e0       	ldi	r24, 0x03	; 3
    1942:	6d e4       	ldi	r22, 0x4D	; 77
    1944:	14 c0       	rjmp	.+40     	; 0x196e <SetDate+0xac>
        LCD_putc( 4, MH);
        LCD_putc( 5, ML);
    }
    else if (mode == DAY)
    1946:	82 30       	cpi	r24, 0x02	; 2
    1948:	e1 f4       	brne	.+56     	; 0x1982 <SetDate+0xc0>
    {
        DH = CHAR2BCD2(date[DAY]);
    194a:	80 91 4d 01 	lds	r24, 0x014D
    194e:	44 dc       	rcall	.-1912   	; 0x11d8 <CHAR2BCD2>
    1950:	18 2f       	mov	r17, r24
        DL = (DH & 0x0F) + '0';
        DH = (DH >> 4) + '0';
    1952:	08 2f       	mov	r16, r24
    1954:	02 95       	swap	r16
    1956:	0f 70       	andi	r16, 0x0F	; 15

        LCD_putc( 0, ' ');
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	60 e2       	ldi	r22, 0x20	; 32
    195c:	58 d4       	rcall	.+2224   	; 0x220e <LCD_putc>
        LCD_putc( 1, ' ');   
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	60 e2       	ldi	r22, 0x20	; 32
    1962:	55 d4       	rcall	.+2218   	; 0x220e <LCD_putc>
        LCD_putc( 2, 'D');
    1964:	82 e0       	ldi	r24, 0x02	; 2
    1966:	64 e4       	ldi	r22, 0x44	; 68
    1968:	52 d4       	rcall	.+2212   	; 0x220e <LCD_putc>
        LCD_putc( 3, 'D');        
    196a:	83 e0       	ldi	r24, 0x03	; 3
    196c:	64 e4       	ldi	r22, 0x44	; 68
    196e:	4f d4       	rcall	.+2206   	; 0x220e <LCD_putc>
        LCD_putc( 4, DH);
    1970:	00 5d       	subi	r16, 0xD0	; 208
    1972:	84 e0       	ldi	r24, 0x04	; 4
    1974:	60 2f       	mov	r22, r16
    1976:	4b d4       	rcall	.+2198   	; 0x220e <LCD_putc>
        LCD_putc( 5, DL);
    1978:	1f 70       	andi	r17, 0x0F	; 15
    197a:	10 5d       	subi	r17, 0xD0	; 208
    197c:	85 e0       	ldi	r24, 0x05	; 5
    197e:	61 2f       	mov	r22, r17
    1980:	46 d4       	rcall	.+2188   	; 0x220e <LCD_putc>
    }

    LCD_putc(6, '\0');
    1982:	86 e0       	ldi	r24, 0x06	; 6
    1984:	60 e0       	ldi	r22, 0x00	; 0
    1986:	43 d4       	rcall	.+2182   	; 0x220e <LCD_putc>

    LCD_Colon(0);
    1988:	80 e0       	ldi	r24, 0x00	; 0
    198a:	57 d4       	rcall	.+2222   	; 0x223a <LCD_Colon>

    if (input != KEY_NULL)
    198c:	ff 20       	and	r15, r15
    198e:	09 f0       	breq	.+2      	; 0x1992 <SetDate+0xd0>
        LCD_FlashReset();
    1990:	63 d4       	rcall	.+2246   	; 0x2258 <LCD_FlashReset>

    LCD_UpdateRequired(TRUE, 0);
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	60 e0       	ldi	r22, 0x00	; 0
    1996:	54 d4       	rcall	.+2216   	; 0x2240 <LCD_UpdateRequired>


    enter_function = 1;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	80 93 3c 01 	sts	0x013C, r24

    // Increment/decrement years, months or days
    if (input == KEY_PLUS)
    199e:	84 e0       	ldi	r24, 0x04	; 4
    19a0:	f8 16       	cp	r15, r24
    19a2:	41 f4       	brne	.+16     	; 0x19b4 <SetDate+0xf2>
        date[mode]++;
    19a4:	e0 91 3b 01 	lds	r30, 0x013B
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	e5 5b       	subi	r30, 0xB5	; 181
    19ac:	fe 4f       	sbci	r31, 0xFE	; 254
    19ae:	80 81       	ld	r24, Z
    19b0:	8f 5f       	subi	r24, 0xFF	; 255
    19b2:	0a c0       	rjmp	.+20     	; 0x19c8 <SetDate+0x106>
    else if (input == KEY_MINUS)
    19b4:	85 e0       	ldi	r24, 0x05	; 5
    19b6:	f8 16       	cp	r15, r24
    19b8:	49 f4       	brne	.+18     	; 0x19cc <SetDate+0x10a>
        date[mode]--;
    19ba:	e0 91 3b 01 	lds	r30, 0x013B
    19be:	f0 e0       	ldi	r31, 0x00	; 0
    19c0:	e5 5b       	subi	r30, 0xB5	; 181
    19c2:	fe 4f       	sbci	r31, 0xFE	; 254
    19c4:	80 81       	ld	r24, Z
    19c6:	81 50       	subi	r24, 0x01	; 1
    19c8:	80 83       	st	Z, r24
    19ca:	31 c0       	rjmp	.+98     	; 0x1a2e <SetDate+0x16c>
    else if (input == KEY_PREV)
    19cc:	83 e0       	ldi	r24, 0x03	; 3
    19ce:	f8 16       	cp	r15, r24
    19d0:	41 f4       	brne	.+16     	; 0x19e2 <SetDate+0x120>
    {
        if (mode == YEAR)
    19d2:	80 91 3b 01 	lds	r24, 0x013B
    19d6:	88 23       	and	r24, r24
    19d8:	11 f4       	brne	.+4      	; 0x19de <SetDate+0x11c>
            mode = DAY;
    19da:	82 e0       	ldi	r24, 0x02	; 2
    19dc:	0d c0       	rjmp	.+26     	; 0x19f8 <SetDate+0x136>
        else
            mode--;
    19de:	81 50       	subi	r24, 0x01	; 1
    19e0:	0b c0       	rjmp	.+22     	; 0x19f8 <SetDate+0x136>
    }
    else if (input == KEY_NEXT)
    19e2:	82 e0       	ldi	r24, 0x02	; 2
    19e4:	f8 16       	cp	r15, r24
    19e6:	59 f4       	brne	.+22     	; 0x19fe <SetDate+0x13c>
    {
        if (mode == DAY)
    19e8:	80 91 3b 01 	lds	r24, 0x013B
    19ec:	82 30       	cpi	r24, 0x02	; 2
    19ee:	19 f4       	brne	.+6      	; 0x19f6 <SetDate+0x134>
            mode = YEAR;
    19f0:	10 92 3b 01 	sts	0x013B, r1
    19f4:	1c c0       	rjmp	.+56     	; 0x1a2e <SetDate+0x16c>
        else
            mode++;
    19f6:	8f 5f       	subi	r24, 0xFF	; 255
    19f8:	80 93 3b 01 	sts	0x013B, r24
    19fc:	18 c0       	rjmp	.+48     	; 0x1a2e <SetDate+0x16c>
    }
    else if (input == KEY_ENTER)
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	f8 16       	cp	r15, r24
    1a02:	a9 f4       	brne	.+42     	; 0x1a2e <SetDate+0x16c>
    {
        // store the temporary adjusted values to the global variables
        cli(); // mt __disable_interrupt();
    1a04:	f8 94       	cli
        gYEAR = date[YEAR];
    1a06:	80 91 4b 01 	lds	r24, 0x014B
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	90 93 75 01 	sts	0x0175, r25
    1a10:	80 93 74 01 	sts	0x0174, r24
        gMONTH = date[MONTH];
    1a14:	80 91 4c 01 	lds	r24, 0x014C
    1a18:	80 93 76 01 	sts	0x0176, r24
        gDAY = date[DAY];
    1a1c:	80 91 4d 01 	lds	r24, 0x014D
    1a20:	80 93 73 01 	sts	0x0173, r24
        sei(); // mt __enable_interrupt();
    1a24:	78 94       	sei
        mode = YEAR;
    1a26:	10 92 3b 01 	sts	0x013B, r1
    1a2a:	8c e1       	ldi	r24, 0x1C	; 28
    1a2c:	53 c0       	rjmp	.+166    	; 0x1ad4 <SetDate+0x212>
        return ST_TIME_DATE_FUNC;
    }

    /* OPTIMIZE: Can be solved by using a modulo operation */
    if (date[YEAR] == 255)
    1a2e:	80 91 4b 01 	lds	r24, 0x014B
    1a32:	8f 3f       	cpi	r24, 0xFF	; 255
    1a34:	19 f4       	brne	.+6      	; 0x1a3c <SetDate+0x17a>
        date[YEAR] = 99;
    1a36:	83 e6       	ldi	r24, 0x63	; 99
    1a38:	80 93 4b 01 	sts	0x014B, r24
    if (date[YEAR] > 99)
    1a3c:	80 91 4b 01 	lds	r24, 0x014B
    1a40:	84 36       	cpi	r24, 0x64	; 100
    1a42:	10 f0       	brcs	.+4      	; 0x1a48 <SetDate+0x186>
        date[YEAR] = 0;
    1a44:	10 92 4b 01 	sts	0x014B, r1

    if (date[MONTH] == 0)
    1a48:	80 91 4c 01 	lds	r24, 0x014C
    1a4c:	88 23       	and	r24, r24
    1a4e:	19 f4       	brne	.+6      	; 0x1a56 <SetDate+0x194>
        date[MONTH] = 12;
    1a50:	8c e0       	ldi	r24, 0x0C	; 12
    1a52:	80 93 4c 01 	sts	0x014C, r24
    if (date[MONTH] > 12)
    1a56:	80 91 4c 01 	lds	r24, 0x014C
    1a5a:	8d 30       	cpi	r24, 0x0D	; 13
    1a5c:	18 f0       	brcs	.+6      	; 0x1a64 <SetDate+0x1a2>
        date[MONTH] = 1;
    1a5e:	81 e0       	ldi	r24, 0x01	; 1
    1a60:	80 93 4c 01 	sts	0x014C, r24

    // Check for leap year, if month == February
    if (gMONTH == 2)
    1a64:	80 91 76 01 	lds	r24, 0x0176
    1a68:	82 30       	cpi	r24, 0x02	; 2
    1a6a:	e1 f4       	brne	.+56     	; 0x1aa4 <SetDate+0x1e2>
        if (!(gYEAR & 0x0003))              // if (gYEAR%4 == 0)
    1a6c:	80 91 74 01 	lds	r24, 0x0174
    1a70:	90 91 75 01 	lds	r25, 0x0175
    1a74:	83 70       	andi	r24, 0x03	; 3
    1a76:	90 70       	andi	r25, 0x00	; 0
    1a78:	89 2b       	or	r24, r25
    1a7a:	a1 f4       	brne	.+40     	; 0x1aa4 <SetDate+0x1e2>
            if (gYEAR%100 == 0)
    1a7c:	80 91 74 01 	lds	r24, 0x0174
    1a80:	90 91 75 01 	lds	r25, 0x0175
    1a84:	64 e6       	ldi	r22, 0x64	; 100
    1a86:	70 e0       	ldi	r23, 0x00	; 0
    1a88:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__udivmodhi4>
    1a8c:	89 2b       	or	r24, r25
    1a8e:	89 f4       	brne	.+34     	; 0x1ab2 <SetDate+0x1f0>
                if (gYEAR%400 == 0)
    1a90:	80 91 74 01 	lds	r24, 0x0174
    1a94:	90 91 75 01 	lds	r25, 0x0175
    1a98:	60 e9       	ldi	r22, 0x90	; 144
    1a9a:	71 e0       	ldi	r23, 0x01	; 1
    1a9c:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__udivmodhi4>
    1aa0:	89 2b       	or	r24, r25
    1aa2:	39 f0       	breq	.+14     	; 0x1ab2 <SetDate+0x1f0>
        LeapMonth = 0;

    if (LeapMonth)
        MonthLength_temp = 29;
    else
        MonthLength_temp = MonthLength[date[MONTH]];
    1aa4:	e0 91 4c 01 	lds	r30, 0x014C
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	e2 5f       	subi	r30, 0xF2	; 242
    1aac:	fe 4f       	sbci	r31, 0xFE	; 254
    1aae:	e0 81       	ld	r30, Z
    1ab0:	01 c0       	rjmp	.+2      	; 0x1ab4 <SetDate+0x1f2>
    1ab2:	ed e1       	ldi	r30, 0x1D	; 29
    
    if (date[DAY] == 0)
    1ab4:	80 91 4d 01 	lds	r24, 0x014D
    1ab8:	88 23       	and	r24, r24
    1aba:	11 f4       	brne	.+4      	; 0x1ac0 <SetDate+0x1fe>
        date[DAY] = MonthLength_temp;
    1abc:	e0 93 4d 01 	sts	0x014D, r30
    if (date[DAY] > MonthLength_temp)
    1ac0:	80 91 4d 01 	lds	r24, 0x014D
    1ac4:	e8 17       	cp	r30, r24
    1ac6:	18 f4       	brcc	.+6      	; 0x1ace <SetDate+0x20c>
        date[DAY] = 1;
    1ac8:	81 e0       	ldi	r24, 0x01	; 1
    1aca:	80 93 4d 01 	sts	0x014D, r24

    enter_function = 0;
    1ace:	10 92 3c 01 	sts	0x013C, r1
    1ad2:	8e e1       	ldi	r24, 0x1E	; 30
    
    return ST_TIME_DATE_ADJUST_FUNC;
}
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	ff 90       	pop	r15
    1ada:	08 95       	ret

00001adc <ShowDate>:
*
*   Purpose :       Shows the date on the LCD
*
*****************************************************************************/
char ShowDate(char input)
{
    1adc:	9f 92       	push	r9
    1ade:	af 92       	push	r10
    1ae0:	bf 92       	push	r11
    1ae2:	cf 92       	push	r12
    1ae4:	df 92       	push	r13
    1ae6:	ef 92       	push	r14
    1ae8:	ff 92       	push	r15
    1aea:	0f 93       	push	r16
    1aec:	1f 93       	push	r17
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	98 2e       	mov	r9, r24
    char YH, YL, MH, ML, DH, DL;

    YH = CHAR2BCD2(gYEAR);
    1af4:	80 91 74 01 	lds	r24, 0x0174
    1af8:	90 91 75 01 	lds	r25, 0x0175
    1afc:	6d db       	rcall	.-2342   	; 0x11d8 <CHAR2BCD2>
    1afe:	18 2f       	mov	r17, r24
    YL = (YH & 0x0F) + '0';
    YH = (YH >> 4) + '0';
    1b00:	08 2f       	mov	r16, r24
    1b02:	02 95       	swap	r16
    1b04:	0f 70       	andi	r16, 0x0F	; 15

    MH = CHAR2BCD2(gMONTH);
    1b06:	80 91 76 01 	lds	r24, 0x0176
    1b0a:	66 db       	rcall	.-2356   	; 0x11d8 <CHAR2BCD2>
    1b0c:	f8 2e       	mov	r15, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1b0e:	d8 2e       	mov	r13, r24
    1b10:	d2 94       	swap	r13
    1b12:	4f e0       	ldi	r20, 0x0F	; 15
    1b14:	d4 22       	and	r13, r20

    DH = CHAR2BCD2(gDAY);
    1b16:	80 91 73 01 	lds	r24, 0x0173
    1b1a:	5e db       	rcall	.-2372   	; 0x11d8 <CHAR2BCD2>
    1b1c:	e8 2e       	mov	r14, r24
    DL = (DH & 0x0F) + '0';
    DH = (DH >> 4) + '0';
    1b1e:	c8 2e       	mov	r12, r24
    1b20:	c2 94       	swap	r12
    1b22:	3f e0       	ldi	r19, 0x0F	; 15
    1b24:	c3 22       	and	r12, r19
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 2), MH);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 3), ML);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 4), DH);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 5), DL);
	*/
   	uint8_t *pDateFormatNr = (uint8_t*)pgm_read_word(&DATE_FORMAT_NR[dateformat]);
    1b26:	80 91 49 01 	lds	r24, 0x0149
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	88 0f       	add	r24, r24
    1b2e:	99 1f       	adc	r25, r25
    1b30:	88 5d       	subi	r24, 0xD8	; 216
    1b32:	9a 4f       	sbci	r25, 0xFA	; 250
    1b34:	fc 01       	movw	r30, r24
    1b36:	25 91       	lpm	r18, Z+
    1b38:	34 91       	lpm	r19, Z+
    LCD_putc( pgm_read_byte(pDateFormatNr++), YH);
    1b3a:	e9 01       	movw	r28, r18
    1b3c:	21 96       	adiw	r28, 0x01	; 1
    1b3e:	f9 01       	movw	r30, r18
    1b40:	84 91       	lpm	r24, Z+
    1b42:	00 5d       	subi	r16, 0xD0	; 208
    1b44:	60 2f       	mov	r22, r16
    1b46:	63 d3       	rcall	.+1734   	; 0x220e <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), YL);
    1b48:	5e 01       	movw	r10, r28
    1b4a:	08 94       	sec
    1b4c:	a1 1c       	adc	r10, r1
    1b4e:	b1 1c       	adc	r11, r1
    1b50:	fe 01       	movw	r30, r28
    1b52:	84 91       	lpm	r24, Z+
    1b54:	1f 70       	andi	r17, 0x0F	; 15
    1b56:	10 5d       	subi	r17, 0xD0	; 208
    1b58:	61 2f       	mov	r22, r17
    1b5a:	59 d3       	rcall	.+1714   	; 0x220e <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), MH);
    1b5c:	e5 01       	movw	r28, r10
    1b5e:	21 96       	adiw	r28, 0x01	; 1
    1b60:	f5 01       	movw	r30, r10
    1b62:	84 91       	lpm	r24, Z+
    1b64:	f0 e3       	ldi	r31, 0x30	; 48
    1b66:	df 0e       	add	r13, r31
    1b68:	6d 2d       	mov	r22, r13
    1b6a:	51 d3       	rcall	.+1698   	; 0x220e <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), ML);
    1b6c:	8e 01       	movw	r16, r28
    1b6e:	0f 5f       	subi	r16, 0xFF	; 255
    1b70:	1f 4f       	sbci	r17, 0xFF	; 255
    1b72:	fe 01       	movw	r30, r28
    1b74:	84 91       	lpm	r24, Z+
    1b76:	ff e0       	ldi	r31, 0x0F	; 15
    1b78:	ff 22       	and	r15, r31
    1b7a:	90 e3       	ldi	r25, 0x30	; 48
    1b7c:	f9 0e       	add	r15, r25
    1b7e:	6f 2d       	mov	r22, r15
    1b80:	46 d3       	rcall	.+1676   	; 0x220e <LCD_putc>
	LCD_putc( pgm_read_byte(pDateFormatNr++), DH);
    1b82:	f8 01       	movw	r30, r16
    1b84:	84 91       	lpm	r24, Z+
    1b86:	f0 e3       	ldi	r31, 0x30	; 48
    1b88:	cf 0e       	add	r12, r31
    1b8a:	6c 2d       	mov	r22, r12
    1b8c:	40 d3       	rcall	.+1664   	; 0x220e <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr), DL);
    1b8e:	0f 5f       	subi	r16, 0xFF	; 255
    1b90:	1f 4f       	sbci	r17, 0xFF	; 255
    1b92:	f8 01       	movw	r30, r16
    1b94:	84 91       	lpm	r24, Z+
    1b96:	ff e0       	ldi	r31, 0x0F	; 15
    1b98:	ef 22       	and	r14, r31
    1b9a:	90 e3       	ldi	r25, 0x30	; 48
    1b9c:	e9 0e       	add	r14, r25
    1b9e:	6e 2d       	mov	r22, r14
    1ba0:	36 d3       	rcall	.+1644   	; 0x220e <LCD_putc>
    // mtE

    LCD_putc(6, '\0');
    1ba2:	86 e0       	ldi	r24, 0x06	; 6
    1ba4:	60 e0       	ldi	r22, 0x00	; 0
    1ba6:	33 d3       	rcall	.+1638   	; 0x220e <LCD_putc>

    LCD_Colon(1);
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	47 d3       	rcall	.+1678   	; 0x223a <LCD_Colon>

    LCD_UpdateRequired(TRUE, 0);
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	60 e0       	ldi	r22, 0x00	; 0
    1bb0:	47 d3       	rcall	.+1678   	; 0x2240 <LCD_UpdateRequired>


    if (input == KEY_PREV)
    1bb2:	e3 e0       	ldi	r30, 0x03	; 3
    1bb4:	9e 16       	cp	r9, r30
    1bb6:	11 f4       	brne	.+4      	; 0x1bbc <ShowDate+0xe0>
    1bb8:	8b e1       	ldi	r24, 0x1B	; 27
    1bba:	06 c0       	rjmp	.+12     	; 0x1bc8 <ShowDate+0xec>
        return ST_TIME_DATE;
    else if (input == KEY_NEXT)
    1bbc:	f2 e0       	ldi	r31, 0x02	; 2
    1bbe:	9f 16       	cp	r9, r31
    1bc0:	11 f0       	breq	.+4      	; 0x1bc6 <ShowDate+0xea>
    1bc2:	8c e1       	ldi	r24, 0x1C	; 28
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <ShowDate+0xec>
    1bc6:	8d e1       	ldi	r24, 0x1D	; 29
        return ST_TIME_DATE_ADJUST;
    else   
        return ST_TIME_DATE_FUNC;
}
    1bc8:	df 91       	pop	r29
    1bca:	cf 91       	pop	r28
    1bcc:	1f 91       	pop	r17
    1bce:	0f 91       	pop	r16
    1bd0:	ff 90       	pop	r15
    1bd2:	ef 90       	pop	r14
    1bd4:	df 90       	pop	r13
    1bd6:	cf 90       	pop	r12
    1bd8:	bf 90       	pop	r11
    1bda:	af 90       	pop	r10
    1bdc:	9f 90       	pop	r9
    1bde:	08 95       	ret

00001be0 <SetClock>:
*
*   Purpose :       Adjusts the clock
*
*****************************************************************************/
char SetClock(char input)
{
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	e8 2e       	mov	r14, r24
    static uint8_t time[3];
    static uint8_t mode = HOUR;
    uint8_t HH, HL, MH, ML, SH, SL;
    // mtE

    if (enter_function)
    1bea:	80 91 3e 01 	lds	r24, 0x013E
    1bee:	88 23       	and	r24, r24
    1bf0:	61 f0       	breq	.+24     	; 0x1c0a <SetClock+0x2a>
    {
        time[HOUR] = gHOUR;
    1bf2:	80 91 71 01 	lds	r24, 0x0171
    1bf6:	80 93 4f 01 	sts	0x014F, r24
        time[MINUTE] = gMINUTE;
    1bfa:	80 91 77 01 	lds	r24, 0x0177
    1bfe:	80 93 50 01 	sts	0x0150, r24
        time[SECOND] = gSECOND;
    1c02:	80 91 72 01 	lds	r24, 0x0172
    1c06:	80 93 51 01 	sts	0x0151, r24
    }

    if (clockformat == CLOCK_12)    // if 12H clock
    1c0a:	80 91 33 01 	lds	r24, 0x0133
    1c0e:	88 23       	and	r24, r24
    1c10:	39 f4       	brne	.+14     	; 0x1c20 <SetClock+0x40>
        HH = CHAR2BCD2(TBL_CLOCK_12[time[HOUR]]);
    1c12:	e0 91 4f 01 	lds	r30, 0x014F
    1c16:	f0 e0       	ldi	r31, 0x00	; 0
    1c18:	e5 5e       	subi	r30, 0xE5	; 229
    1c1a:	fe 4f       	sbci	r31, 0xFE	; 254
    1c1c:	80 81       	ld	r24, Z
    1c1e:	02 c0       	rjmp	.+4      	; 0x1c24 <SetClock+0x44>
    else
        HH = CHAR2BCD2(time[HOUR]);
    1c20:	80 91 4f 01 	lds	r24, 0x014F
    1c24:	d9 da       	rcall	.-2638   	; 0x11d8 <CHAR2BCD2>
    1c26:	18 2f       	mov	r17, r24
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';

    MH = CHAR2BCD2(time[MINUTE]);
    1c28:	80 91 50 01 	lds	r24, 0x0150
    1c2c:	d5 da       	rcall	.-2646   	; 0x11d8 <CHAR2BCD2>
    1c2e:	08 2f       	mov	r16, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';

    SH = CHAR2BCD2(time[SECOND]);
    1c30:	80 91 51 01 	lds	r24, 0x0151
    1c34:	d1 da       	rcall	.-2654   	; 0x11d8 <CHAR2BCD2>
    1c36:	f8 2e       	mov	r15, r24
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    1c38:	80 91 4e 01 	lds	r24, 0x014E
    1c3c:	88 23       	and	r24, r24
    1c3e:	11 f0       	breq	.+4      	; 0x1c44 <SetClock+0x64>
    1c40:	60 e0       	ldi	r22, 0x00	; 0
    1c42:	01 c0       	rjmp	.+2      	; 0x1c46 <SetClock+0x66>
    1c44:	60 e8       	ldi	r22, 0x80	; 128
        HH = CHAR2BCD2(TBL_CLOCK_12[time[HOUR]]);
    else
        HH = CHAR2BCD2(time[HOUR]);
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';
    1c46:	81 2f       	mov	r24, r17
    1c48:	82 95       	swap	r24
    1c4a:	8f 70       	andi	r24, 0x0F	; 15

    SH = CHAR2BCD2(time[SECOND]);
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    1c4c:	80 5d       	subi	r24, 0xD0	; 208
    1c4e:	68 2b       	or	r22, r24
    1c50:	80 e0       	ldi	r24, 0x00	; 0
    1c52:	dd d2       	rcall	.+1466   	; 0x220e <LCD_putc>
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    1c54:	80 91 4e 01 	lds	r24, 0x014E
    1c58:	88 23       	and	r24, r24
    1c5a:	11 f0       	breq	.+4      	; 0x1c60 <SetClock+0x80>
    1c5c:	60 e0       	ldi	r22, 0x00	; 0
    1c5e:	01 c0       	rjmp	.+2      	; 0x1c62 <SetClock+0x82>
    1c60:	60 e8       	ldi	r22, 0x80	; 128
    1c62:	1f 70       	andi	r17, 0x0F	; 15
    1c64:	10 5d       	subi	r17, 0xD0	; 208
    1c66:	61 2b       	or	r22, r17
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	d1 d2       	rcall	.+1442   	; 0x220e <LCD_putc>
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    1c6c:	80 91 4e 01 	lds	r24, 0x014E
    1c70:	81 30       	cpi	r24, 0x01	; 1
    1c72:	11 f0       	breq	.+4      	; 0x1c78 <SetClock+0x98>
    1c74:	60 e0       	ldi	r22, 0x00	; 0
    1c76:	01 c0       	rjmp	.+2      	; 0x1c7a <SetClock+0x9a>
    1c78:	60 e8       	ldi	r22, 0x80	; 128
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';

    MH = CHAR2BCD2(time[MINUTE]);
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1c7a:	80 2f       	mov	r24, r16
    1c7c:	82 95       	swap	r24
    1c7e:	8f 70       	andi	r24, 0x0F	; 15
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    1c80:	80 5d       	subi	r24, 0xD0	; 208
    1c82:	68 2b       	or	r22, r24
    1c84:	82 e0       	ldi	r24, 0x02	; 2
    1c86:	c3 d2       	rcall	.+1414   	; 0x220e <LCD_putc>
    LCD_putc(3, ML | ((mode == MINUTE) ? 0x80 : 0x00));
    1c88:	80 91 4e 01 	lds	r24, 0x014E
    1c8c:	81 30       	cpi	r24, 0x01	; 1
    1c8e:	11 f0       	breq	.+4      	; 0x1c94 <SetClock+0xb4>
    1c90:	60 e0       	ldi	r22, 0x00	; 0
    1c92:	01 c0       	rjmp	.+2      	; 0x1c96 <SetClock+0xb6>
    1c94:	60 e8       	ldi	r22, 0x80	; 128
    1c96:	0f 70       	andi	r16, 0x0F	; 15
    1c98:	00 5d       	subi	r16, 0xD0	; 208
    1c9a:	60 2b       	or	r22, r16
    1c9c:	83 e0       	ldi	r24, 0x03	; 3
    1c9e:	b7 d2       	rcall	.+1390   	; 0x220e <LCD_putc>
    LCD_putc(4, SH | ((mode == SECOND) ? 0x80 : 0x00));
    1ca0:	80 91 4e 01 	lds	r24, 0x014E
    1ca4:	82 30       	cpi	r24, 0x02	; 2
    1ca6:	11 f0       	breq	.+4      	; 0x1cac <SetClock+0xcc>
    1ca8:	60 e0       	ldi	r22, 0x00	; 0
    1caa:	01 c0       	rjmp	.+2      	; 0x1cae <SetClock+0xce>
    1cac:	60 e8       	ldi	r22, 0x80	; 128
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';

    SH = CHAR2BCD2(time[SECOND]);
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';
    1cae:	8f 2d       	mov	r24, r15
    1cb0:	82 95       	swap	r24
    1cb2:	8f 70       	andi	r24, 0x0F	; 15

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    LCD_putc(3, ML | ((mode == MINUTE) ? 0x80 : 0x00));
    LCD_putc(4, SH | ((mode == SECOND) ? 0x80 : 0x00));
    1cb4:	80 5d       	subi	r24, 0xD0	; 208
    1cb6:	68 2b       	or	r22, r24
    1cb8:	84 e0       	ldi	r24, 0x04	; 4
    1cba:	a9 d2       	rcall	.+1362   	; 0x220e <LCD_putc>
    LCD_putc(5, SL | ((mode == SECOND) ? 0x80 : 0x00));
    1cbc:	80 91 4e 01 	lds	r24, 0x014E
    1cc0:	82 30       	cpi	r24, 0x02	; 2
    1cc2:	11 f0       	breq	.+4      	; 0x1cc8 <SetClock+0xe8>
    1cc4:	60 e0       	ldi	r22, 0x00	; 0
    1cc6:	01 c0       	rjmp	.+2      	; 0x1cca <SetClock+0xea>
    1cc8:	60 e8       	ldi	r22, 0x80	; 128
    1cca:	8f e0       	ldi	r24, 0x0F	; 15
    1ccc:	f8 22       	and	r15, r24
    1cce:	80 e3       	ldi	r24, 0x30	; 48
    1cd0:	f8 0e       	add	r15, r24
    1cd2:	6f 29       	or	r22, r15
    1cd4:	85 e0       	ldi	r24, 0x05	; 5
    1cd6:	9b d2       	rcall	.+1334   	; 0x220e <LCD_putc>
    LCD_putc(6, '\0');
    1cd8:	86 e0       	ldi	r24, 0x06	; 6
    1cda:	60 e0       	ldi	r22, 0x00	; 0
    1cdc:	98 d2       	rcall	.+1328   	; 0x220e <LCD_putc>

    LCD_Colon(1);
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	ac d2       	rcall	.+1368   	; 0x223a <LCD_Colon>

    if (input != KEY_NULL)
    1ce2:	ee 20       	and	r14, r14
    1ce4:	09 f0       	breq	.+2      	; 0x1ce8 <SetClock+0x108>
        LCD_FlashReset();
    1ce6:	b8 d2       	rcall	.+1392   	; 0x2258 <LCD_FlashReset>

    LCD_UpdateRequired(TRUE, 0);
    1ce8:	81 e0       	ldi	r24, 0x01	; 1
    1cea:	60 e0       	ldi	r22, 0x00	; 0
    1cec:	a9 d2       	rcall	.+1362   	; 0x2240 <LCD_UpdateRequired>
    
    enter_function = 1;
    1cee:	81 e0       	ldi	r24, 0x01	; 1
    1cf0:	80 93 3e 01 	sts	0x013E, r24

    // Increment/decrement hours, minutes or seconds
    if (input == KEY_PLUS)
    1cf4:	84 e0       	ldi	r24, 0x04	; 4
    1cf6:	e8 16       	cp	r14, r24
    1cf8:	41 f4       	brne	.+16     	; 0x1d0a <SetClock+0x12a>
        time[mode]++;
    1cfa:	e0 91 4e 01 	lds	r30, 0x014E
    1cfe:	f0 e0       	ldi	r31, 0x00	; 0
    1d00:	e1 5b       	subi	r30, 0xB1	; 177
    1d02:	fe 4f       	sbci	r31, 0xFE	; 254
    1d04:	80 81       	ld	r24, Z
    1d06:	8f 5f       	subi	r24, 0xFF	; 255
    1d08:	0a c0       	rjmp	.+20     	; 0x1d1e <SetClock+0x13e>
    else if (input == KEY_MINUS)
    1d0a:	85 e0       	ldi	r24, 0x05	; 5
    1d0c:	e8 16       	cp	r14, r24
    1d0e:	49 f4       	brne	.+18     	; 0x1d22 <SetClock+0x142>
        time[mode]--;
    1d10:	e0 91 4e 01 	lds	r30, 0x014E
    1d14:	f0 e0       	ldi	r31, 0x00	; 0
    1d16:	e1 5b       	subi	r30, 0xB1	; 177
    1d18:	fe 4f       	sbci	r31, 0xFE	; 254
    1d1a:	80 81       	ld	r24, Z
    1d1c:	81 50       	subi	r24, 0x01	; 1
    1d1e:	80 83       	st	Z, r24
    1d20:	2e c0       	rjmp	.+92     	; 0x1d7e <SetClock+0x19e>
    else if (input == KEY_PREV)
    1d22:	83 e0       	ldi	r24, 0x03	; 3
    1d24:	e8 16       	cp	r14, r24
    1d26:	41 f4       	brne	.+16     	; 0x1d38 <SetClock+0x158>
    {
        if (mode == HOUR)
    1d28:	80 91 4e 01 	lds	r24, 0x014E
    1d2c:	88 23       	and	r24, r24
    1d2e:	11 f4       	brne	.+4      	; 0x1d34 <SetClock+0x154>
            mode = SECOND;
    1d30:	82 e0       	ldi	r24, 0x02	; 2
    1d32:	0d c0       	rjmp	.+26     	; 0x1d4e <SetClock+0x16e>
        else
            mode--;
    1d34:	81 50       	subi	r24, 0x01	; 1
    1d36:	0b c0       	rjmp	.+22     	; 0x1d4e <SetClock+0x16e>
    }
    else if (input == KEY_NEXT)
    1d38:	82 e0       	ldi	r24, 0x02	; 2
    1d3a:	e8 16       	cp	r14, r24
    1d3c:	59 f4       	brne	.+22     	; 0x1d54 <SetClock+0x174>
    {
        if (mode == SECOND)
    1d3e:	80 91 4e 01 	lds	r24, 0x014E
    1d42:	82 30       	cpi	r24, 0x02	; 2
    1d44:	19 f4       	brne	.+6      	; 0x1d4c <SetClock+0x16c>
            mode = HOUR;
    1d46:	10 92 4e 01 	sts	0x014E, r1
    1d4a:	19 c0       	rjmp	.+50     	; 0x1d7e <SetClock+0x19e>
        else
            mode++;
    1d4c:	8f 5f       	subi	r24, 0xFF	; 255
    1d4e:	80 93 4e 01 	sts	0x014E, r24
    1d52:	15 c0       	rjmp	.+42     	; 0x1d7e <SetClock+0x19e>
    }
    else if (input == KEY_ENTER)
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	e8 16       	cp	r14, r24
    1d58:	91 f4       	brne	.+36     	; 0x1d7e <SetClock+0x19e>
    {
        // store the temporary adjusted values to the global variables
        cli(); // mt __disable_interrupt();
    1d5a:	f8 94       	cli
        gHOUR = time[HOUR];
    1d5c:	80 91 4f 01 	lds	r24, 0x014F
    1d60:	80 93 71 01 	sts	0x0171, r24
        gMINUTE = time[MINUTE];
    1d64:	80 91 50 01 	lds	r24, 0x0150
    1d68:	80 93 77 01 	sts	0x0177, r24
        gSECOND = time[SECOND];
    1d6c:	80 91 51 01 	lds	r24, 0x0151
    1d70:	80 93 72 01 	sts	0x0172, r24
        sei(); // mt __enable_interrupt();
    1d74:	78 94       	sei
        mode = HOUR;
    1d76:	10 92 4e 01 	sts	0x014E, r1
    1d7a:	86 e1       	ldi	r24, 0x16	; 22
    1d7c:	2a c0       	rjmp	.+84     	; 0x1dd2 <SetClock+0x1f2>
        return ST_TIME_CLOCK_FUNC;
    }

    /* OPTIMIZE: Can be solved by using a modulo operation */
    if (time[HOUR] == 255)
    1d7e:	80 91 4f 01 	lds	r24, 0x014F
    1d82:	8f 3f       	cpi	r24, 0xFF	; 255
    1d84:	19 f4       	brne	.+6      	; 0x1d8c <SetClock+0x1ac>
        time[HOUR] = 23;
    1d86:	87 e1       	ldi	r24, 0x17	; 23
    1d88:	80 93 4f 01 	sts	0x014F, r24
    if (time[HOUR] > 23)
    1d8c:	80 91 4f 01 	lds	r24, 0x014F
    1d90:	88 31       	cpi	r24, 0x18	; 24
    1d92:	10 f0       	brcs	.+4      	; 0x1d98 <SetClock+0x1b8>
        time[HOUR] = 0;
    1d94:	10 92 4f 01 	sts	0x014F, r1

    if (time[MINUTE] == 255)
    1d98:	80 91 50 01 	lds	r24, 0x0150
    1d9c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d9e:	19 f4       	brne	.+6      	; 0x1da6 <SetClock+0x1c6>
        time[MINUTE] = 59;
    1da0:	8b e3       	ldi	r24, 0x3B	; 59
    1da2:	80 93 50 01 	sts	0x0150, r24
    if (time[MINUTE] > 59)
    1da6:	80 91 50 01 	lds	r24, 0x0150
    1daa:	8c 33       	cpi	r24, 0x3C	; 60
    1dac:	10 f0       	brcs	.+4      	; 0x1db2 <SetClock+0x1d2>
        time[MINUTE] = 0;
    1dae:	10 92 50 01 	sts	0x0150, r1

    if (time[SECOND] == 255)
    1db2:	80 91 51 01 	lds	r24, 0x0151
    1db6:	8f 3f       	cpi	r24, 0xFF	; 255
    1db8:	19 f4       	brne	.+6      	; 0x1dc0 <SetClock+0x1e0>
        time[SECOND] = 59;
    1dba:	8b e3       	ldi	r24, 0x3B	; 59
    1dbc:	80 93 51 01 	sts	0x0151, r24
    if (time[SECOND] > 59)
    1dc0:	80 91 51 01 	lds	r24, 0x0151
    1dc4:	8c 33       	cpi	r24, 0x3C	; 60
    1dc6:	10 f0       	brcs	.+4      	; 0x1dcc <SetClock+0x1ec>
        time[SECOND] = 0;
    1dc8:	10 92 51 01 	sts	0x0151, r1

    enter_function = 0;
    1dcc:	10 92 3e 01 	sts	0x013E, r1
    1dd0:	88 e1       	ldi	r24, 0x18	; 24
    return ST_TIME_CLOCK_ADJUST_FUNC;
}
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16
    1dd6:	ff 90       	pop	r15
    1dd8:	ef 90       	pop	r14
    1dda:	08 95       	ret

00001ddc <ShowClock>:
*
*   Purpose :       Shows the clock on the LCD
*
*****************************************************************************/
char ShowClock(char input)
{
    1ddc:	bf 92       	push	r11
    1dde:	cf 92       	push	r12
    1de0:	df 92       	push	r13
    1de2:	ef 92       	push	r14
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	b8 2e       	mov	r11, r24
    //char HH, HL, MH, ML, SH, SL;
    uint8_t HH, HL, MH, ML, SH, SL;

    if (clockformat == CLOCK_12)    // if 12H clock
    1dec:	80 91 33 01 	lds	r24, 0x0133
    1df0:	88 23       	and	r24, r24
    1df2:	39 f4       	brne	.+14     	; 0x1e02 <ShowClock+0x26>
        HH = CHAR2BCD2(TBL_CLOCK_12[gHOUR]);   
    1df4:	e0 91 71 01 	lds	r30, 0x0171
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	e5 5e       	subi	r30, 0xE5	; 229
    1dfc:	fe 4f       	sbci	r31, 0xFE	; 254
    1dfe:	80 81       	ld	r24, Z
    1e00:	02 c0       	rjmp	.+4      	; 0x1e06 <ShowClock+0x2a>
    else
        HH = CHAR2BCD2(gHOUR);
    1e02:	80 91 71 01 	lds	r24, 0x0171
    1e06:	e8 d9       	rcall	.-3120   	; 0x11d8 <CHAR2BCD2>
    1e08:	08 2f       	mov	r16, r24
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';
    1e0a:	18 2f       	mov	r17, r24
    1e0c:	12 95       	swap	r17
    1e0e:	1f 70       	andi	r17, 0x0F	; 15

    MH = CHAR2BCD2(gMINUTE);
    1e10:	80 91 77 01 	lds	r24, 0x0177
    1e14:	e1 d9       	rcall	.-3134   	; 0x11d8 <CHAR2BCD2>
    1e16:	c8 2e       	mov	r12, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1e18:	e8 2e       	mov	r14, r24
    1e1a:	e2 94       	swap	r14
    1e1c:	6f e0       	ldi	r22, 0x0F	; 15
    1e1e:	e6 22       	and	r14, r22

    SH = CHAR2BCD2(gSECOND);
    1e20:	80 91 72 01 	lds	r24, 0x0172
    1e24:	d9 d9       	rcall	.-3150   	; 0x11d8 <CHAR2BCD2>
    1e26:	f8 2e       	mov	r15, r24
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';
    1e28:	d8 2e       	mov	r13, r24
    1e2a:	d2 94       	swap	r13
    1e2c:	5f e0       	ldi	r21, 0x0F	; 15
    1e2e:	d5 22       	and	r13, r21

    LCD_putc(0, HH);
    1e30:	10 5d       	subi	r17, 0xD0	; 208
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	61 2f       	mov	r22, r17
    1e36:	eb d1       	rcall	.+982    	; 0x220e <LCD_putc>
    LCD_putc(1, HL);
    1e38:	0f 70       	andi	r16, 0x0F	; 15
    1e3a:	00 5d       	subi	r16, 0xD0	; 208
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	60 2f       	mov	r22, r16
    1e40:	e6 d1       	rcall	.+972    	; 0x220e <LCD_putc>
    LCD_putc(2, MH);
    1e42:	80 e3       	ldi	r24, 0x30	; 48
    1e44:	e8 0e       	add	r14, r24
    1e46:	82 e0       	ldi	r24, 0x02	; 2
    1e48:	6e 2d       	mov	r22, r14
    1e4a:	e1 d1       	rcall	.+962    	; 0x220e <LCD_putc>
    LCD_putc(3, ML);
    1e4c:	8f e0       	ldi	r24, 0x0F	; 15
    1e4e:	c8 22       	and	r12, r24
    1e50:	80 e3       	ldi	r24, 0x30	; 48
    1e52:	c8 0e       	add	r12, r24
    1e54:	83 e0       	ldi	r24, 0x03	; 3
    1e56:	6c 2d       	mov	r22, r12
    1e58:	da d1       	rcall	.+948    	; 0x220e <LCD_putc>
    LCD_putc(4, SH);
    1e5a:	80 e3       	ldi	r24, 0x30	; 48
    1e5c:	d8 0e       	add	r13, r24
    1e5e:	84 e0       	ldi	r24, 0x04	; 4
    1e60:	6d 2d       	mov	r22, r13
    1e62:	d5 d1       	rcall	.+938    	; 0x220e <LCD_putc>
    LCD_putc(5, SL);
    1e64:	8f e0       	ldi	r24, 0x0F	; 15
    1e66:	f8 22       	and	r15, r24
    1e68:	80 e3       	ldi	r24, 0x30	; 48
    1e6a:	f8 0e       	add	r15, r24
    1e6c:	85 e0       	ldi	r24, 0x05	; 5
    1e6e:	6f 2d       	mov	r22, r15
    1e70:	ce d1       	rcall	.+924    	; 0x220e <LCD_putc>
    LCD_putc(6, '\0');
    1e72:	86 e0       	ldi	r24, 0x06	; 6
    1e74:	60 e0       	ldi	r22, 0x00	; 0
    1e76:	cb d1       	rcall	.+918    	; 0x220e <LCD_putc>

    LCD_Colon(1);
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	df d1       	rcall	.+958    	; 0x223a <LCD_Colon>

    LCD_UpdateRequired(TRUE, 0);
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	60 e0       	ldi	r22, 0x00	; 0
    1e80:	df d1       	rcall	.+958    	; 0x2240 <LCD_UpdateRequired>

    if (input == KEY_PREV)
    1e82:	83 e0       	ldi	r24, 0x03	; 3
    1e84:	b8 16       	cp	r11, r24
    1e86:	11 f4       	brne	.+4      	; 0x1e8c <ShowClock+0xb0>
    1e88:	85 e1       	ldi	r24, 0x15	; 21
    1e8a:	06 c0       	rjmp	.+12     	; 0x1e98 <ShowClock+0xbc>
        return ST_TIME_CLOCK;
    else if (input == KEY_NEXT)
    1e8c:	82 e0       	ldi	r24, 0x02	; 2
    1e8e:	b8 16       	cp	r11, r24
    1e90:	11 f0       	breq	.+4      	; 0x1e96 <ShowClock+0xba>
    1e92:	86 e1       	ldi	r24, 0x16	; 22
    1e94:	01 c0       	rjmp	.+2      	; 0x1e98 <ShowClock+0xbc>
    1e96:	87 e1       	ldi	r24, 0x17	; 23
        return ST_TIME_CLOCK_ADJUST;
      
    return ST_TIME_CLOCK_FUNC;
}
    1e98:	1f 91       	pop	r17
    1e9a:	0f 91       	pop	r16
    1e9c:	ff 90       	pop	r15
    1e9e:	ef 90       	pop	r14
    1ea0:	df 90       	pop	r13
    1ea2:	cf 90       	pop	r12
    1ea4:	bf 90       	pop	r11
    1ea6:	08 95       	ret

00001ea8 <RTC_init>:
*                   32.768kHz crystal.
*
*******************************************************************************/
void RTC_init(void)
{
    Delay(1000);            // wait for 1 sec to let the Xtal stabilize after a power-on,
    1ea8:	88 ee       	ldi	r24, 0xE8	; 232
    1eaa:	93 e0       	ldi	r25, 0x03	; 3
    1eac:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>

    cli(); // mt __disable_interrupt();  // disabel global interrupt
    1eb0:	f8 94       	cli

    cbiBF(TIMSK2, TOIE2);             // disable OCIE2A and TOIE2
    1eb2:	80 91 70 00 	lds	r24, 0x0070
    1eb6:	8e 7f       	andi	r24, 0xFE	; 254
    1eb8:	80 93 70 00 	sts	0x0070, r24

    ASSR = (1<<AS2);        // select asynchronous operation of Timer2
    1ebc:	88 e0       	ldi	r24, 0x08	; 8
    1ebe:	80 93 b6 00 	sts	0x00B6, r24

    TCNT2 = 0;              // clear TCNT2A
    1ec2:	10 92 b2 00 	sts	0x00B2, r1
    TCCR2A |= (1<<CS22) | (1<<CS20);             // select precaler: 32.768 kHz / 128 = 1 sec between each overflow
    1ec6:	80 91 b0 00 	lds	r24, 0x00B0
    1eca:	85 60       	ori	r24, 0x05	; 5
    1ecc:	80 93 b0 00 	sts	0x00B0, r24

    while((ASSR & 0x01) | (ASSR & 0x04));       // wait for TCN2UB and TCR2UB to be cleared
    1ed0:	20 91 b6 00 	lds	r18, 0x00B6
    1ed4:	80 91 b6 00 	lds	r24, 0x00B6
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	84 70       	andi	r24, 0x04	; 4
    1edc:	90 70       	andi	r25, 0x00	; 0
    1ede:	30 e0       	ldi	r19, 0x00	; 0
    1ee0:	21 70       	andi	r18, 0x01	; 1
    1ee2:	30 70       	andi	r19, 0x00	; 0
    1ee4:	82 2b       	or	r24, r18
    1ee6:	93 2b       	or	r25, r19
    1ee8:	89 2b       	or	r24, r25
    1eea:	91 f7       	brne	.-28     	; 0x1ed0 <RTC_init+0x28>

    TIFR2 = 0xFF;           // clear interrupt-flags
    1eec:	8f ef       	ldi	r24, 0xFF	; 255
    1eee:	87 bb       	out	0x17, r24	; 23
    sbiBF(TIMSK2, TOIE2);     // enable Timer2 overflow interrupt
    1ef0:	80 91 70 00 	lds	r24, 0x0070
    1ef4:	81 60       	ori	r24, 0x01	; 1
    1ef6:	80 93 70 00 	sts	0x0070, r24

    sei(); // mt __enable_interrupt();                 // enable global interrupt
    1efa:	78 94       	sei

    // initial time and date setting
    gSECOND  = 0;
    1efc:	10 92 72 01 	sts	0x0172, r1
    gMINUTE  = 0;
    1f00:	10 92 77 01 	sts	0x0177, r1
    gHOUR    = 12;
    1f04:	8c e0       	ldi	r24, 0x0C	; 12
    1f06:	80 93 71 01 	sts	0x0171, r24
    // mt release timestamp
    gDAY     = 12;
    1f0a:	80 93 73 01 	sts	0x0173, r24
    gMONTH   = 3;
    1f0e:	83 e0       	ldi	r24, 0x03	; 3
    1f10:	80 93 76 01 	sts	0x0176, r24
    gYEAR    = 9;
    1f14:	89 e0       	ldi	r24, 0x09	; 9
    1f16:	90 e0       	ldi	r25, 0x00	; 0
    1f18:	90 93 75 01 	sts	0x0175, r25
    1f1c:	80 93 74 01 	sts	0x0174, r24
}
    1f20:	08 95       	ret

00001f22 <DF_SPI_init>:
void DF_SPI_init (void)
{
	// mtA
	// PORTB |= (1<<PORTB3) | (1<<PORTB2) | (1<<PORTB1) | (1<<PORTB0);
	// DDRB |= (1<<PORTB2) | (1<<PORTB1) | (1<<PORTB0);		//Set MOSI, SCK AND SS as outputs
	PORTB |= (1<<PB3) | (1<<PB2) | (1<<PB1) | (1<<PB0);
    1f22:	85 b1       	in	r24, 0x05	; 5
    1f24:	8f 60       	ori	r24, 0x0F	; 15
    1f26:	85 b9       	out	0x05, r24	; 5
	DDRB |= (1<<DDB2) | (1<<DDB1) | (1<<DDB0);		//Set MOSI, SCK AND SS as outputs
    1f28:	84 b1       	in	r24, 0x04	; 4
    1f2a:	87 60       	ori	r24, 0x07	; 7
    1f2c:	84 b9       	out	0x04, r24	; 4
	// mtE
	SPSR = (1<<SPI2X);                                      //SPI double speed settings
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	8d bd       	out	0x2d, r24	; 45
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA) | (1<<CPOL);	//Enable SPI in Master mode, mode 3, Fosc/4
    1f32:	8c e5       	ldi	r24, 0x5C	; 92
    1f34:	8c bd       	out	0x2c, r24	; 44
// mt: the following line was already commented out in the original code
//	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA) | (1<<CPOL) | (1<<SPR1) | (1<<SPR0);	//Enable SPI in Master mode, mode 3, Fosc/2
}
    1f36:	08 95       	ret

00001f38 <DF_SPI_RW>:
******************************************************************************/
unsigned char DF_SPI_RW (unsigned char output)
{
	unsigned char input;
	
	SPDR = output;							//put byte 'output' in SPI data register
    1f38:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & 0x80));					//wait for transfer complete, poll SPIF-flag
    1f3a:	0d b4       	in	r0, 0x2d	; 45
    1f3c:	07 fe       	sbrs	r0, 7
    1f3e:	fd cf       	rjmp	.-6      	; 0x1f3a <DF_SPI_RW+0x2>
	input = SPDR;							//read value in SPI data reg.
    1f40:	8e b5       	in	r24, 0x2e	; 46
	
	return input;							//return the byte clocked in from SPI slave
}
    1f42:	08 95       	ret

00001f44 <Read_DF_status>:
******************************************************************************/
unsigned char Read_DF_status (void)
{
	unsigned char result,index_copy;
	
	DF_CS_inactive;							//make sure to toggle CS signal in order
    1f44:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;							//to reset dataflash command decoder
    1f46:	28 98       	cbi	0x05, 0	; 5
	result = DF_SPI_RW(StatusReg);			//send status register read op-code
    1f48:	87 e5       	ldi	r24, 0x57	; 87
    1f4a:	f6 df       	rcall	.-20     	; 0x1f38 <DF_SPI_RW>
	result = DF_SPI_RW(0x00);				//dummy write to get result
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
    1f4e:	f4 df       	rcall	.-24     	; 0x1f38 <DF_SPI_RW>
	index_copy = ((result & 0x38) >> 3);	//get the size info from status register
	// mtA
	/// if (!PageBits) { // mt 200401
		// PageBits   = DF_pagebits[index_copy];	//get number of internal page address bits from look-up table
		// PageSize   = DF_pagesize[index_copy];   //get the size of the page (in bytes)
		PageBits   = pgm_read_byte(&DF_pagebits[index_copy]);	//get number of internal page address bits from look-up table
    1f50:	28 2f       	mov	r18, r24
    1f52:	30 e0       	ldi	r19, 0x00	; 0
    1f54:	28 73       	andi	r18, 0x38	; 56
    1f56:	30 70       	andi	r19, 0x00	; 0
    1f58:	43 e0       	ldi	r20, 0x03	; 3
    1f5a:	36 95       	lsr	r19
    1f5c:	27 95       	ror	r18
    1f5e:	4a 95       	dec	r20
    1f60:	e1 f7       	brne	.-8      	; 0x1f5a <Read_DF_status+0x16>
    1f62:	f9 01       	movw	r30, r18
    1f64:	ea 5b       	subi	r30, 0xBA	; 186
    1f66:	fa 4f       	sbci	r31, 0xFA	; 250
    1f68:	e4 91       	lpm	r30, Z+
    1f6a:	e0 93 52 01 	sts	0x0152, r30
		PageSize   = pgm_read_word(&DF_pagesize[index_copy]);   //get the size of the page (in bytes)
    1f6e:	f9 01       	movw	r30, r18
    1f70:	ee 0f       	add	r30, r30
    1f72:	ff 1f       	adc	r31, r31
    1f74:	e2 5b       	subi	r30, 0xB2	; 178
    1f76:	fa 4f       	sbci	r31, 0xFA	; 250
    1f78:	25 91       	lpm	r18, Z+
    1f7a:	34 91       	lpm	r19, Z+
    1f7c:	30 93 54 01 	sts	0x0154, r19
    1f80:	20 93 53 01 	sts	0x0153, r18
	/// }
	// mtE
	return result;							//return the read status register value
}
    1f84:	08 95       	ret

00001f86 <Buffer_Write_Byte>:
*	Purpose :		Writes one byte to one of the dataflash
*					internal SRAM buffers
*
******************************************************************************/
void Buffer_Write_Byte (unsigned char BufferNo, unsigned int IntPageAdr, unsigned char Data)
{
    1f86:	1f 93       	push	r17
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	eb 01       	movw	r28, r22
    1f8e:	14 2f       	mov	r17, r20
	
	DF_CS_inactive;								//make sure to toggle CS signal in order
    1f90:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;								//to reset dataflash command decoder
    1f92:	28 98       	cbi	0x05, 0	; 5
	
	if (1 == BufferNo)							//write byte to buffer 1
    1f94:	81 30       	cpi	r24, 0x01	; 1
    1f96:	59 f4       	brne	.+22     	; 0x1fae <Buffer_Write_Byte+0x28>
	{
		DF_SPI_RW(Buf1Write);					//buffer 1 write op-code
    1f98:	84 e8       	ldi	r24, 0x84	; 132
    1f9a:	ce df       	rcall	.-100    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW(0x00);						//don't cares
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	cc df       	rcall	.-104    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    1fa0:	8d 2f       	mov	r24, r29
    1fa2:	99 27       	eor	r25, r25
    1fa4:	c9 df       	rcall	.-110    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    1fa6:	8c 2f       	mov	r24, r28
    1fa8:	c7 df       	rcall	.-114    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW(Data);						//write data byte
    1faa:	81 2f       	mov	r24, r17
    1fac:	c5 df       	rcall	.-118    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
		DF_SPI_RW(Data);						//write data byte
	}		
#endif
}
    1fae:	df 91       	pop	r29
    1fb0:	cf 91       	pop	r28
    1fb2:	1f 91       	pop	r17
    1fb4:	08 95       	ret

00001fb6 <Buffer_To_Page>:
*
*	Purpose :		Transfers a page from dataflash SRAM buffer to flash
*					
******************************************************************************/
void Buffer_To_Page (unsigned char BufferNo, unsigned int PageAdr)
{
    1fb6:	cf 93       	push	r28
    1fb8:	df 93       	push	r29
    1fba:	eb 01       	movw	r28, r22
	DF_CS_inactive;												//make sure to toggle CS signal in order
    1fbc:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;												//to reset dataflash command decoder
    1fbe:	28 98       	cbi	0x05, 0	; 5
		
	if (1 == BufferNo)											//program flash page from buffer 1
    1fc0:	81 30       	cpi	r24, 0x01	; 1
    1fc2:	e9 f4       	brne	.+58     	; 0x1ffe <Buffer_To_Page+0x48>
	{
		DF_SPI_RW(Buf1ToFlashWE);								//buffer 1 to flash with erase op-code
    1fc4:	83 e8       	ldi	r24, 0x83	; 131
    1fc6:	b8 df       	rcall	.-144    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
    1fc8:	20 91 52 01 	lds	r18, 0x0152
    1fcc:	80 e1       	ldi	r24, 0x10	; 16
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	82 1b       	sub	r24, r18
    1fd2:	91 09       	sbc	r25, r1
    1fd4:	9e 01       	movw	r18, r28
    1fd6:	02 c0       	rjmp	.+4      	; 0x1fdc <Buffer_To_Page+0x26>
    1fd8:	36 95       	lsr	r19
    1fda:	27 95       	ror	r18
    1fdc:	8a 95       	dec	r24
    1fde:	e2 f7       	brpl	.-8      	; 0x1fd8 <Buffer_To_Page+0x22>
    1fe0:	c9 01       	movw	r24, r18
    1fe2:	aa df       	rcall	.-172    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
    1fe4:	80 91 52 01 	lds	r24, 0x0152
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	08 97       	sbiw	r24, 0x08	; 8
    1fec:	02 c0       	rjmp	.+4      	; 0x1ff2 <Buffer_To_Page+0x3c>
    1fee:	cc 0f       	add	r28, r28
    1ff0:	dd 1f       	adc	r29, r29
    1ff2:	8a 95       	dec	r24
    1ff4:	e2 f7       	brpl	.-8      	; 0x1fee <Buffer_To_Page+0x38>
    1ff6:	8c 2f       	mov	r24, r28
    1ff8:	9f df       	rcall	.-194    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW(0x00);										//don't cares
    1ffa:	80 e0       	ldi	r24, 0x00	; 0
    1ffc:	9d df       	rcall	.-198    	; 0x1f38 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
		DF_SPI_RW(0x00);										//don't cares
	}
#endif
	
	DF_CS_inactive;												//initiate flash page programming
    1ffe:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;												
    2000:	28 98       	cbi	0x05, 0	; 5
	
	while(!(Read_DF_status() & 0x80));							//monitor the status register, wait until busy-flag is high
    2002:	a0 df       	rcall	.-192    	; 0x1f44 <Read_DF_status>
    2004:	87 ff       	sbrs	r24, 7
    2006:	fd cf       	rjmp	.-6      	; 0x2002 <Buffer_To_Page+0x4c>
}
    2008:	df 91       	pop	r29
    200a:	cf 91       	pop	r28
    200c:	08 95       	ret

0000200e <Cont_Flash_Read_Enable>:
*
*	Purpose :		Initiates a continuous read from a location in the DataFlash
*
******************************************************************************/
void Cont_Flash_Read_Enable (unsigned int PageAdr, unsigned int IntPageAdr)
{
    200e:	ef 92       	push	r14
    2010:	ff 92       	push	r15
    2012:	0f 93       	push	r16
    2014:	1f 93       	push	r17
    2016:	8c 01       	movw	r16, r24
    2018:	7b 01       	movw	r14, r22
	DF_CS_inactive;																//make sure to toggle CS signal in order
    201a:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;																//to reset dataflash command decoder
    201c:	28 98       	cbi	0x05, 0	; 5
	
	DF_SPI_RW(ContArrayRead);													//Continuous Array Read op-code
    201e:	88 e6       	ldi	r24, 0x68	; 104
    2020:	8b df       	rcall	.-234    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));						//upper part of page address
    2022:	20 91 52 01 	lds	r18, 0x0152
    2026:	80 e1       	ldi	r24, 0x10	; 16
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	82 1b       	sub	r24, r18
    202c:	91 09       	sbc	r25, r1
    202e:	98 01       	movw	r18, r16
    2030:	02 c0       	rjmp	.+4      	; 0x2036 <Cont_Flash_Read_Enable+0x28>
    2032:	36 95       	lsr	r19
    2034:	27 95       	ror	r18
    2036:	8a 95       	dec	r24
    2038:	e2 f7       	brpl	.-8      	; 0x2032 <Cont_Flash_Read_Enable+0x24>
    203a:	c9 01       	movw	r24, r18
    203c:	7d df       	rcall	.-262    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)((PageAdr << (PageBits - 8))+ (IntPageAdr>>8)));	//lower part of page address and MSB of int.page adr.
    203e:	8f 2d       	mov	r24, r15
    2040:	99 27       	eor	r25, r25
    2042:	20 91 52 01 	lds	r18, 0x0152
    2046:	30 e0       	ldi	r19, 0x00	; 0
    2048:	28 50       	subi	r18, 0x08	; 8
    204a:	30 40       	sbci	r19, 0x00	; 0
    204c:	02 c0       	rjmp	.+4      	; 0x2052 <Cont_Flash_Read_Enable+0x44>
    204e:	00 0f       	add	r16, r16
    2050:	11 1f       	adc	r17, r17
    2052:	2a 95       	dec	r18
    2054:	e2 f7       	brpl	.-8      	; 0x204e <Cont_Flash_Read_Enable+0x40>
    2056:	80 0f       	add	r24, r16
    2058:	6f df       	rcall	.-290    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)(IntPageAdr));										//LSB byte of internal page address
    205a:	8e 2d       	mov	r24, r14
    205c:	6d df       	rcall	.-294    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//perform 4 dummy writes
    205e:	80 e0       	ldi	r24, 0x00	; 0
    2060:	6b df       	rcall	.-298    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//in order to intiate DataFlash
    2062:	80 e0       	ldi	r24, 0x00	; 0
    2064:	69 df       	rcall	.-302    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//address pointers
    2066:	80 e0       	ldi	r24, 0x00	; 0
    2068:	67 df       	rcall	.-306    	; 0x1f38 <DF_SPI_RW>
	DF_SPI_RW(0x00);
    206a:	80 e0       	ldi	r24, 0x00	; 0
    206c:	65 df       	rcall	.-310    	; 0x1f38 <DF_SPI_RW>
}
    206e:	1f 91       	pop	r17
    2070:	0f 91       	pop	r16
    2072:	ff 90       	pop	r15
    2074:	ef 90       	pop	r14
    2076:	08 95       	ret

00002078 <getkey>:
*****************************************************************************/
char getkey(void)
{
    char k;

    cli(); // mt: __disable_interrupt();
    2078:	f8 94       	cli

    if (KEY_VALID)              // Check for unread key in buffer
    207a:	80 91 57 01 	lds	r24, 0x0157
    207e:	88 23       	and	r24, r24
    2080:	21 f0       	breq	.+8      	; 0x208a <getkey+0x12>
    {
        k = KEY;
    2082:	80 91 56 01 	lds	r24, 0x0156
        KEY_VALID = FALSE;
    2086:	10 92 57 01 	sts	0x0157, r1
    }
    else
        k = KEY_NULL;           // No key stroke available

    sei(); // mt: __enable_interrupt();
    208a:	78 94       	sei

    return k;
}
    208c:	08 95       	ret

0000208e <PinChangeInterrupt>:
    PORTB | PORTE   B   A       O   D   C
    =============================================
*/


    buttons = (~PINB) & PINB_MASK;
    208e:	83 b1       	in	r24, 0x03	; 3
    buttons |= (~PINE) & PINE_MASK;
    2090:	2c b1       	in	r18, 0x0c	; 12
    2092:	20 95       	com	r18
    2094:	2c 70       	andi	r18, 0x0C	; 12
    2096:	80 95       	com	r24
    2098:	80 7d       	andi	r24, 0xD0	; 208
    209a:	28 2b       	or	r18, r24

    // Output virtual keys
    if (buttons & (1<<BUTTON_A))
    209c:	26 ff       	sbrs	r18, 6
    209e:	02 c0       	rjmp	.+4      	; 0x20a4 <PinChangeInterrupt+0x16>
    20a0:	94 e0       	ldi	r25, 0x04	; 4
    20a2:	0f c0       	rjmp	.+30     	; 0x20c2 <PinChangeInterrupt+0x34>
        key = KEY_PLUS;
    else if (buttons & (1<<BUTTON_B))
    20a4:	27 ff       	sbrs	r18, 7
    20a6:	02 c0       	rjmp	.+4      	; 0x20ac <PinChangeInterrupt+0x1e>
    20a8:	95 e0       	ldi	r25, 0x05	; 5
    20aa:	0b c0       	rjmp	.+22     	; 0x20c2 <PinChangeInterrupt+0x34>
        key = KEY_MINUS;
    else if (buttons & (1<<BUTTON_C))
    20ac:	22 ff       	sbrs	r18, 2
    20ae:	02 c0       	rjmp	.+4      	; 0x20b4 <PinChangeInterrupt+0x26>
    20b0:	93 e0       	ldi	r25, 0x03	; 3
    20b2:	07 c0       	rjmp	.+14     	; 0x20c2 <PinChangeInterrupt+0x34>
        key = KEY_PREV;
    else if (buttons & (1<<BUTTON_D))
    20b4:	23 ff       	sbrs	r18, 3
    20b6:	02 c0       	rjmp	.+4      	; 0x20bc <PinChangeInterrupt+0x2e>
    20b8:	92 e0       	ldi	r25, 0x02	; 2
    20ba:	03 c0       	rjmp	.+6      	; 0x20c2 <PinChangeInterrupt+0x34>
        key = KEY_NEXT;
    else if (buttons & (1<<BUTTON_O))
    20bc:	24 ff       	sbrs	r18, 4
    20be:	15 c0       	rjmp	.+42     	; 0x20ea <PinChangeInterrupt+0x5c>
    20c0:	91 e0       	ldi	r25, 0x01	; 1
        key = KEY_NULL;

    
    if(key != KEY_NULL)
    {
        if(gButtonTimeout)  // gButtonTimeout is set in the LCD_SOF_interrupt in LCD_driver.c
    20c2:	80 91 55 01 	lds	r24, 0x0155
    20c6:	88 23       	and	r24, r24
    20c8:	81 f0       	breq	.+32     	; 0x20ea <PinChangeInterrupt+0x5c>
        {
            if (!KEY_VALID)
    20ca:	80 91 57 01 	lds	r24, 0x0157
    20ce:	88 23       	and	r24, r24
    20d0:	51 f4       	brne	.+20     	; 0x20e6 <PinChangeInterrupt+0x58>
            {
                KEY = key;          // Store key in global key buffer
    20d2:	90 93 56 01 	sts	0x0156, r25
                KEY_VALID = TRUE;
    20d6:	81 e0       	ldi	r24, 0x01	; 1
    20d8:	80 93 57 01 	sts	0x0157, r24
                if (gKeyClickStatus)
    20dc:	80 91 46 01 	lds	r24, 0x0146
    20e0:	88 23       	and	r24, r24
    20e2:	09 f0       	breq	.+2      	; 0x20e6 <PinChangeInterrupt+0x58>
                  PlayClick();
    20e4:	55 d2       	rcall	.+1194   	; 0x2590 <PlayClick>
            }

         gButtonTimeout = FALSE;
    20e6:	10 92 55 01 	sts	0x0155, r1
    
        }
    }
    
    EIFR = (1<<PCIF1) | (1<<PCIF0);     // Delete pin change interrupt flags
    20ea:	80 ec       	ldi	r24, 0xC0	; 192
    20ec:	8c bb       	out	0x1c, r24	; 28

    gPowerSaveTimer = 0;                // Reset the Auto Power Down timer
    20ee:	10 92 48 01 	sts	0x0148, r1
    
}
    20f2:	08 95       	ret

000020f4 <__vector_3>:
// mtA
// #pragma vector = PCINT1_vect
// __interrupt void PCINT1_interrupt(void)
// mtE
ISR(PCINT1_vect)
{
    20f4:	1f 92       	push	r1
    20f6:	0f 92       	push	r0
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	0f 92       	push	r0
    20fc:	11 24       	eor	r1, r1
    20fe:	2f 93       	push	r18
    2100:	3f 93       	push	r19
    2102:	4f 93       	push	r20
    2104:	5f 93       	push	r21
    2106:	6f 93       	push	r22
    2108:	7f 93       	push	r23
    210a:	8f 93       	push	r24
    210c:	9f 93       	push	r25
    210e:	af 93       	push	r26
    2110:	bf 93       	push	r27
    2112:	ef 93       	push	r30
    2114:	ff 93       	push	r31
    PinChangeInterrupt();
    2116:	bb df       	rcall	.-138    	; 0x208e <PinChangeInterrupt>
}
    2118:	ff 91       	pop	r31
    211a:	ef 91       	pop	r30
    211c:	bf 91       	pop	r27
    211e:	af 91       	pop	r26
    2120:	9f 91       	pop	r25
    2122:	8f 91       	pop	r24
    2124:	7f 91       	pop	r23
    2126:	6f 91       	pop	r22
    2128:	5f 91       	pop	r21
    212a:	4f 91       	pop	r20
    212c:	3f 91       	pop	r19
    212e:	2f 91       	pop	r18
    2130:	0f 90       	pop	r0
    2132:	0f be       	out	0x3f, r0	; 63
    2134:	0f 90       	pop	r0
    2136:	1f 90       	pop	r1
    2138:	18 95       	reti

0000213a <__vector_2>:

// #pragma vector = PCINT0_vect
// __interrupt void PCINT0_interrupt(void)
ISR(PCINT0_vect)
// mtE
{
    213a:	1f 92       	push	r1
    213c:	0f 92       	push	r0
    213e:	0f b6       	in	r0, 0x3f	; 63
    2140:	0f 92       	push	r0
    2142:	11 24       	eor	r1, r1
    2144:	2f 93       	push	r18
    2146:	3f 93       	push	r19
    2148:	4f 93       	push	r20
    214a:	5f 93       	push	r21
    214c:	6f 93       	push	r22
    214e:	7f 93       	push	r23
    2150:	8f 93       	push	r24
    2152:	9f 93       	push	r25
    2154:	af 93       	push	r26
    2156:	bf 93       	push	r27
    2158:	ef 93       	push	r30
    215a:	ff 93       	push	r31
    PinChangeInterrupt();
    215c:	98 df       	rcall	.-208    	; 0x208e <PinChangeInterrupt>
}
    215e:	ff 91       	pop	r31
    2160:	ef 91       	pop	r30
    2162:	bf 91       	pop	r27
    2164:	af 91       	pop	r26
    2166:	9f 91       	pop	r25
    2168:	8f 91       	pop	r24
    216a:	7f 91       	pop	r23
    216c:	6f 91       	pop	r22
    216e:	5f 91       	pop	r21
    2170:	4f 91       	pop	r20
    2172:	3f 91       	pop	r19
    2174:	2f 91       	pop	r18
    2176:	0f 90       	pop	r0
    2178:	0f be       	out	0x3f, r0	; 63
    217a:	0f 90       	pop	r0
    217c:	1f 90       	pop	r1
    217e:	18 95       	reti

00002180 <Button_Init>:
*
*****************************************************************************/
void Button_Init(void)
{
    // Init port pins
    cbiBF(DDRB,7);
    2180:	27 98       	cbi	0x04, 7	; 4
    cbiBF(DDRB,6);
    2182:	26 98       	cbi	0x04, 6	; 4
    cbiBF(DDRB,4);
    2184:	24 98       	cbi	0x04, 4	; 4
    PORTB |= PINB_MASK;
    2186:	85 b1       	in	r24, 0x05	; 5
    2188:	80 6d       	ori	r24, 0xD0	; 208
    218a:	85 b9       	out	0x05, r24	; 5
    DDRE = 0x00;
    218c:	1d b8       	out	0x0d, r1	; 13
    PORTE |= PINE_MASK;
    218e:	8e b1       	in	r24, 0x0e	; 14
    2190:	8c 60       	ori	r24, 0x0C	; 12
    2192:	8e b9       	out	0x0e, r24	; 14

    // Enable pin change interrupt on PORTB and PORTE
    PCMSK0 = PINE_MASK;
    2194:	8c e0       	ldi	r24, 0x0C	; 12
    2196:	80 93 6b 00 	sts	0x006B, r24
    PCMSK1 = PINB_MASK;
    219a:	80 ed       	ldi	r24, 0xD0	; 208
    219c:	80 93 6c 00 	sts	0x006C, r24
    EIFR = (1<<PCIF0)|(1<<PCIF1);
    21a0:	80 ec       	ldi	r24, 0xC0	; 192
    21a2:	8c bb       	out	0x1c, r24	; 28
    EIMSK = (1<<PCIE0)|(1<<PCIE1);
    21a4:	8d bb       	out	0x1d, r24	; 29

    CountdownTimerHandle = Timer0_AllocateCountdownTimer();
    21a6:	05 d8       	rcall	.-4086   	; 0x11b2 <Timer0_AllocateCountdownTimer>
    21a8:	80 93 78 01 	sts	0x0178, r24
}
    21ac:	08 95       	ret

000021ae <LCD_puts_f>:
*
*****************************************************************************/

// mt void LCD_puts_f(char __flash *pFlashStr, char scrollmode)
void LCD_puts_f(const char *pFlashStr, char scrollmode)
{
    21ae:	bc 01       	movw	r22, r24
    uint8_t i;

    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer
    21b0:	80 91 59 01 	lds	r24, 0x0159
    21b4:	88 23       	and	r24, r24
    21b6:	e1 f7       	brne	.-8      	; 0x21b0 <LCD_puts_f+0x2>
    21b8:	20 e0       	ldi	r18, 0x00	; 0
    21ba:	30 e0       	ldi	r19, 0x00	; 0
    21bc:	06 c0       	rjmp	.+12     	; 0x21ca <LCD_puts_f+0x1c>

    // mt: for (i = 0; pFlashStr[i] && i < TEXTBUFFER_SIZE; i++)
    for (i = 0; (const char)(pgm_read_byte(&pFlashStr[i])) && i < TEXTBUFFER_SIZE; i++)
    {
        // mt: gTextBuffer[i] = pFlashStr[i];
        gTextBuffer[i] = pgm_read_byte(&pFlashStr[i]);
    21be:	f9 01       	movw	r30, r18
    21c0:	e2 57       	subi	r30, 0x72	; 114
    21c2:	fe 4f       	sbci	r31, 0xFE	; 254
    21c4:	80 83       	st	Z, r24
    21c6:	2f 5f       	subi	r18, 0xFF	; 255
    21c8:	3f 4f       	sbci	r19, 0xFF	; 255
    21ca:	42 2f       	mov	r20, r18
    21cc:	fb 01       	movw	r30, r22
    21ce:	e2 0f       	add	r30, r18
    21d0:	f3 1f       	adc	r31, r19
    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer

    // mt: for (i = 0; pFlashStr[i] && i < TEXTBUFFER_SIZE; i++)
    for (i = 0; (const char)(pgm_read_byte(&pFlashStr[i])) && i < TEXTBUFFER_SIZE; i++)
    21d2:	84 91       	lpm	r24, Z+
    21d4:	88 23       	and	r24, r24
    21d6:	19 f0       	breq	.+6      	; 0x21de <LCD_puts_f+0x30>
    21d8:	29 31       	cpi	r18, 0x19	; 25
    21da:	31 05       	cpc	r19, r1
    21dc:	81 f7       	brne	.-32     	; 0x21be <LCD_puts_f+0x10>
    {
        // mt: gTextBuffer[i] = pFlashStr[i];
        gTextBuffer[i] = pgm_read_byte(&pFlashStr[i]);
    }

    gTextBuffer[i] = '\0';
    21de:	e4 2f       	mov	r30, r20
    21e0:	f0 e0       	ldi	r31, 0x00	; 0
    21e2:	e2 57       	subi	r30, 0x72	; 114
    21e4:	fe 4f       	sbci	r31, 0xFE	; 254
    21e6:	10 82       	st	Z, r1

    if (i > 6)
    21e8:	47 30       	cpi	r20, 0x07	; 7
    21ea:	48 f0       	brcs	.+18     	; 0x21fe <LCD_puts_f+0x50>
    {
        gScrollMode = 1;        // Scroll if text is longer than display size
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	80 93 79 01 	sts	0x0179, r24
        gScroll = 0;
    21f2:	10 92 a7 01 	sts	0x01A7, r1
        gLCD_Start_Scroll_Timer = 3;    //Start-up delay before scrolling the text
    21f6:	83 e0       	ldi	r24, 0x03	; 3
    21f8:	80 93 5a 01 	sts	0x015A, r24
    21fc:	04 c0       	rjmp	.+8      	; 0x2206 <LCD_puts_f+0x58>
    }
    else
    {
        gScrollMode = 0;        
    21fe:	10 92 79 01 	sts	0x0179, r1
        gScroll = 0;
    2202:	10 92 a7 01 	sts	0x01A7, r1
    }

    gLCD_Update_Required = 1;
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	80 93 59 01 	sts	0x0159, r24
}
    220c:	08 95       	ret

0000220e <LCD_putc>:
*
*****************************************************************************/
// mt void LCD_putc(char digit, char character)
void LCD_putc(uint8_t digit, char character)
{
    if (digit < TEXTBUFFER_SIZE) {
    220e:	89 31       	cpi	r24, 0x19	; 25
    2210:	28 f4       	brcc	.+10     	; 0x221c <LCD_putc+0xe>
        gTextBuffer[digit] = character;
    2212:	e8 2f       	mov	r30, r24
    2214:	f0 e0       	ldi	r31, 0x00	; 0
    2216:	e2 57       	subi	r30, 0x72	; 114
    2218:	fe 4f       	sbci	r31, 0xFE	; 254
    221a:	60 83       	st	Z, r22
    221c:	08 95       	ret

0000221e <LCD_Clear>:
*
*	Purpose :		Clear the LCD
*
*****************************************************************************/
void LCD_Clear(void)
{
    221e:	80 e0       	ldi	r24, 0x00	; 0
    2220:	90 e0       	ldi	r25, 0x00	; 0
    uint8_t i; // char i;

    for (i=0; i<TEXTBUFFER_SIZE; i++) {
        gTextBuffer[i] = ' ';
    2222:	20 e2       	ldi	r18, 0x20	; 32
    2224:	fc 01       	movw	r30, r24
    2226:	e2 57       	subi	r30, 0x72	; 114
    2228:	fe 4f       	sbci	r31, 0xFE	; 254
    222a:	20 83       	st	Z, r18
    222c:	01 96       	adiw	r24, 0x01	; 1
*****************************************************************************/
void LCD_Clear(void)
{
    uint8_t i; // char i;

    for (i=0; i<TEXTBUFFER_SIZE; i++) {
    222e:	89 31       	cpi	r24, 0x19	; 25
    2230:	91 05       	cpc	r25, r1
    2232:	c1 f7       	brne	.-16     	; 0x2224 <LCD_Clear+0x6>
        gTextBuffer[i] = ' ';
    }

    gTextBuffer[TEXTBUFFER_SIZE - 1] = '\0'; // M. Loeffler 12/2009
    2234:	10 92 a6 01 	sts	0x01A6, r1
}
    2238:	08 95       	ret

0000223a <LCD_Colon>:
*	Purpose :		Enable/disable colons on the LCD
*
*****************************************************************************/
void LCD_Colon(char show)
{
    gColon = show;
    223a:	80 93 5c 01 	sts	0x015C, r24
}
    223e:	08 95       	ret

00002240 <LCD_UpdateRequired>:
*
*	Purpose :		Tells the LCD that there is new data to be presented
*
*****************************************************************************/
void LCD_UpdateRequired(char update, char scrollmode)
{
    2240:	98 2f       	mov	r25, r24

    while (gLCD_Update_Required);
    2242:	80 91 59 01 	lds	r24, 0x0159
    2246:	88 23       	and	r24, r24
    2248:	e1 f7       	brne	.-8      	; 0x2242 <LCD_UpdateRequired+0x2>
    
    gScrollMode = scrollmode;
    224a:	60 93 79 01 	sts	0x0179, r22
    gScroll = 0;
    224e:	10 92 a7 01 	sts	0x01A7, r1

    gLCD_Update_Required = update;
    2252:	90 93 59 01 	sts	0x0159, r25
}
    2256:	08 95       	ret

00002258 <LCD_FlashReset>:
*	Purpose :		This function resets the blinking cycle of a flashing digit
*
*****************************************************************************/
void LCD_FlashReset(void)
{
    gFlashTimer = 0;
    2258:	10 92 5b 01 	sts	0x015B, r1
}
    225c:	08 95       	ret

0000225e <SetContrast>:
*
*	Purpose :		Adjust the LCD contrast
*
*****************************************************************************/
char SetContrast(char input)
{
    225e:	ff 92       	push	r15
    2260:	0f 93       	push	r16
    2262:	1f 93       	push	r17
    2264:	f8 2e       	mov	r15, r24
    static char enter = 1;
    char CH, CL;

    if (enter)
    2266:	80 91 40 01 	lds	r24, 0x0140
    226a:	88 23       	and	r24, r24
    226c:	19 f0       	breq	.+6      	; 0x2274 <SetContrast+0x16>
    {
        LCD_Clear();
    226e:	d7 df       	rcall	.-82     	; 0x221e <LCD_Clear>
        enter = 0;
    2270:	10 92 40 01 	sts	0x0140, r1
    }

    CH = CHAR2BCD2(CONTRAST);
    2274:	80 91 3f 01 	lds	r24, 0x013F
    2278:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <CHAR2BCD2>
    227c:	18 2f       	mov	r17, r24
    CL = (CH & 0x0F) + '0';
    CH = (CH >> 4) + '0';
    227e:	08 2f       	mov	r16, r24
    2280:	02 95       	swap	r16
    2282:	0f 70       	andi	r16, 0x0F	; 15

    LCD_putc(0, 'C');
    2284:	80 e0       	ldi	r24, 0x00	; 0
    2286:	63 e4       	ldi	r22, 0x43	; 67
    2288:	c2 df       	rcall	.-124    	; 0x220e <LCD_putc>
    LCD_putc(1, 'T');
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	64 e5       	ldi	r22, 0x54	; 84
    228e:	bf df       	rcall	.-130    	; 0x220e <LCD_putc>
    LCD_putc(2, 'R');
    2290:	82 e0       	ldi	r24, 0x02	; 2
    2292:	62 e5       	ldi	r22, 0x52	; 82
    2294:	bc df       	rcall	.-136    	; 0x220e <LCD_putc>
    LCD_putc(3, ' ');
    2296:	83 e0       	ldi	r24, 0x03	; 3
    2298:	60 e2       	ldi	r22, 0x20	; 32
    229a:	b9 df       	rcall	.-142    	; 0x220e <LCD_putc>
    LCD_putc(4, CH);
    229c:	00 5d       	subi	r16, 0xD0	; 208
    229e:	84 e0       	ldi	r24, 0x04	; 4
    22a0:	60 2f       	mov	r22, r16
    22a2:	b5 df       	rcall	.-150    	; 0x220e <LCD_putc>
    LCD_putc(5, CL);
    22a4:	1f 70       	andi	r17, 0x0F	; 15
    22a6:	10 5d       	subi	r17, 0xD0	; 208
    22a8:	85 e0       	ldi	r24, 0x05	; 5
    22aa:	61 2f       	mov	r22, r17
    22ac:	b0 df       	rcall	.-160    	; 0x220e <LCD_putc>

    LCD_UpdateRequired(TRUE, 0);
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	60 e0       	ldi	r22, 0x00	; 0
    22b2:	c6 df       	rcall	.-116    	; 0x2240 <LCD_UpdateRequired>

    if (input == KEY_PLUS)
    22b4:	84 e0       	ldi	r24, 0x04	; 4
    22b6:	f8 16       	cp	r15, r24
    22b8:	21 f4       	brne	.+8      	; 0x22c2 <SetContrast+0x64>
        CONTRAST++;
    22ba:	80 91 3f 01 	lds	r24, 0x013F
    22be:	8f 5f       	subi	r24, 0xFF	; 255
    22c0:	06 c0       	rjmp	.+12     	; 0x22ce <SetContrast+0x70>
    else if (input == KEY_MINUS)
    22c2:	85 e0       	ldi	r24, 0x05	; 5
    22c4:	f8 16       	cp	r15, r24
    22c6:	29 f4       	brne	.+10     	; 0x22d2 <SetContrast+0x74>
        CONTRAST--;
    22c8:	80 91 3f 01 	lds	r24, 0x013F
    22cc:	81 50       	subi	r24, 0x01	; 1
    22ce:	80 93 3f 01 	sts	0x013F, r24

    if (CONTRAST == 255)
    22d2:	80 91 3f 01 	lds	r24, 0x013F
    22d6:	8f 3f       	cpi	r24, 0xFF	; 255
    22d8:	11 f4       	brne	.+4      	; 0x22de <SetContrast+0x80>
        CONTRAST = 0;
    22da:	10 92 3f 01 	sts	0x013F, r1
    if (CONTRAST > 15)
    22de:	80 91 3f 01 	lds	r24, 0x013F
    22e2:	80 31       	cpi	r24, 0x10	; 16
    22e4:	18 f0       	brcs	.+6      	; 0x22ec <SetContrast+0x8e>
        CONTRAST = 15;
    22e6:	8f e0       	ldi	r24, 0x0F	; 15
    22e8:	80 93 3f 01 	sts	0x013F, r24

    LCD_CONTRAST_LEVEL(CONTRAST);
    22ec:	90 91 e7 00 	lds	r25, 0x00E7
    22f0:	80 91 3f 01 	lds	r24, 0x013F
    22f4:	8f 70       	andi	r24, 0x0F	; 15
    22f6:	90 7f       	andi	r25, 0xF0	; 240
    22f8:	89 2b       	or	r24, r25
    22fa:	80 93 e7 00 	sts	0x00E7, r24


    if (input == KEY_ENTER)
    22fe:	81 e0       	ldi	r24, 0x01	; 1
    2300:	f8 16       	cp	r15, r24
    2302:	11 f0       	breq	.+4      	; 0x2308 <SetContrast+0xaa>
    2304:	8d e5       	ldi	r24, 0x5D	; 93
    2306:	03 c0       	rjmp	.+6      	; 0x230e <SetContrast+0xb0>
    {
        enter = 1;
    2308:	f0 92 40 01 	sts	0x0140, r15
    230c:	8c e5       	ldi	r24, 0x5C	; 92
        return ST_OPTIONS_DISPLAY_CONTRAST;
    }

    return ST_OPTIONS_DISPLAY_CONTRAST_FUNC;
}
    230e:	1f 91       	pop	r17
    2310:	0f 91       	pop	r16
    2312:	ff 90       	pop	r15
    2314:	08 95       	ret

00002316 <LCD_WriteDigit>:
*   Purpose :       Stores LCD control data in the LCD_displayData buffer.
*                   (The LCD_displayData is latched in the LCD_SOF interrupt.)
*
*****************************************************************************/
void LCD_WriteDigit(char c, char digit)
{
    2316:	cf 93       	push	r28
    2318:	df 93       	push	r29
    231a:	98 2f       	mov	r25, r24
    char mask, nibble;
    volatile char *ptr;
    char i;


    if (digit > 5)                              // Skip if digit is illegal
    231c:	66 30       	cpi	r22, 0x06	; 6
    231e:	c8 f5       	brcc	.+114    	; 0x2392 <LCD_WriteDigit+0x7c>
        return;

    //Lookup character table for segmet data
    if ((c >= '*') && (c <= 'z'))
    2320:	8a 52       	subi	r24, 0x2A	; 42
    2322:	81 35       	cpi	r24, 0x51	; 81
    2324:	18 f0       	brcs	.+6      	; 0x232c <LCD_WriteDigit+0x16>
    2326:	a0 e0       	ldi	r26, 0x00	; 0
    2328:	b0 e0       	ldi	r27, 0x00	; 0
    232a:	0c c0       	rjmp	.+24     	; 0x2344 <LCD_WriteDigit+0x2e>
    {
        // c is a letter
        if (c >= 'a')                           // Convert to upper case
    232c:	91 36       	cpi	r25, 0x61	; 97
    232e:	08 f0       	brcs	.+2      	; 0x2332 <LCD_WriteDigit+0x1c>
            c &= ~0x20;                         // if necessarry
    2330:	9f 7d       	andi	r25, 0xDF	; 223

        c -= '*';

        //mt seg = LCD_character_table[c];
        seg = (unsigned int) pgm_read_word(&LCD_character_table[(uint8_t)c]); 
    2332:	9a 52       	subi	r25, 0x2A	; 42
    2334:	e9 2f       	mov	r30, r25
    2336:	f0 e0       	ldi	r31, 0x00	; 0
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	e2 5a       	subi	r30, 0xA2	; 162
    233e:	fa 4f       	sbci	r31, 0xFA	; 250
    2340:	a5 91       	lpm	r26, Z+
    2342:	b4 91       	lpm	r27, Z+
    }

    // Adjust mask according to LCD segment mapping
    if (digit & 0x01)
    2344:	86 2f       	mov	r24, r22
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	ec 01       	movw	r28, r24
    234a:	c1 70       	andi	r28, 0x01	; 1
    234c:	d0 70       	andi	r29, 0x00	; 0
    234e:	60 fd       	sbrc	r22, 0
    2350:	02 c0       	rjmp	.+4      	; 0x2356 <LCD_WriteDigit+0x40>
    2352:	90 ef       	ldi	r25, 0xF0	; 240
    2354:	01 c0       	rjmp	.+2      	; 0x2358 <LCD_WriteDigit+0x42>
    2356:	9f e0       	ldi	r25, 0x0F	; 15
        mask = 0x0F;                // Digit 1, 3, 5
    else
        mask = 0xF0;                // Digit 0, 2, 4

    ptr = LCD_Data + (digit >> 1);  // digit = {0,0,1,1,2,2}
    2358:	66 95       	lsr	r22
    235a:	70 e0       	ldi	r23, 0x00	; 0
    235c:	66 58       	subi	r22, 0x86	; 134
    235e:	7e 4f       	sbci	r23, 0xFE	; 254
    2360:	20 e0       	ldi	r18, 0x00	; 0
    2362:	30 e0       	ldi	r19, 0x00	; 0
    2364:	fb 01       	movw	r30, r22
    2366:	e2 0f       	add	r30, r18
    2368:	f3 1f       	adc	r31, r19

    for (i = 0; i < 4; i++)
    {
        nibble = seg & 0x000F;
    236a:	4a 2f       	mov	r20, r26
    236c:	4f 70       	andi	r20, 0x0F	; 15
        seg >>= 4;
    236e:	84 e0       	ldi	r24, 0x04	; 4
    2370:	b6 95       	lsr	r27
    2372:	a7 95       	ror	r26
    2374:	8a 95       	dec	r24
    2376:	e1 f7       	brne	.-8      	; 0x2370 <LCD_WriteDigit+0x5a>
        if (digit & 0x01)
    2378:	20 97       	sbiw	r28, 0x00	; 0
    237a:	11 f0       	breq	.+4      	; 0x2380 <LCD_WriteDigit+0x6a>
            nibble <<= 4;
    237c:	42 95       	swap	r20
    237e:	40 7f       	andi	r20, 0xF0	; 240
        *ptr = (*ptr & mask) | nibble;
    2380:	80 81       	ld	r24, Z
    2382:	89 23       	and	r24, r25
    2384:	48 2b       	or	r20, r24
    2386:	40 83       	st	Z, r20
    2388:	2b 5f       	subi	r18, 0xFB	; 251
    238a:	3f 4f       	sbci	r19, 0xFF	; 255
    else
        mask = 0xF0;                // Digit 0, 2, 4

    ptr = LCD_Data + (digit >> 1);  // digit = {0,0,1,1,2,2}

    for (i = 0; i < 4; i++)
    238c:	24 31       	cpi	r18, 0x14	; 20
    238e:	31 05       	cpc	r19, r1
    2390:	49 f7       	brne	.-46     	; 0x2364 <LCD_WriteDigit+0x4e>
        if (digit & 0x01)
            nibble <<= 4;
        *ptr = (*ptr & mask) | nibble;
        ptr += 5;
    }
}
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	08 95       	ret

00002398 <LCD_AllSegments>:
*****************************************************************************/
void LCD_AllSegments(char show)
{
    unsigned char i;

    if (show)
    2398:	81 11       	cpse	r24, r1
    239a:	8f ef       	ldi	r24, 0xFF	; 255
    239c:	20 e0       	ldi	r18, 0x00	; 0
    239e:	30 e0       	ldi	r19, 0x00	; 0
    23a0:	f9 01       	movw	r30, r18
    23a2:	e6 58       	subi	r30, 0x86	; 134
    23a4:	fe 4f       	sbci	r31, 0xFE	; 254
        show = 0xFF;

    // Set/clear all bits in all LCD registers
    for (i=0; i < LCD_REGISTER_COUNT; i++)
        *(LCD_Data + i) = show;
    23a6:	80 83       	st	Z, r24
    23a8:	2f 5f       	subi	r18, 0xFF	; 255
    23aa:	3f 4f       	sbci	r19, 0xFF	; 255

    if (show)
        show = 0xFF;

    // Set/clear all bits in all LCD registers
    for (i=0; i < LCD_REGISTER_COUNT; i++)
    23ac:	24 31       	cpi	r18, 0x14	; 20
    23ae:	31 05       	cpc	r19, r1
    23b0:	b9 f7       	brne	.-18     	; 0x23a0 <LCD_AllSegments+0x8>
        *(LCD_Data + i) = show;
}
    23b2:	08 95       	ret

000023b4 <LCD_Init>:
*                   Set up the LCD (timing, contrast, etc.)
*
*****************************************************************************/
void LCD_Init(void)
{
    LCD_AllSegments(FALSE);                     // Clear segment buffer.
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	f0 df       	rcall	.-32     	; 0x2398 <LCD_AllSegments>

    LCD_CONTRAST_LEVEL(LCD_INITIAL_CONTRAST);    //Set the LCD contrast level
    23b8:	a7 ee       	ldi	r26, 0xE7	; 231
    23ba:	b0 e0       	ldi	r27, 0x00	; 0
    23bc:	8c 91       	ld	r24, X
    23be:	8f 60       	ori	r24, 0x0F	; 15
    23c0:	8c 93       	st	X, r24

    // Select asynchronous clock source, enable all COM pins and enable all
    // segment pins.
    LCDCRB = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    23c2:	87 eb       	ldi	r24, 0xB7	; 183
    23c4:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR = (0<<LCDPS0) | (7<<LCDCD0);    
    23c8:	87 e0       	ldi	r24, 0x07	; 7
    23ca:	80 93 e6 00 	sts	0x00E6, r24

    LCDCRA = (1<<LCDEN) | (1<<LCDAB);           // Enable LCD and set low power waveform
    23ce:	e4 ee       	ldi	r30, 0xE4	; 228
    23d0:	f0 e0       	ldi	r31, 0x00	; 0
    23d2:	80 ec       	ldi	r24, 0xC0	; 192
    23d4:	80 83       	st	Z, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
    23d6:	80 81       	ld	r24, Z
    23d8:	88 60       	ori	r24, 0x08	; 8
    23da:	80 83       	st	Z, r24

    //updated 2006-10-10, setting LCD drive time to 1150us in FW rev 07, 
    //instead of previous 300us in FW rev 06. Due to some variations on the LCD
    //glass provided to the AVR Butterfly production.
    LCDCCR |= (1<<LCDDC2) | (1<<LCDDC1) | (1<<LCDDC0);
    23dc:	8c 91       	ld	r24, X
    23de:	80 6e       	ori	r24, 0xE0	; 224
    23e0:	8c 93       	st	X, r24

    gLCD_Update_Required = FALSE;
    23e2:	10 92 59 01 	sts	0x0159, r1


}
    23e6:	08 95       	ret

000023e8 <__vector_22>:
*   Purpose: Latch the LCD_displayData and Set LCD_status.updateComplete
*
*****************************************************************************/

ISR(LCD_vect)
{
    23e8:	1f 92       	push	r1
    23ea:	0f 92       	push	r0
    23ec:	0f b6       	in	r0, 0x3f	; 63
    23ee:	0f 92       	push	r0
    23f0:	11 24       	eor	r1, r1
    23f2:	ef 92       	push	r14
    23f4:	ff 92       	push	r15
    23f6:	0f 93       	push	r16
    23f8:	1f 93       	push	r17
    23fa:	2f 93       	push	r18
    23fc:	3f 93       	push	r19
    23fe:	4f 93       	push	r20
    2400:	5f 93       	push	r21
    2402:	6f 93       	push	r22
    2404:	7f 93       	push	r23
    2406:	8f 93       	push	r24
    2408:	9f 93       	push	r25
    240a:	af 93       	push	r26
    240c:	bf 93       	push	r27
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	ef 93       	push	r30
    2414:	ff 93       	push	r31
    static char auto_joystick_count;

    c_flash=0; // mt
    
/**************** Button timeout for the button.c, START ****************/
    if(!gButtonTimeout)
    2416:	80 91 55 01 	lds	r24, 0x0155
    241a:	88 23       	and	r24, r24
    241c:	61 f4       	brne	.+24     	; 0x2436 <__vector_22+0x4e>
    {
        timeout_count++;
    241e:	80 91 5e 01 	lds	r24, 0x015E
    2422:	8f 5f       	subi	r24, 0xFF	; 255
    2424:	80 93 5e 01 	sts	0x015E, r24
        
        if(timeout_count > 3)
    2428:	84 30       	cpi	r24, 0x04	; 4
    242a:	28 f0       	brcs	.+10     	; 0x2436 <__vector_22+0x4e>
        {
            gButtonTimeout = TRUE;
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	80 93 55 01 	sts	0x0155, r24
            timeout_count = 0;
    2432:	10 92 5e 01 	sts	0x015E, r1

/**************** Button timeout for the button.c, END ******************/

/**************** Auto press joystick for the main.c, START *************/

    if(gAutoPressJoystick == AUTO)
    2436:	80 91 58 01 	lds	r24, 0x0158
    243a:	83 30       	cpi	r24, 0x03	; 3
    243c:	71 f4       	brne	.+28     	; 0x245a <__vector_22+0x72>
    {
        auto_joystick_count++;
    243e:	80 91 5d 01 	lds	r24, 0x015D
    2442:	8f 5f       	subi	r24, 0xFF	; 255
    2444:	80 93 5d 01 	sts	0x015D, r24
        
        if(auto_joystick_count > 16)
    2448:	81 31       	cpi	r24, 0x11	; 17
    244a:	48 f0       	brcs	.+18     	; 0x245e <__vector_22+0x76>
        {
            gAutoPressJoystick = TRUE;
    244c:	81 e0       	ldi	r24, 0x01	; 1
    244e:	80 93 58 01 	sts	0x0158, r24
            auto_joystick_count = 15;
    2452:	8f e0       	ldi	r24, 0x0F	; 15
    2454:	80 93 5d 01 	sts	0x015D, r24
    2458:	02 c0       	rjmp	.+4      	; 0x245e <__vector_22+0x76>
        }
    }
    else
        auto_joystick_count = 0;
    245a:	10 92 5d 01 	sts	0x015D, r1


/**************** Auto press joystick for the main.c, END ***************/    

    LCD_timer--;                    // Decreased every LCD frame
    245e:	00 91 41 01 	lds	r16, 0x0141
    2462:	01 50       	subi	r16, 0x01	; 1
    2464:	00 93 41 01 	sts	0x0141, r16

    if (gScrollMode)
    2468:	80 91 79 01 	lds	r24, 0x0179
    246c:	88 23       	and	r24, r24
    246e:	81 f0       	breq	.+32     	; 0x2490 <__vector_22+0xa8>
    {
        // If we are in scroll mode, and the timer has expired,
        // we will update the LCD
        if (LCD_timer == 0)
    2470:	00 23       	and	r16, r16
    2472:	81 f4       	brne	.+32     	; 0x2494 <__vector_22+0xac>
        {
            if (gLCD_Start_Scroll_Timer == 0)
    2474:	80 91 5a 01 	lds	r24, 0x015A
    2478:	88 23       	and	r24, r24
    247a:	21 f4       	brne	.+8      	; 0x2484 <__vector_22+0x9c>
            {
                gLCD_Update_Required = TRUE;
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	80 93 59 01 	sts	0x0159, r24
    2482:	08 c0       	rjmp	.+16     	; 0x2494 <__vector_22+0xac>
            }
            else
                gLCD_Start_Scroll_Timer--;
    2484:	80 91 5a 01 	lds	r24, 0x015A
    2488:	81 50       	subi	r24, 0x01	; 1
    248a:	80 93 5a 01 	sts	0x015A, r24
    248e:	02 c0       	rjmp	.+4      	; 0x2494 <__vector_22+0xac>
    }
    else    
    {   // if not scrolling,
        // disble LCD start of frame interrupt
        // cbi(LCDCRA, LCDIE);   //DEBUG
        gScroll = 0;
    2490:	10 92 a7 01 	sts	0x01A7, r1
    }


    EOL = FALSE;
    if (gLCD_Update_Required == TRUE)
    2494:	80 91 59 01 	lds	r24, 0x0159
    2498:	81 30       	cpi	r24, 0x01	; 1
    249a:	09 f0       	breq	.+2      	; 0x249e <__vector_22+0xb6>
    249c:	51 c0       	rjmp	.+162    	; 0x2540 <__vector_22+0x158>
    {
        // Duty cycle of flashing characters
        if (gFlashTimer < (LCD_FLASH_SEED >> 1))
    249e:	e0 90 5b 01 	lds	r14, 0x015B
    24a2:	ff 24       	eor	r15, r15
    24a4:	10 e0       	ldi	r17, 0x00	; 0
    24a6:	c0 e0       	ldi	r28, 0x00	; 0
    24a8:	d0 e0       	ldi	r29, 0x00	; 0
    24aa:	6c 2f       	mov	r22, r28
            flash = 1;

        // Repeat for the six LCD characters
        for (i = 0; i < 6; i++)
        {
            if ((gScroll+i) >= 0 && (!EOL))
    24ac:	80 91 a7 01 	lds	r24, 0x01A7
    24b0:	99 27       	eor	r25, r25
    24b2:	87 fd       	sbrc	r24, 7
    24b4:	90 95       	com	r25
    24b6:	8c 0f       	add	r24, r28
    24b8:	9d 1f       	adc	r25, r29
    24ba:	97 fd       	sbrc	r25, 7
    24bc:	15 c0       	rjmp	.+42     	; 0x24e8 <__vector_22+0x100>
    24be:	11 23       	and	r17, r17
    24c0:	99 f4       	brne	.+38     	; 0x24e8 <__vector_22+0x100>
            {
                // We have some visible characters
                c = gTextBuffer[i + gScroll];
    24c2:	e0 91 a7 01 	lds	r30, 0x01A7
    24c6:	ff 27       	eor	r31, r31
    24c8:	e7 fd       	sbrc	r30, 7
    24ca:	f0 95       	com	r31
    24cc:	ec 0f       	add	r30, r28
    24ce:	fd 1f       	adc	r31, r29
    24d0:	e2 57       	subi	r30, 0x72	; 114
    24d2:	fe 4f       	sbci	r31, 0xFE	; 254
    24d4:	80 81       	ld	r24, Z
                c_flash = c & 0x80 ? 1 : 0;
    24d6:	f8 2e       	mov	r15, r24
    24d8:	ff 1c       	adc	r15, r15
    24da:	ff 24       	eor	r15, r15
    24dc:	ff 1c       	adc	r15, r15
                c = c & 0x7F;
    24de:	8f 77       	andi	r24, 0x7F	; 127

                if (c == '\0')
    24e0:	21 f4       	brne	.+8      	; 0x24ea <__vector_22+0x102>
    24e2:	1c 2f       	mov	r17, r28
    24e4:	1f 5f       	subi	r17, 0xFF	; 255
    24e6:	01 c0       	rjmp	.+2      	; 0x24ea <__vector_22+0x102>
    24e8:	80 e2       	ldi	r24, 0x20	; 32
            else
                c = ' ';

            // Check if this character is flashing

            if (c_flash && flash)
    24ea:	ff 20       	and	r15, r15
    24ec:	21 f0       	breq	.+8      	; 0x24f6 <__vector_22+0x10e>
    24ee:	94 e0       	ldi	r25, 0x04	; 4
    24f0:	9e 15       	cp	r25, r14
    24f2:	08 f4       	brcc	.+2      	; 0x24f6 <__vector_22+0x10e>
                LCD_WriteDigit(' ', i);
    24f4:	80 e2       	ldi	r24, 0x20	; 32
            else
                LCD_WriteDigit(c, i);
    24f6:	0f df       	rcall	.-482    	; 0x2316 <LCD_WriteDigit>
    24f8:	21 96       	adiw	r28, 0x01	; 1
            flash = 0;
        else
            flash = 1;

        // Repeat for the six LCD characters
        for (i = 0; i < 6; i++)
    24fa:	c6 30       	cpi	r28, 0x06	; 6
    24fc:	d1 05       	cpc	r29, r1
    24fe:	a9 f6       	brne	.-86     	; 0x24aa <__vector_22+0xc2>
    2500:	ac ee       	ldi	r26, 0xEC	; 236
    2502:	b0 e0       	ldi	r27, 0x00	; 0
    2504:	fd 01       	movw	r30, r26
    2506:	e2 57       	subi	r30, 0x72	; 114
    2508:	ff 4f       	sbci	r31, 0xFF	; 255
                LCD_WriteDigit(c, i);
        }

        // Copy the segment buffer to the real segments
        for (i = 0; i < LCD_REGISTER_COUNT; i++)
            *(pLCDREG + i) = *(LCD_Data+i);
    250a:	80 81       	ld	r24, Z
    250c:	8d 93       	st	X+, r24
            else
                LCD_WriteDigit(c, i);
        }

        // Copy the segment buffer to the real segments
        for (i = 0; i < LCD_REGISTER_COUNT; i++)
    250e:	81 e0       	ldi	r24, 0x01	; 1
    2510:	a0 30       	cpi	r26, 0x00	; 0
    2512:	b8 07       	cpc	r27, r24
    2514:	b9 f7       	brne	.-18     	; 0x2504 <__vector_22+0x11c>
            *(pLCDREG + i) = *(LCD_Data+i);

        // Handle colon
        if (gColon)
    2516:	80 91 5c 01 	lds	r24, 0x015C
    251a:	88 23       	and	r24, r24
    251c:	21 f0       	breq	.+8      	; 0x2526 <__vector_22+0x13e>
            *(pLCDREG + 8) = 0x01;
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	80 93 f4 00 	sts	0x00F4, r24
    2524:	02 c0       	rjmp	.+4      	; 0x252a <__vector_22+0x142>
        else
            *(pLCDREG + 8) = 0x00;
    2526:	10 92 f4 00 	sts	0x00F4, r1

        // If the text scrolled off the display,
        // we have to start over again.
        if (EOL == 1)
    252a:	11 30       	cpi	r17, 0x01	; 1
    252c:	11 f4       	brne	.+4      	; 0x2532 <__vector_22+0x14a>
            gScroll = -6;
    252e:	8a ef       	ldi	r24, 0xFA	; 250
    2530:	03 c0       	rjmp	.+6      	; 0x2538 <__vector_22+0x150>
        else
            gScroll++;
    2532:	80 91 a7 01 	lds	r24, 0x01A7
    2536:	8f 5f       	subi	r24, 0xFF	; 255
    2538:	80 93 a7 01 	sts	0x01A7, r24

        // No need to update anymore
        gLCD_Update_Required = FALSE;
    253c:	10 92 59 01 	sts	0x0159, r1
    }


    // LCD_timer is used when scrolling text
    if (LCD_timer == 0)
    2540:	00 23       	and	r16, r16
    2542:	19 f4       	brne	.+6      	; 0x254a <__vector_22+0x162>
    {
/*        if ((gScroll <= 0) || EOL)
            LCD_timer = LCD_TIMER_SEED/2;
        else*/
            LCD_timer = LCD_TIMER_SEED;
    2544:	83 e0       	ldi	r24, 0x03	; 3
    2546:	80 93 41 01 	sts	0x0141, r24
    }

    // gFlashTimer is used when flashing characters
    if (gFlashTimer == LCD_FLASH_SEED)
    254a:	80 91 5b 01 	lds	r24, 0x015B
    254e:	8a 30       	cpi	r24, 0x0A	; 10
    2550:	19 f4       	brne	.+6      	; 0x2558 <__vector_22+0x170>
        gFlashTimer= 0;
    2552:	10 92 5b 01 	sts	0x015B, r1
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <__vector_22+0x17a>
    else
        gFlashTimer++;
    2558:	80 91 5b 01 	lds	r24, 0x015B
    255c:	8f 5f       	subi	r24, 0xFF	; 255
    255e:	80 93 5b 01 	sts	0x015B, r24

}
    2562:	ff 91       	pop	r31
    2564:	ef 91       	pop	r30
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	bf 91       	pop	r27
    256c:	af 91       	pop	r26
    256e:	9f 91       	pop	r25
    2570:	8f 91       	pop	r24
    2572:	7f 91       	pop	r23
    2574:	6f 91       	pop	r22
    2576:	5f 91       	pop	r21
    2578:	4f 91       	pop	r20
    257a:	3f 91       	pop	r19
    257c:	2f 91       	pop	r18
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	ef 90       	pop	r14
    2586:	0f 90       	pop	r0
    2588:	0f be       	out	0x3f, r0	; 63
    258a:	0f 90       	pop	r0
    258c:	1f 90       	pop	r1
    258e:	18 95       	reti

00002590 <PlayClick>:
*
*   Purpose :       Plays the click-sound
*
*****************************************************************************/
void PlayClick(void)
{
    2590:	1f 93       	push	r17
    2592:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char i;
	for (i = 0; i < 10; i++) {
		cbiBF(PORTB, 5);
    2594:	2d 98       	cbi	0x05, 5	; 5
		Delay(1);
    2596:	81 e0       	ldi	r24, 0x01	; 1
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>
		sbiBF(PORTB, 5);
    259e:	2d 9a       	sbi	0x05, 5	; 5
		Delay(1);
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	90 e0       	ldi	r25, 0x00	; 0
    25a4:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>
*
*****************************************************************************/
void PlayClick(void)
{
	unsigned char i;
	for (i = 0; i < 10; i++) {
    25a8:	1f 5f       	subi	r17, 0xFF	; 255
    25aa:	1a 30       	cpi	r17, 0x0A	; 10
    25ac:	99 f7       	brne	.-26     	; 0x2594 <PlayClick+0x4>
		cbiBF(PORTB, 5);
		Delay(1);
		sbiBF(PORTB, 5);
		Delay(1);
	}
}
    25ae:	1f 91       	pop	r17
    25b0:	08 95       	ret

000025b2 <Play_Tune>:
    unsigned int temp_tone;	// mt 200301
    int temp_hi;
    
    char loop;
    
    if(!Tone)
    25b2:	80 91 60 01 	lds	r24, 0x0160
    25b6:	88 23       	and	r24, r24
    25b8:	69 f4       	brne	.+26     	; 0x25d4 <Play_Tune+0x22>
    {
        Duration = 0;   
    25ba:	10 92 61 01 	sts	0x0161, r1
        // mt Tempo = *(pSong + 0);
        Tempo = (uint8_t)pgm_read_word(pSong + 0);
    25be:	e0 91 a8 01 	lds	r30, 0x01A8
    25c2:	f0 91 a9 01 	lds	r31, 0x01A9
    25c6:	85 91       	lpm	r24, Z+
    25c8:	94 91       	lpm	r25, Z+
    25ca:	80 93 63 01 	sts	0x0163, r24
        Tone = 1;   //Start the song from the beginning
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	80 93 60 01 	sts	0x0160, r24
    }
    
    if(!Tempo)
    25d4:	80 91 63 01 	lds	r24, 0x0163
    25d8:	88 23       	and	r24, r24
    25da:	09 f0       	breq	.+2      	; 0x25de <Play_Tune+0x2c>
    25dc:	6d c0       	rjmp	.+218    	; 0x26b8 <Play_Tune+0x106>
    {
        if(Duration)        // Check if the lenght of the tone has "expired"
    25de:	80 91 61 01 	lds	r24, 0x0161
    25e2:	88 23       	and	r24, r24
    25e4:	21 f0       	breq	.+8      	; 0x25ee <Play_Tune+0x3c>
        {   
            Duration--;
    25e6:	81 50       	subi	r24, 0x01	; 1
    25e8:	80 93 61 01 	sts	0x0161, r24
    25ec:	5e c0       	rjmp	.+188    	; 0x26aa <Play_Tune+0xf8>
        }
        // mt: else if(*(pSong + Tone))    // If not the end of the song
        else if(pgm_read_word(pSong + Tone))  // If not the end of the song
    25ee:	20 91 a8 01 	lds	r18, 0x01A8
    25f2:	30 91 a9 01 	lds	r19, 0x01A9
    25f6:	80 91 60 01 	lds	r24, 0x0160
    25fa:	e8 2f       	mov	r30, r24
    25fc:	f0 e0       	ldi	r31, 0x00	; 0
    25fe:	ee 0f       	add	r30, r30
    2600:	ff 1f       	adc	r31, r31
    2602:	e2 0f       	add	r30, r18
    2604:	f3 1f       	adc	r31, r19
    2606:	65 91       	lpm	r22, Z+
    2608:	74 91       	lpm	r23, Z+
    260a:	48 2f       	mov	r20, r24
    260c:	4f 5f       	subi	r20, 0xFF	; 255
    260e:	61 15       	cp	r22, r1
    2610:	71 05       	cpc	r23, r1
    2612:	59 f1       	breq	.+86     	; 0x266a <Play_Tune+0xb8>
        {
            // mt: Duration = ( DURATION_SEED / *(pSong + Tone) );  // store the duration
            Duration = ( DURATION_SEED / pgm_read_word(pSong + Tone) );  // store the duration
    2614:	80 e2       	ldi	r24, 0x20	; 32
    2616:	90 e0       	ldi	r25, 0x00	; 0
    2618:	03 d4       	rcall	.+2054   	; 0x2e20 <__udivmodhi4>
    261a:	60 93 61 01 	sts	0x0161, r22
        
            Tone++;                     // point to the next tone in the Song-table        

            temp_tone=pgm_read_word(pSong + Tone); // mt 200301
    261e:	e4 2f       	mov	r30, r20
    2620:	f0 e0       	ldi	r31, 0x00	; 0
    2622:	ee 0f       	add	r30, r30
    2624:	ff 1f       	adc	r31, r31
    2626:	e2 0f       	add	r30, r18
    2628:	f3 1f       	adc	r31, r19
    262a:	25 91       	lpm	r18, Z+
    262c:	34 91       	lpm	r19, Z+
            // mt: if( (*(pSong + Tone) == p) | (*(pSong + Tone) == P) ) // if pause
            // if( (pgm_read_word(pSong + Tone) == p) | (pgm_read_word(pSong + Tone) == P) ) // if pause
            if( (temp_tone == p) || (temp_tone == P) ) // if pause
    262e:	21 30       	cpi	r18, 0x01	; 1
    2630:	31 05       	cpc	r19, r1
    2632:	21 f4       	brne	.+8      	; 0x263c <Play_Tune+0x8a>
                cbiBF(TCCR1B, CS10);             // stop Timer1, prescaler(1)    
    2634:	80 91 81 00 	lds	r24, 0x0081
    2638:	8e 7f       	andi	r24, 0xFE	; 254
    263a:	03 c0       	rjmp	.+6      	; 0x2642 <Play_Tune+0x90>
            else 
                sbiBF(TCCR1B, CS10);             // start Timer1, prescaler(1)  
    263c:	80 91 81 00 	lds	r24, 0x0081
    2640:	81 60       	ori	r24, 0x01	; 1
    2642:	80 93 81 00 	sts	0x0081, r24
                
            cli(); // mt __disable_interrupt();
    2646:	f8 94       	cli
            // mt temp_hi = *(pSong + Tone);      // read out the PWM-value
            // temp_hi = pgm_read_word(pSong + Tone);      // read out the PWM-value
            temp_hi = temp_tone;   // mt 200301
            temp_hi >>= 8;                  // move integer 8 bits to the rigth
                
            TCNT1H = 0;                     // reset TCNT1H/L
    2648:	10 92 85 00 	sts	0x0085, r1
            TCNT1L = 0;
    264c:	10 92 84 00 	sts	0x0084, r1
            
            ICR1H = temp_hi;                // load ICR1H/L
    2650:	83 2f       	mov	r24, r19
    2652:	99 27       	eor	r25, r25
    2654:	87 fd       	sbrc	r24, 7
    2656:	9a 95       	dec	r25
    2658:	80 93 87 00 	sts	0x0087, r24
            // mt: ICR1L = *(pSong + Tone);        
            // ICR1L = pgm_read_word(pSong + Tone);
            ICR1L = temp_tone;
    265c:	20 93 86 00 	sts	0x0086, r18
            
            sei(); // mt: __enable_interrupt();
    2660:	78 94       	sei
            
            Tone++;                     // point to the next tone in the Song-table
    2662:	4f 5f       	subi	r20, 0xFF	; 255
    2664:	40 93 60 01 	sts	0x0160, r20
    2668:	20 c0       	rjmp	.+64     	; 0x26aa <Play_Tune+0xf8>
        else    // the end of song
        {
            Tone++;         // point to the next tone in the Song-table        
            
            // mt: loop = *(pSong + Tone); // get the byte that tells if the song should loop or not
            loop = (uint8_t)pgm_read_word(pSong + Tone); // get the byte that tells if the song should loop or not
    266a:	e4 2f       	mov	r30, r20
    266c:	f0 e0       	ldi	r31, 0x00	; 0
    266e:	ee 0f       	add	r30, r30
    2670:	ff 1f       	adc	r31, r31
    2672:	e2 0f       	add	r30, r18
    2674:	f3 1f       	adc	r31, r19
    2676:	85 91       	lpm	r24, Z+
    2678:	94 91       	lpm	r25, Z+
            
            if( loop )  
    267a:	88 23       	and	r24, r24
    267c:	21 f0       	breq	.+8      	; 0x2686 <Play_Tune+0xd4>
            {
                Tone = 1;
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	80 93 60 01 	sts	0x0160, r24
    2684:	12 c0       	rjmp	.+36     	; 0x26aa <Play_Tune+0xf8>
            }
            else        // if not looping the song
            {
                Tone = 0;
    2686:	10 92 60 01 	sts	0x0160, r1
                gPlaying = FALSE;
    268a:	10 92 5f 01 	sts	0x015F, r1
                cbiBF(TCCR1B, 0);                     // stop Playing
    268e:	80 91 81 00 	lds	r24, 0x0081
    2692:	8e 7f       	andi	r24, 0xFE	; 254
    2694:	80 93 81 00 	sts	0x0081, r24
                Timer0_RemoveCallbackFunction(Play_Tune);
    2698:	89 ed       	ldi	r24, 0xD9	; 217
    269a:	92 e1       	ldi	r25, 0x12	; 18
    269c:	0e 94 bf 08 	call	0x117e	; 0x117e <Timer0_RemoveCallbackFunction>
                TCCR1A = 0;
    26a0:	10 92 80 00 	sts	0x0080, r1
                TCCR1B = 0;
    26a4:	10 92 81 00 	sts	0x0081, r1
                sbiBF(PORTB, 5);              // set OC1A high
    26a8:	2d 9a       	sbi	0x05, 5	; 5
            }
        }
        
        // mt: Tempo = *(pSong + 0);
        Tempo = (uint8_t)pgm_read_word(pSong + 0);
    26aa:	e0 91 a8 01 	lds	r30, 0x01A8
    26ae:	f0 91 a9 01 	lds	r31, 0x01A9
    26b2:	85 91       	lpm	r24, Z+
    26b4:	94 91       	lpm	r25, Z+
    26b6:	01 c0       	rjmp	.+2      	; 0x26ba <Play_Tune+0x108>
    }
    else
        Tempo--;
    26b8:	81 50       	subi	r24, 0x01	; 1
    26ba:	80 93 63 01 	sts	0x0163, r24
    26be:	08 95       	ret

000026c0 <showSongName>:
*
*****************************************************************************/
// mt inserted local helper to save some flash-space
static void showSongName(unsigned char songnum)
{
    LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[songnum]), 1);  // mt   // Set up the a song in the LCD
    26c0:	e8 2f       	mov	r30, r24
    26c2:	f0 e0       	ldi	r31, 0x00	; 0
    26c4:	ee 0f       	add	r30, r30
    26c6:	ff 1f       	adc	r31, r31
    26c8:	e2 5c       	subi	r30, 0xC2	; 194
    26ca:	f4 4f       	sbci	r31, 0xF4	; 244
    26cc:	85 91       	lpm	r24, Z+
    26ce:	94 91       	lpm	r25, Z+
    26d0:	61 e0       	ldi	r22, 0x01	; 1
}
    26d2:	6d cd       	rjmp	.-1318   	; 0x21ae <LCD_puts_f>

000026d4 <SelectSound>:

char SelectSound(char input)
{
    26d4:	1f 93       	push	r17
    26d6:	18 2f       	mov	r17, r24
    static char enter = 1;
    // mt static char song = 0;
    static uint8_t song = 0;
    
    
    if (enter)
    26d8:	80 91 44 01 	lds	r24, 0x0144
    26dc:	88 23       	and	r24, r24
    26de:	99 f0       	breq	.+38     	; 0x2706 <SelectSound+0x32>
    {
        enter = 0;
    26e0:	10 92 44 01 	sts	0x0144, r1
        
        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1);  // mt   // Set up the a song in the LCD
        showSongName(song);
    26e4:	80 91 62 01 	lds	r24, 0x0162
    26e8:	eb df       	rcall	.-42     	; 0x26c0 <showSongName>

        // mt pSong = Songs[song];            // point to this song             
        pSong=(int*)pgm_read_word(&Songs[song]); // looks too complicated...
    26ea:	80 91 62 01 	lds	r24, 0x0162
    26ee:	e8 2f       	mov	r30, r24
    26f0:	f0 e0       	ldi	r31, 0x00	; 0
    26f2:	ee 0f       	add	r30, r30
    26f4:	ff 1f       	adc	r31, r31
    26f6:	e4 5d       	subi	r30, 0xD4	; 212
    26f8:	f4 4f       	sbci	r31, 0xF4	; 244
    26fa:	85 91       	lpm	r24, Z+
    26fc:	94 91       	lpm	r25, Z+
    26fe:	90 93 a9 01 	sts	0x01A9, r25
    2702:	80 93 a8 01 	sts	0x01A8, r24

    }      
        
    if (input == KEY_PLUS)  // shift to next song
    2706:	14 30       	cpi	r17, 0x04	; 4
    2708:	41 f5       	brne	.+80     	; 0x275a <SelectSound+0x86>
    {
        if(!song)       // wrap around the table
    270a:	80 91 62 01 	lds	r24, 0x0162
    270e:	88 23       	and	r24, r24
    2710:	99 f4       	brne	.+38     	; 0x2738 <SelectSound+0x64>
    2712:	21 e0       	ldi	r18, 0x01	; 1
        {
            for(song=1; pgm_read_word(&TEXT_SONG_TBL[song]); song++){}; // mt
    2714:	e2 2f       	mov	r30, r18
    2716:	f0 e0       	ldi	r31, 0x00	; 0
    2718:	ee 0f       	add	r30, r30
    271a:	ff 1f       	adc	r31, r31
    271c:	e2 5c       	subi	r30, 0xC2	; 194
    271e:	f4 4f       	sbci	r31, 0xF4	; 244
    2720:	85 91       	lpm	r24, Z+
    2722:	94 91       	lpm	r25, Z+
    2724:	32 2f       	mov	r19, r18
    2726:	3f 5f       	subi	r19, 0xFF	; 255
    2728:	89 2b       	or	r24, r25
    272a:	11 f0       	breq	.+4      	; 0x2730 <SelectSound+0x5c>
    272c:	23 2f       	mov	r18, r19
    272e:	f2 cf       	rjmp	.-28     	; 0x2714 <SelectSound+0x40>
            
            song--;
    2730:	21 50       	subi	r18, 0x01	; 1
    2732:	20 93 62 01 	sts	0x0162, r18
    2736:	03 c0       	rjmp	.+6      	; 0x273e <SelectSound+0x6a>
        }    
        else
            song--;
    2738:	81 50       	subi	r24, 0x01	; 1
    273a:	80 93 62 01 	sts	0x0162, r24

        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1); // mt
        showSongName(song);
    273e:	80 91 62 01 	lds	r24, 0x0162
    2742:	be df       	rcall	.-132    	; 0x26c0 <showSongName>
        
        // mt pSong = Songs[song];
        pSong=(int*)pgm_read_word(&Songs[song]); 
    2744:	80 91 62 01 	lds	r24, 0x0162
    2748:	e8 2f       	mov	r30, r24
    274a:	f0 e0       	ldi	r31, 0x00	; 0
    274c:	ee 0f       	add	r30, r30
    274e:	ff 1f       	adc	r31, r31
    2750:	e4 5d       	subi	r30, 0xD4	; 212
    2752:	f4 4f       	sbci	r31, 0xF4	; 244
    2754:	85 91       	lpm	r24, Z+
    2756:	94 91       	lpm	r25, Z+
    2758:	20 c0       	rjmp	.+64     	; 0x279a <SelectSound+0xc6>

    }    
    else if (input == KEY_MINUS)    // shift to next song
    275a:	15 30       	cpi	r17, 0x05	; 5
    275c:	19 f5       	brne	.+70     	; 0x27a4 <SelectSound+0xd0>
    {
        song++;
    275e:	80 91 62 01 	lds	r24, 0x0162
    2762:	8f 5f       	subi	r24, 0xFF	; 255
    2764:	80 93 62 01 	sts	0x0162, r24

        if( !(pgm_read_word(&TEXT_SONG_TBL[song])) )       // wrap around the table
    2768:	e8 2f       	mov	r30, r24
    276a:	f0 e0       	ldi	r31, 0x00	; 0
    276c:	ee 0f       	add	r30, r30
    276e:	ff 1f       	adc	r31, r31
    2770:	e2 5c       	subi	r30, 0xC2	; 194
    2772:	f4 4f       	sbci	r31, 0xF4	; 244
    2774:	85 91       	lpm	r24, Z+
    2776:	94 91       	lpm	r25, Z+
    2778:	89 2b       	or	r24, r25
    277a:	11 f4       	brne	.+4      	; 0x2780 <SelectSound+0xac>
            song = 0;
    277c:	10 92 62 01 	sts	0x0162, r1
        
        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1);
        showSongName(song);
    2780:	80 91 62 01 	lds	r24, 0x0162
    2784:	9d df       	rcall	.-198    	; 0x26c0 <showSongName>
        
        // mt pSong = Songs[song];
        pSong=(int*)pgm_read_word(&Songs[song]);
    2786:	80 91 62 01 	lds	r24, 0x0162
    278a:	e8 2f       	mov	r30, r24
    278c:	f0 e0       	ldi	r31, 0x00	; 0
    278e:	ee 0f       	add	r30, r30
    2790:	ff 1f       	adc	r31, r31
    2792:	e4 5d       	subi	r30, 0xD4	; 212
    2794:	f4 4f       	sbci	r31, 0xF4	; 244
    2796:	85 91       	lpm	r24, Z+
    2798:	94 91       	lpm	r25, Z+
    279a:	90 93 a9 01 	sts	0x01A9, r25
    279e:	80 93 a8 01 	sts	0x01A8, r24
    27a2:	08 c0       	rjmp	.+16     	; 0x27b4 <SelectSound+0xe0>
    }  
    else if(input == KEY_ENTER)     // start playing
    27a4:	11 30       	cpi	r17, 0x01	; 1
    27a6:	21 f4       	brne	.+8      	; 0x27b0 <SelectSound+0xdc>
    {
        enter = 1;
    27a8:	10 93 44 01 	sts	0x0144, r17
    27ac:	8b e2       	ldi	r24, 0x2B	; 43
    27ae:	08 c0       	rjmp	.+16     	; 0x27c0 <SelectSound+0xec>
        return ST_MUSIC_PLAY;
    }
    else if (input == KEY_PREV)
    27b0:	13 30       	cpi	r17, 0x03	; 3
    27b2:	11 f0       	breq	.+4      	; 0x27b8 <SelectSound+0xe4>
    27b4:	8a e2       	ldi	r24, 0x2A	; 42
    27b6:	04 c0       	rjmp	.+8      	; 0x27c0 <SelectSound+0xec>
    {
        enter = 1;
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	80 93 44 01 	sts	0x0144, r24
    27be:	88 e2       	ldi	r24, 0x28	; 40
        return ST_MUSIC;
    }    
        
    return ST_MUSIC_SELECT;
}
    27c0:	1f 91       	pop	r17
    27c2:	08 95       	ret

000027c4 <Sound_Init>:
*   Purpose :       Set up Timer1 with PWM
*
*****************************************************************************/
void Sound_Init(void)
{
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    27c4:	80 e8       	ldi	r24, 0x80	; 128
    27c6:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM13);        // Phase/Freq-correct PWM, top value = ICR1
    27ca:	e1 e8       	ldi	r30, 0x81	; 129
    27cc:	f0 e0       	ldi	r31, 0x00	; 0
    27ce:	80 e1       	ldi	r24, 0x10	; 16
    27d0:	80 83       	st	Z, r24
    
    sbiBF(TCCR1B, CS10);             // start Timer1, prescaler(1)    
    27d2:	80 81       	ld	r24, Z
    27d4:	81 60       	ori	r24, 0x01	; 1
    27d6:	80 83       	st	Z, r24
    
    OCR1AH = 0;        // Set a initial value in the OCR1A-register
    27d8:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = Volume;   // This will adjust the volume on the buzzer, lower value => higher volume
    27dc:	80 91 42 01 	lds	r24, 0x0142
    27e0:	80 93 88 00 	sts	0x0088, r24
    
    Timer0_RegisterCallbackFunction(Play_Tune);     // Timer/Counter0 keeps the right beat
    27e4:	89 ed       	ldi	r24, 0xD9	; 217
    27e6:	92 e1       	ldi	r25, 0x12	; 18
    27e8:	0c 94 9b 08 	jmp	0x1136	; 0x1136 <Timer0_RegisterCallbackFunction>

000027ec <Sound>:
*
*   Purpose :       Start/stop timers, adjust volume 
*
*****************************************************************************/
char Sound(char input)
{
    27ec:	1f 93       	push	r17
    27ee:	18 2f       	mov	r17, r24
    static char enter = 1;

    if (enter)
    27f0:	80 91 43 01 	lds	r24, 0x0143
    27f4:	88 23       	and	r24, r24
    27f6:	69 f0       	breq	.+26     	; 0x2812 <Sound+0x26>
    {
        enter = 0;
    27f8:	10 92 43 01 	sts	0x0143, r1
        Tone = 0;
    27fc:	10 92 60 01 	sts	0x0160, r1
        Sound_Init();           // start playing
    2800:	e1 df       	rcall	.-62     	; 0x27c4 <Sound_Init>
        LCD_puts_f(PLAYING, 1);
    2802:	80 e5       	ldi	r24, 0x50	; 80
    2804:	9b e0       	ldi	r25, 0x0B	; 11
    2806:	61 e0       	ldi	r22, 0x01	; 1
    2808:	d2 dc       	rcall	.-1628   	; 0x21ae <LCD_puts_f>
        gPlaying = TRUE;
    280a:	81 e0       	ldi	r24, 0x01	; 1
    280c:	80 93 5f 01 	sts	0x015F, r24
    2810:	0d c0       	rjmp	.+26     	; 0x282c <Sound+0x40>
    }        
    else if (!gPlaying)
    2812:	80 91 5f 01 	lds	r24, 0x015F
    2816:	88 23       	and	r24, r24
    2818:	49 f4       	brne	.+18     	; 0x282c <Sound+0x40>
    {
        Timer0_RemoveCallbackFunction(Play_Tune);
    281a:	89 ed       	ldi	r24, 0xD9	; 217
    281c:	92 e1       	ldi	r25, 0x12	; 18
    281e:	0e 94 bf 08 	call	0x117e	; 0x117e <Timer0_RemoveCallbackFunction>
        TCCR1A = 0;
    2822:	10 92 80 00 	sts	0x0080, r1
        TCCR1B = 0;
    2826:	10 92 81 00 	sts	0x0081, r1
    282a:	55 c0       	rjmp	.+170    	; 0x28d6 <Sound+0xea>
        enter = 1;
        return ST_MUSIC_SELECT;
    }
    
    if (input == KEY_PLUS)          // increase the volum
    282c:	14 30       	cpi	r17, 0x04	; 4
    282e:	41 f4       	brne	.+16     	; 0x2840 <Sound+0x54>
    {
        if(Volume >= 80)
    2830:	80 91 42 01 	lds	r24, 0x0142
    2834:	80 35       	cpi	r24, 0x50	; 80
    2836:	10 f0       	brcs	.+4      	; 0x283c <Sound+0x50>
            Volume = 80;
    2838:	80 e5       	ldi	r24, 0x50	; 80
    283a:	0b c0       	rjmp	.+22     	; 0x2852 <Sound+0x66>
        else
            Volume += 5;
    283c:	8b 5f       	subi	r24, 0xFB	; 251
    283e:	09 c0       	rjmp	.+18     	; 0x2852 <Sound+0x66>

        OCR1AH = 0;
        OCR1AL = Volume;
    }
    else if (input == KEY_MINUS)    // decrease the volum
    2840:	15 30       	cpi	r17, 0x05	; 5
    2842:	81 f4       	brne	.+32     	; 0x2864 <Sound+0x78>
    {
        if(Volume < 11)
    2844:	80 91 42 01 	lds	r24, 0x0142
    2848:	8b 30       	cpi	r24, 0x0B	; 11
    284a:	10 f4       	brcc	.+4      	; 0x2850 <Sound+0x64>
            Volume = 6;
    284c:	86 e0       	ldi	r24, 0x06	; 6
    284e:	01 c0       	rjmp	.+2      	; 0x2852 <Sound+0x66>
        else
            Volume -= 5;   
    2850:	85 50       	subi	r24, 0x05	; 5
    2852:	80 93 42 01 	sts	0x0142, r24
        
        OCR1AH = 0;
    2856:	10 92 89 00 	sts	0x0089, r1
        OCR1AL = Volume;
    285a:	80 91 42 01 	lds	r24, 0x0142
    285e:	80 93 88 00 	sts	0x0088, r24
    2862:	27 c0       	rjmp	.+78     	; 0x28b2 <Sound+0xc6>
    }         
    
    if (input == KEY_ENTER)         // start/stop playing
    2864:	11 30       	cpi	r17, 0x01	; 1
    2866:	19 f5       	brne	.+70     	; 0x28ae <Sound+0xc2>
    {   
        if (gPlaying)
    2868:	80 91 5f 01 	lds	r24, 0x015F
    286c:	88 23       	and	r24, r24
    286e:	99 f0       	breq	.+38     	; 0x2896 <Sound+0xaa>
        {
            gPlaying = FALSE;
    2870:	10 92 5f 01 	sts	0x015F, r1
            cbiBF(TCCR1B, 0);                     // stop Playing
    2874:	80 91 81 00 	lds	r24, 0x0081
    2878:	8e 7f       	andi	r24, 0xFE	; 254
    287a:	80 93 81 00 	sts	0x0081, r24
            Timer0_RemoveCallbackFunction(Play_Tune);
    287e:	89 ed       	ldi	r24, 0xD9	; 217
    2880:	92 e1       	ldi	r25, 0x12	; 18
    2882:	0e 94 bf 08 	call	0x117e	; 0x117e <Timer0_RemoveCallbackFunction>
            TCCR1A = 0;
    2886:	10 92 80 00 	sts	0x0080, r1
            TCCR1B = 0;
    288a:	10 92 81 00 	sts	0x0081, r1
            sbiBF(PORTB, 5);              // set OC1A high
    288e:	2d 9a       	sbi	0x05, 5	; 5
            enter = 1;
    2890:	10 93 43 01 	sts	0x0143, r17
    2894:	23 c0       	rjmp	.+70     	; 0x28dc <Sound+0xf0>
            return ST_MUSIC_SELECT;
        }
        else
        {   
            Duration = 0;                       // start Playing
    2896:	10 92 61 01 	sts	0x0161, r1
            Tone = 1;
    289a:	10 93 60 01 	sts	0x0160, r17
            Sound_Init();
    289e:	92 df       	rcall	.-220    	; 0x27c4 <Sound_Init>
            LCD_puts_f(PLAYING, 1);            
    28a0:	80 e5       	ldi	r24, 0x50	; 80
    28a2:	9b e0       	ldi	r25, 0x0B	; 11
    28a4:	61 e0       	ldi	r22, 0x01	; 1
    28a6:	83 dc       	rcall	.-1786   	; 0x21ae <LCD_puts_f>
            gPlaying = TRUE;
    28a8:	10 93 5f 01 	sts	0x015F, r17
    28ac:	02 c0       	rjmp	.+4      	; 0x28b2 <Sound+0xc6>
        }
    }
    else if (input == KEY_PREV)
    28ae:	13 30       	cpi	r17, 0x03	; 3
    28b0:	11 f0       	breq	.+4      	; 0x28b6 <Sound+0xca>
    28b2:	8b e2       	ldi	r24, 0x2B	; 43
    28b4:	14 c0       	rjmp	.+40     	; 0x28de <Sound+0xf2>
    {
        gPlaying = FALSE;
    28b6:	10 92 5f 01 	sts	0x015F, r1
        cbiBF(TCCR1B, 0);                     // stop Playing
    28ba:	80 91 81 00 	lds	r24, 0x0081
    28be:	8e 7f       	andi	r24, 0xFE	; 254
    28c0:	80 93 81 00 	sts	0x0081, r24
        Timer0_RemoveCallbackFunction(Play_Tune);
    28c4:	89 ed       	ldi	r24, 0xD9	; 217
    28c6:	92 e1       	ldi	r25, 0x12	; 18
    28c8:	0e 94 bf 08 	call	0x117e	; 0x117e <Timer0_RemoveCallbackFunction>
        TCCR1A = 0;
    28cc:	10 92 80 00 	sts	0x0080, r1
        TCCR1B = 0;
    28d0:	10 92 81 00 	sts	0x0081, r1
        sbiBF(PORTB, 5);              // set OC1A high
    28d4:	2d 9a       	sbi	0x05, 5	; 5
        enter = 1;
    28d6:	81 e0       	ldi	r24, 0x01	; 1
    28d8:	80 93 43 01 	sts	0x0143, r24
    28dc:	8a e2       	ldi	r24, 0x2A	; 42
        return ST_MUSIC_SELECT;
    }
        
    return ST_MUSIC_PLAY;
}
    28de:	1f 91       	pop	r17
    28e0:	08 95       	ret

000028e2 <ErrorBeep>:
    // mtE
    while(1);                       //wait for WD-reset
}

void ErrorBeep(void)
{
    28e2:	8f 92       	push	r8
    28e4:	9f 92       	push	r9
    28e6:	bf 92       	push	r11
    28e8:	cf 92       	push	r12
    28ea:	df 92       	push	r13
    28ec:	ef 92       	push	r14
    28ee:	ff 92       	push	r15
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    28f4:	20 e8       	ldi	r18, 0x80	; 128
    28f6:	82 2e       	mov	r8, r18
    28f8:	91 2c       	mov	r9, r1
    28fa:	80 e8       	ldi	r24, 0x80	; 128
    28fc:	f4 01       	movw	r30, r8
    28fe:	80 83       	st	Z, r24
    TCCR1B = (1<<WGM13) | (1<<CS10);        // Phase/Freq-correct PWM, top value = ICR1
    2900:	01 e8       	ldi	r16, 0x81	; 129
    2902:	10 e0       	ldi	r17, 0x00	; 0
    2904:	81 e1       	ldi	r24, 0x11	; 17
    2906:	f8 01       	movw	r30, r16
    2908:	80 83       	st	Z, r24
    
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    290a:	80 81       	ld	r24, Z
    290c:	81 60       	ori	r24, 0x01	; 1
    290e:	80 83       	st	Z, r24
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    2910:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume
    2914:	80 e5       	ldi	r24, 0x50	; 80
    2916:	80 93 88 00 	sts	0x0088, r24
    
    ICR1H = 1;
    291a:	97 e8       	ldi	r25, 0x87	; 135
    291c:	c9 2e       	mov	r12, r25
    291e:	d1 2c       	mov	r13, r1
    2920:	bb 24       	eor	r11, r11
    2922:	b3 94       	inc	r11
    2924:	f6 01       	movw	r30, r12
    2926:	b0 82       	st	Z, r11
    ICR1L = 0x3F;
    2928:	86 e8       	ldi	r24, 0x86	; 134
    292a:	e8 2e       	mov	r14, r24
    292c:	f1 2c       	mov	r15, r1
    292e:	8f e3       	ldi	r24, 0x3F	; 63
    2930:	f7 01       	movw	r30, r14
    2932:	80 83       	st	Z, r24

    Delay(50);
    2934:	82 e3       	ldi	r24, 0x32	; 50
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>

    ICR1H = 1;
    293c:	f6 01       	movw	r30, r12
    293e:	b0 82       	st	Z, r11
    ICR1L = 0xDE;
    2940:	8e ed       	ldi	r24, 0xDE	; 222
    2942:	f7 01       	movw	r30, r14
    2944:	80 83       	st	Z, r24

    Delay(300);
    2946:	8c e2       	ldi	r24, 0x2C	; 44
    2948:	91 e0       	ldi	r25, 0x01	; 1
    294a:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>
    
    TCCR1A = 0;
    294e:	f4 01       	movw	r30, r8
    2950:	10 82       	st	Z, r1
    TCCR1B = 0;
    2952:	f8 01       	movw	r30, r16
    2954:	10 82       	st	Z, r1
}
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	ff 90       	pop	r15
    295c:	ef 90       	pop	r14
    295e:	df 90       	pop	r13
    2960:	cf 90       	pop	r12
    2962:	bf 90       	pop	r11
    2964:	9f 90       	pop	r9
    2966:	8f 90       	pop	r8
    2968:	08 95       	ret

0000296a <TestWaitEnter>:
static void TestWaitEnter(void)
{
    char input = 0;
    while(input != KEY_ENTER)
    {
        input = getkey();           // Read buttons
    296a:	86 db       	rcall	.-2292   	; 0x2078 <getkey>

// mtA
static void TestWaitEnter(void)
{
    char input = 0;
    while(input != KEY_ENTER)
    296c:	81 30       	cpi	r24, 0x01	; 1
    296e:	e9 f7       	brne	.-6      	; 0x296a <TestWaitEnter>
    {
        input = getkey();           // Read buttons
    }
}
    2970:	08 95       	ret

00002972 <Test>:
// mtE

void Test(void)
{
    2972:	1f 93       	push	r17
    2974:	cf 93       	push	r28
    2976:	df 93       	push	r29
    char j;
    
    int integer;
    int temp_hi;
    
    TIMSK2 = 0; // Stop clock, the interrupt will disturb the sound-test cause
    2978:	10 92 70 00 	sts	0x0070, r1
                // the play-routine doesn't use interrupt...

//mtA    
    LCD_puts_f(PSTR("Test"),0); // mt LCD_puts("Test",0);
    297c:	80 eb       	ldi	r24, 0xB0	; 176
    297e:	9b e0       	ldi	r25, 0x0B	; 11
    2980:	60 e0       	ldi	r22, 0x00	; 0
    2982:	15 dc       	rcall	.-2006   	; 0x21ae <LCD_puts_f>
    TestWaitEnter();
    2984:	f2 df       	rcall	.-28     	; 0x296a <TestWaitEnter>
//mtE


//// //// //// //// JOYSTICK TEST //// //// //// ////

    LCD_puts_f(PSTR("Left"),0);// mt LCD_puts("Left",0);
    2986:	8b ea       	ldi	r24, 0xAB	; 171
    2988:	9b e0       	ldi	r25, 0x0B	; 11
    298a:	60 e0       	ldi	r22, 0x00	; 0
    298c:	10 dc       	rcall	.-2016   	; 0x21ae <LCD_puts_f>
    
    while(input != KEY_PREV)
    {
        input = getkey();           // Read buttons
    298e:	74 db       	rcall	.-2328   	; 0x2078 <getkey>

//// //// //// //// JOYSTICK TEST //// //// //// ////

    LCD_puts_f(PSTR("Left"),0);// mt LCD_puts("Left",0);
    
    while(input != KEY_PREV)
    2990:	83 30       	cpi	r24, 0x03	; 3
    2992:	e9 f7       	brne	.-6      	; 0x298e <Test+0x1c>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Up"),0);// mt LCD_puts("Up",0);
    2994:	88 ea       	ldi	r24, 0xA8	; 168
    2996:	9b e0       	ldi	r25, 0x0B	; 11
    2998:	60 e0       	ldi	r22, 0x00	; 0
    299a:	09 dc       	rcall	.-2030   	; 0x21ae <LCD_puts_f>
    
    while(input != KEY_PLUS)
    {
        input = getkey();           // Read buttons
    299c:	6d db       	rcall	.-2342   	; 0x2078 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Up"),0);// mt LCD_puts("Up",0);
    
    while(input != KEY_PLUS)
    299e:	84 30       	cpi	r24, 0x04	; 4
    29a0:	e9 f7       	brne	.-6      	; 0x299c <Test+0x2a>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Right"),0);// mt LCD_puts("Right",0);
    29a2:	82 ea       	ldi	r24, 0xA2	; 162
    29a4:	9b e0       	ldi	r25, 0x0B	; 11
    29a6:	60 e0       	ldi	r22, 0x00	; 0
    29a8:	02 dc       	rcall	.-2044   	; 0x21ae <LCD_puts_f>
    
    while(input != KEY_NEXT)
    {
        input = getkey();           // Read buttons
    29aa:	66 db       	rcall	.-2356   	; 0x2078 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Right"),0);// mt LCD_puts("Right",0);
    
    while(input != KEY_NEXT)
    29ac:	82 30       	cpi	r24, 0x02	; 2
    29ae:	e9 f7       	brne	.-6      	; 0x29aa <Test+0x38>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Down"),0);// mt LCD_puts("Down",0);
    29b0:	8d e9       	ldi	r24, 0x9D	; 157
    29b2:	9b e0       	ldi	r25, 0x0B	; 11
    29b4:	60 e0       	ldi	r22, 0x00	; 0
    29b6:	fb db       	rcall	.-2058   	; 0x21ae <LCD_puts_f>
    
    while(input != KEY_MINUS)
    {
        input = getkey();           // Read buttons
    29b8:	5f db       	rcall	.-2370   	; 0x2078 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Down"),0);// mt LCD_puts("Down",0);
    
    while(input != KEY_MINUS)
    29ba:	85 30       	cpi	r24, 0x05	; 5
    29bc:	e9 f7       	brne	.-6      	; 0x29b8 <Test+0x46>



//// //// //// //// SOUND TEST //// //// //// ////
    
    LCD_puts_f(PSTR("Sound"),0);// mt LCD_puts("Sound",0);
    29be:	87 e9       	ldi	r24, 0x97	; 151
    29c0:	9b e0       	ldi	r25, 0x0B	; 11
    29c2:	60 e0       	ldi	r22, 0x00	; 0
    29c4:	f4 db       	rcall	.-2072   	; 0x21ae <LCD_puts_f>
    TestWaitEnter();
    29c6:	d1 df       	rcall	.-94     	; 0x296a <TestWaitEnter>
    
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    29c8:	80 e8       	ldi	r24, 0x80	; 128
    29ca:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM13) | (1<<CS10);        // Phase/Freq-correct PWM, top value = ICR1
    29ce:	81 e1       	ldi	r24, 0x11	; 17
    29d0:	80 93 81 00 	sts	0x0081, r24
    
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    29d4:	80 91 81 00 	lds	r24, 0x0081
    29d8:	81 60       	ori	r24, 0x01	; 1
    29da:	80 93 81 00 	sts	0x0081, r24
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    29de:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume
    29e2:	80 e5       	ldi	r24, 0x50	; 80
    29e4:	80 93 88 00 	sts	0x0088, r24
    29e8:	18 ec       	ldi	r17, 0xC8	; 200

    for(integer = 200; integer >= 100; integer -= 5)
    {
        temp_hi = integer;
        
        ICR1H = (temp_hi >>= 8);
    29ea:	10 92 87 00 	sts	0x0087, r1
        ICR1L = integer;
    29ee:	10 93 86 00 	sts	0x0086, r17
    
        Delay(30);
    29f2:	8e e1       	ldi	r24, 0x1E	; 30
    29f4:	90 e0       	ldi	r25, 0x00	; 0
    29f6:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>
    29fa:	15 50       	subi	r17, 0x05	; 5
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume

    for(integer = 200; integer >= 100; integer -= 5)
    29fc:	1f 35       	cpi	r17, 0x5F	; 95
    29fe:	a9 f7       	brne	.-22     	; 0x29ea <Test+0x78>
    
        Delay(30);
    }


    TCCR1A = 0;
    2a00:	10 92 80 00 	sts	0x0080, r1
    TCCR1B = 0;     //Stop timer1
    2a04:	10 92 81 00 	sts	0x0081, r1


//// //// //// //// LCD TEST //// //// //// ////    
    
    LCD_puts_f(PSTR("LCD test"),0);// mt LCD_puts("LCD test",0);
    2a08:	8e e8       	ldi	r24, 0x8E	; 142
    2a0a:	9b e0       	ldi	r25, 0x0B	; 11
    2a0c:	60 e0       	ldi	r22, 0x00	; 0
    2a0e:	cf db       	rcall	.-2146   	; 0x21ae <LCD_puts_f>

    //mtA
    // mt while(!(PINB & (1<<PORTB4)));
    while(!(PINB & (1<<PINB4)));
    2a10:	1c 9b       	sbis	0x03, 4	; 3
    2a12:	fe cf       	rjmp	.-4      	; 0x2a10 <Test+0x9e>
    TestWaitEnter();
    2a14:	aa df       	rcall	.-172    	; 0x296a <TestWaitEnter>
    //mtE
    
    cbiBF(LCDCRA, LCDIE);
    2a16:	80 91 e4 00 	lds	r24, 0x00E4
    2a1a:	87 7f       	andi	r24, 0xF7	; 247
    2a1c:	80 93 e4 00 	sts	0x00E4, r24
    2a20:	ec ee       	ldi	r30, 0xEC	; 236
    2a22:	f0 e0       	ldi	r31, 0x00	; 0
    
    for(i = 0; i < 20; i++) // set all LCD segment register to the variable ucSegments
    {
        *(&pLCDREG_test + i) = 0xFF;
    2a24:	8f ef       	ldi	r24, 0xFF	; 255
    2a26:	81 93       	st	Z+, r24
    TestWaitEnter();
    //mtE
    
    cbiBF(LCDCRA, LCDIE);
    
    for(i = 0; i < 20; i++) // set all LCD segment register to the variable ucSegments
    2a28:	91 e0       	ldi	r25, 0x01	; 1
    2a2a:	e0 30       	cpi	r30, 0x00	; 0
    2a2c:	f9 07       	cpc	r31, r25
    2a2e:	d9 f7       	brne	.-10     	; 0x2a26 <Test+0xb4>
    {
        *(&pLCDREG_test + i) = 0xFF;
    }
    
    // mt while(!(PINB & (1<<PORTB4)));
    while(!(PINB & (1<<PINB4)));
    2a30:	1c 9b       	sbis	0x03, 4	; 3
    2a32:	fe cf       	rjmp	.-4      	; 0x2a30 <Test+0xbe>
    
    Delay(100);
    2a34:	84 e6       	ldi	r24, 0x64	; 100
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	0e 94 18 06 	call	0xc30	; 0xc30 <Delay>

    // mt while((PINB & (1<<PORTB4)));    //pull PINB cause the LCD interrupt is disabled which 
    while((PINB & (1<<PINB4)));    //pull PINB cause the LCD interrupt is disabled which
    2a3c:	1c 99       	sbic	0x03, 4	; 3
    2a3e:	fe cf       	rjmp	.-4      	; 0x2a3c <Test+0xca>
                                   //controls the button-bouncing
    sbiBF(LCDCRA, LCDIE);
    2a40:	80 91 e4 00 	lds	r24, 0x00E4
    2a44:	88 60       	ori	r24, 0x08	; 8
    2a46:	80 93 e4 00 	sts	0x00E4, r24


//// //// //// //// TEMPERATURE TEST //// //// //// ////
      
    ADC_init(0);
    2a4a:	80 e0       	ldi	r24, 0x00	; 0
    2a4c:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <ADC_init>

    integer = ADC_read();
    2a50:	0e 94 23 09 	call	0x1246	; 0x1246 <ADC_read>
    
    //check if temperature is between 21 and 30 degree Celcius
    if( (integer < 452) || (integer > 586) )  
    2a54:	84 5c       	subi	r24, 0xC4	; 196
    2a56:	91 40       	sbci	r25, 0x01	; 1
    2a58:	87 38       	cpi	r24, 0x87	; 135
    2a5a:	91 05       	cpc	r25, r1
    2a5c:	60 f0       	brcs	.+24     	; 0x2a76 <Test+0x104>
    {
        LCD_puts_f(PSTR("Error Temperature"),0);// mt LCD_puts("Error Temperature",0);
    2a5e:	8c e7       	ldi	r24, 0x7C	; 124
    2a60:	9b e0       	ldi	r25, 0x0B	; 11
    2a62:	60 e0       	ldi	r22, 0x00	; 0
    2a64:	a4 db       	rcall	.-2232   	; 0x21ae <LCD_puts_f>
        ErrorBeep();
    2a66:	3d df       	rcall	.-390    	; 0x28e2 <ErrorBeep>
        TestWaitEnter();
    2a68:	80 df       	rcall	.-256    	; 0x296a <TestWaitEnter>
        ADC_periphery();
    2a6a:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_periphery>
        LCD_UpdateRequired(TRUE, 0);
    2a6e:	81 e0       	ldi	r24, 0x01	; 1
    2a70:	60 e0       	ldi	r22, 0x00	; 0
    2a72:	e6 db       	rcall	.-2100   	; 0x2240 <LCD_UpdateRequired>
        TestWaitEnter();
    2a74:	7a df       	rcall	.-268    	; 0x296a <TestWaitEnter>
    }


//// //// //// //// Voltage TEST //// //// //// ////    

    ADC_init(1);
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <ADC_init>
    integer = ADC_read();
    2a7c:	0e 94 23 09 	call	0x1246	; 0x1246 <ADC_read>

    //if measuring outside 4,8 to 5,2 V
    if( (integer < 298) || (integer > 320) )
    2a80:	8a 52       	subi	r24, 0x2A	; 42
    2a82:	91 40       	sbci	r25, 0x01	; 1
    2a84:	47 97       	sbiw	r24, 0x17	; 23
    2a86:	60 f0       	brcs	.+24     	; 0x2aa0 <Test+0x12e>
    {
        LCD_puts_f(PSTR("Error Voltage"),0);// mt LCD_puts("Error Voltage",0);
    2a88:	8e e6       	ldi	r24, 0x6E	; 110
    2a8a:	9b e0       	ldi	r25, 0x0B	; 11
    2a8c:	60 e0       	ldi	r22, 0x00	; 0
    2a8e:	8f db       	rcall	.-2274   	; 0x21ae <LCD_puts_f>
        ErrorBeep();
    2a90:	28 df       	rcall	.-432    	; 0x28e2 <ErrorBeep>
        TestWaitEnter();
    2a92:	6b df       	rcall	.-298    	; 0x296a <TestWaitEnter>
        ADC_periphery();
    2a94:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_periphery>
        LCD_UpdateRequired(TRUE, 0);
    2a98:	81 e0       	ldi	r24, 0x01	; 1
    2a9a:	60 e0       	ldi	r22, 0x00	; 0
    2a9c:	d1 db       	rcall	.-2142   	; 0x2240 <LCD_UpdateRequired>
        TestWaitEnter();
    2a9e:	65 df       	rcall	.-310    	; 0x296a <TestWaitEnter>
    }


//// //// //// //// LIGHT TEST //// //// //// ////    

    LCD_puts_f(PSTR("Light"),0);// mt LCD_puts("Light",0);
    2aa0:	88 e6       	ldi	r24, 0x68	; 104
    2aa2:	9b e0       	ldi	r25, 0x0B	; 11
    2aa4:	60 e0       	ldi	r22, 0x00	; 0
    2aa6:	83 db       	rcall	.-2298   	; 0x21ae <LCD_puts_f>
    TestWaitEnter();
    2aa8:	60 df       	rcall	.-320    	; 0x296a <TestWaitEnter>

    ADC_init(2);
    2aaa:	82 e0       	ldi	r24, 0x02	; 2
    2aac:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <ADC_init>
    input = 0;
    
    while(input != KEY_ENTER)
    {
        ADC_read();
    2ab0:	0e 94 23 09 	call	0x1246	; 0x1246 <ADC_read>
        ADC_periphery();
    2ab4:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_periphery>
        // mt __no_operation();
        asm volatile ("nop"::);
    2ab8:	00 00       	nop
        LCD_UpdateRequired(TRUE, 0);    
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	60 e0       	ldi	r22, 0x00	; 0
    2abe:	c0 db       	rcall	.-2176   	; 0x2240 <LCD_UpdateRequired>
        input = getkey();           // Read buttons
    2ac0:	db da       	rcall	.-2634   	; 0x2078 <getkey>
    TestWaitEnter();

    ADC_init(2);
    input = 0;
    
    while(input != KEY_ENTER)
    2ac2:	81 30       	cpi	r24, 0x01	; 1
    2ac4:	a9 f7       	brne	.-22     	; 0x2ab0 <Test+0x13e>
        LCD_UpdateRequired(TRUE, 0);    
        input = getkey();           // Read buttons
    }


    DF_CS_inactive;
    2ac6:	28 9a       	sbi	0x05, 0	; 5
    DF_CS_active;
    2ac8:	28 98       	cbi	0x05, 0	; 5
    2aca:	c0 e0       	ldi	r28, 0x00	; 0
    2acc:	d0 e0       	ldi	r29, 0x00	; 0
    
    for(j=0;j<50;j++) {
        Buffer_Write_Byte (1,j,j);
    2ace:	81 e0       	ldi	r24, 0x01	; 1
    2ad0:	be 01       	movw	r22, r28
    2ad2:	4c 2f       	mov	r20, r28
    2ad4:	58 da       	rcall	.-2896   	; 0x1f86 <Buffer_Write_Byte>
    2ad6:	21 96       	adiw	r28, 0x01	; 1


    DF_CS_inactive;
    DF_CS_active;
    
    for(j=0;j<50;j++) {
    2ad8:	c2 33       	cpi	r28, 0x32	; 50
    2ada:	d1 05       	cpc	r29, r1
    2adc:	c1 f7       	brne	.-16     	; 0x2ace <Test+0x15c>
        Buffer_Write_Byte (1,j,j);
    }

    Buffer_To_Page (1,1);             //transfer to DataFlash
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	61 e0       	ldi	r22, 0x01	; 1
    2ae2:	70 e0       	ldi	r23, 0x00	; 0
    2ae4:	68 da       	rcall	.-2864   	; 0x1fb6 <Buffer_To_Page>

    DF_CS_inactive;
    2ae6:	28 9a       	sbi	0x05, 0	; 5
    DF_CS_active;
    2ae8:	28 98       	cbi	0x05, 0	; 5
    
    Cont_Flash_Read_Enable (1,0);
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	60 e0       	ldi	r22, 0x00	; 0
    2af0:	70 e0       	ldi	r23, 0x00	; 0
    2af2:	8d da       	rcall	.-2790   	; 0x200e <Cont_Flash_Read_Enable>
    2af4:	10 e0       	ldi	r17, 0x00	; 0

    for(j=0;j<50;j++)
    {
        
        if(j != DF_SPI_RW(0x00) )
    2af6:	80 e0       	ldi	r24, 0x00	; 0
    2af8:	1f da       	rcall	.-3010   	; 0x1f38 <DF_SPI_RW>
    2afa:	18 17       	cp	r17, r24
    2afc:	39 f0       	breq	.+14     	; 0x2b0c <Test+0x19a>
        {
            LCD_puts_f(PSTR("Error DataFlash"),0);// mt LCD_puts("Error Dataflash",0);
    2afe:	88 e5       	ldi	r24, 0x58	; 88
    2b00:	9b e0       	ldi	r25, 0x0B	; 11
    2b02:	60 e0       	ldi	r22, 0x00	; 0
    2b04:	54 db       	rcall	.-2392   	; 0x21ae <LCD_puts_f>
            ErrorBeep();
    2b06:	ed de       	rcall	.-550    	; 0x28e2 <ErrorBeep>
            TestWaitEnter();
    2b08:	30 df       	rcall	.-416    	; 0x296a <TestWaitEnter>
    2b0a:	03 c0       	rjmp	.+6      	; 0x2b12 <Test+0x1a0>
    DF_CS_inactive;
    DF_CS_active;
    
    Cont_Flash_Read_Enable (1,0);

    for(j=0;j<50;j++)
    2b0c:	1f 5f       	subi	r17, 0xFF	; 255
    2b0e:	12 33       	cpi	r17, 0x32	; 50
    2b10:	91 f7       	brne	.-28     	; 0x2af6 <Test+0x184>
            TestWaitEnter();
            break;
        }
    }

    DF_CS_inactive;
    2b12:	28 9a       	sbi	0x05, 0	; 5


//// //// //// //// RESET //// //// //// ////


    WDTCR = (1<<WDCE) | (1<<WDE);   //Enable Watchdog Timer to give reset
    2b14:	88 e1       	ldi	r24, 0x18	; 24
    2b16:	80 93 60 00 	sts	0x0060, r24
    2b1a:	ff cf       	rjmp	.-2      	; 0x2b1a <Test+0x1a8>

00002b1c <__subsf3>:
    2b1c:	50 58       	subi	r21, 0x80	; 128

00002b1e <__addsf3>:
    2b1e:	bb 27       	eor	r27, r27
    2b20:	aa 27       	eor	r26, r26
    2b22:	0e d0       	rcall	.+28     	; 0x2b40 <__addsf3x>
    2b24:	e0 c0       	rjmp	.+448    	; 0x2ce6 <__fp_round>
    2b26:	d1 d0       	rcall	.+418    	; 0x2cca <__fp_pscA>
    2b28:	30 f0       	brcs	.+12     	; 0x2b36 <__addsf3+0x18>
    2b2a:	d6 d0       	rcall	.+428    	; 0x2cd8 <__fp_pscB>
    2b2c:	20 f0       	brcs	.+8      	; 0x2b36 <__addsf3+0x18>
    2b2e:	31 f4       	brne	.+12     	; 0x2b3c <__addsf3+0x1e>
    2b30:	9f 3f       	cpi	r25, 0xFF	; 255
    2b32:	11 f4       	brne	.+4      	; 0x2b38 <__addsf3+0x1a>
    2b34:	1e f4       	brtc	.+6      	; 0x2b3c <__addsf3+0x1e>
    2b36:	c6 c0       	rjmp	.+396    	; 0x2cc4 <__fp_nan>
    2b38:	0e f4       	brtc	.+2      	; 0x2b3c <__addsf3+0x1e>
    2b3a:	e0 95       	com	r30
    2b3c:	e7 fb       	bst	r30, 7
    2b3e:	bc c0       	rjmp	.+376    	; 0x2cb8 <__fp_inf>

00002b40 <__addsf3x>:
    2b40:	e9 2f       	mov	r30, r25
    2b42:	e2 d0       	rcall	.+452    	; 0x2d08 <__fp_split3>
    2b44:	80 f3       	brcs	.-32     	; 0x2b26 <__addsf3+0x8>
    2b46:	ba 17       	cp	r27, r26
    2b48:	62 07       	cpc	r22, r18
    2b4a:	73 07       	cpc	r23, r19
    2b4c:	84 07       	cpc	r24, r20
    2b4e:	95 07       	cpc	r25, r21
    2b50:	18 f0       	brcs	.+6      	; 0x2b58 <__addsf3x+0x18>
    2b52:	71 f4       	brne	.+28     	; 0x2b70 <__addsf3x+0x30>
    2b54:	9e f5       	brtc	.+102    	; 0x2bbc <__addsf3x+0x7c>
    2b56:	fa c0       	rjmp	.+500    	; 0x2d4c <__fp_zero>
    2b58:	0e f4       	brtc	.+2      	; 0x2b5c <__addsf3x+0x1c>
    2b5a:	e0 95       	com	r30
    2b5c:	0b 2e       	mov	r0, r27
    2b5e:	ba 2f       	mov	r27, r26
    2b60:	a0 2d       	mov	r26, r0
    2b62:	0b 01       	movw	r0, r22
    2b64:	b9 01       	movw	r22, r18
    2b66:	90 01       	movw	r18, r0
    2b68:	0c 01       	movw	r0, r24
    2b6a:	ca 01       	movw	r24, r20
    2b6c:	a0 01       	movw	r20, r0
    2b6e:	11 24       	eor	r1, r1
    2b70:	ff 27       	eor	r31, r31
    2b72:	59 1b       	sub	r21, r25
    2b74:	99 f0       	breq	.+38     	; 0x2b9c <__addsf3x+0x5c>
    2b76:	59 3f       	cpi	r21, 0xF9	; 249
    2b78:	50 f4       	brcc	.+20     	; 0x2b8e <__addsf3x+0x4e>
    2b7a:	50 3e       	cpi	r21, 0xE0	; 224
    2b7c:	68 f1       	brcs	.+90     	; 0x2bd8 <__addsf3x+0x98>
    2b7e:	1a 16       	cp	r1, r26
    2b80:	f0 40       	sbci	r31, 0x00	; 0
    2b82:	a2 2f       	mov	r26, r18
    2b84:	23 2f       	mov	r18, r19
    2b86:	34 2f       	mov	r19, r20
    2b88:	44 27       	eor	r20, r20
    2b8a:	58 5f       	subi	r21, 0xF8	; 248
    2b8c:	f3 cf       	rjmp	.-26     	; 0x2b74 <__addsf3x+0x34>
    2b8e:	46 95       	lsr	r20
    2b90:	37 95       	ror	r19
    2b92:	27 95       	ror	r18
    2b94:	a7 95       	ror	r26
    2b96:	f0 40       	sbci	r31, 0x00	; 0
    2b98:	53 95       	inc	r21
    2b9a:	c9 f7       	brne	.-14     	; 0x2b8e <__addsf3x+0x4e>
    2b9c:	7e f4       	brtc	.+30     	; 0x2bbc <__addsf3x+0x7c>
    2b9e:	1f 16       	cp	r1, r31
    2ba0:	ba 0b       	sbc	r27, r26
    2ba2:	62 0b       	sbc	r22, r18
    2ba4:	73 0b       	sbc	r23, r19
    2ba6:	84 0b       	sbc	r24, r20
    2ba8:	ba f0       	brmi	.+46     	; 0x2bd8 <__addsf3x+0x98>
    2baa:	91 50       	subi	r25, 0x01	; 1
    2bac:	a1 f0       	breq	.+40     	; 0x2bd6 <__addsf3x+0x96>
    2bae:	ff 0f       	add	r31, r31
    2bb0:	bb 1f       	adc	r27, r27
    2bb2:	66 1f       	adc	r22, r22
    2bb4:	77 1f       	adc	r23, r23
    2bb6:	88 1f       	adc	r24, r24
    2bb8:	c2 f7       	brpl	.-16     	; 0x2baa <__addsf3x+0x6a>
    2bba:	0e c0       	rjmp	.+28     	; 0x2bd8 <__addsf3x+0x98>
    2bbc:	ba 0f       	add	r27, r26
    2bbe:	62 1f       	adc	r22, r18
    2bc0:	73 1f       	adc	r23, r19
    2bc2:	84 1f       	adc	r24, r20
    2bc4:	48 f4       	brcc	.+18     	; 0x2bd8 <__addsf3x+0x98>
    2bc6:	87 95       	ror	r24
    2bc8:	77 95       	ror	r23
    2bca:	67 95       	ror	r22
    2bcc:	b7 95       	ror	r27
    2bce:	f7 95       	ror	r31
    2bd0:	9e 3f       	cpi	r25, 0xFE	; 254
    2bd2:	08 f0       	brcs	.+2      	; 0x2bd6 <__addsf3x+0x96>
    2bd4:	b3 cf       	rjmp	.-154    	; 0x2b3c <__addsf3+0x1e>
    2bd6:	93 95       	inc	r25
    2bd8:	88 0f       	add	r24, r24
    2bda:	08 f0       	brcs	.+2      	; 0x2bde <__addsf3x+0x9e>
    2bdc:	99 27       	eor	r25, r25
    2bde:	ee 0f       	add	r30, r30
    2be0:	97 95       	ror	r25
    2be2:	87 95       	ror	r24
    2be4:	08 95       	ret

00002be6 <__fixunssfsi>:
    2be6:	98 d0       	rcall	.+304    	; 0x2d18 <__fp_splitA>
    2be8:	88 f0       	brcs	.+34     	; 0x2c0c <__fixunssfsi+0x26>
    2bea:	9f 57       	subi	r25, 0x7F	; 127
    2bec:	90 f0       	brcs	.+36     	; 0x2c12 <__fixunssfsi+0x2c>
    2bee:	b9 2f       	mov	r27, r25
    2bf0:	99 27       	eor	r25, r25
    2bf2:	b7 51       	subi	r27, 0x17	; 23
    2bf4:	a0 f0       	brcs	.+40     	; 0x2c1e <__fixunssfsi+0x38>
    2bf6:	d1 f0       	breq	.+52     	; 0x2c2c <__fixunssfsi+0x46>
    2bf8:	66 0f       	add	r22, r22
    2bfa:	77 1f       	adc	r23, r23
    2bfc:	88 1f       	adc	r24, r24
    2bfe:	99 1f       	adc	r25, r25
    2c00:	1a f0       	brmi	.+6      	; 0x2c08 <__fixunssfsi+0x22>
    2c02:	ba 95       	dec	r27
    2c04:	c9 f7       	brne	.-14     	; 0x2bf8 <__fixunssfsi+0x12>
    2c06:	12 c0       	rjmp	.+36     	; 0x2c2c <__fixunssfsi+0x46>
    2c08:	b1 30       	cpi	r27, 0x01	; 1
    2c0a:	81 f0       	breq	.+32     	; 0x2c2c <__fixunssfsi+0x46>
    2c0c:	9f d0       	rcall	.+318    	; 0x2d4c <__fp_zero>
    2c0e:	b1 e0       	ldi	r27, 0x01	; 1
    2c10:	08 95       	ret
    2c12:	9c c0       	rjmp	.+312    	; 0x2d4c <__fp_zero>
    2c14:	67 2f       	mov	r22, r23
    2c16:	78 2f       	mov	r23, r24
    2c18:	88 27       	eor	r24, r24
    2c1a:	b8 5f       	subi	r27, 0xF8	; 248
    2c1c:	39 f0       	breq	.+14     	; 0x2c2c <__fixunssfsi+0x46>
    2c1e:	b9 3f       	cpi	r27, 0xF9	; 249
    2c20:	cc f3       	brlt	.-14     	; 0x2c14 <__fixunssfsi+0x2e>
    2c22:	86 95       	lsr	r24
    2c24:	77 95       	ror	r23
    2c26:	67 95       	ror	r22
    2c28:	b3 95       	inc	r27
    2c2a:	d9 f7       	brne	.-10     	; 0x2c22 <__fixunssfsi+0x3c>
    2c2c:	3e f4       	brtc	.+14     	; 0x2c3c <__fixunssfsi+0x56>
    2c2e:	90 95       	com	r25
    2c30:	80 95       	com	r24
    2c32:	70 95       	com	r23
    2c34:	61 95       	neg	r22
    2c36:	7f 4f       	sbci	r23, 0xFF	; 255
    2c38:	8f 4f       	sbci	r24, 0xFF	; 255
    2c3a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c3c:	08 95       	ret

00002c3e <__floatunsisf>:
    2c3e:	e8 94       	clt
    2c40:	09 c0       	rjmp	.+18     	; 0x2c54 <__floatsisf+0x12>

00002c42 <__floatsisf>:
    2c42:	97 fb       	bst	r25, 7
    2c44:	3e f4       	brtc	.+14     	; 0x2c54 <__floatsisf+0x12>
    2c46:	90 95       	com	r25
    2c48:	80 95       	com	r24
    2c4a:	70 95       	com	r23
    2c4c:	61 95       	neg	r22
    2c4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c50:	8f 4f       	sbci	r24, 0xFF	; 255
    2c52:	9f 4f       	sbci	r25, 0xFF	; 255
    2c54:	99 23       	and	r25, r25
    2c56:	a9 f0       	breq	.+42     	; 0x2c82 <__floatsisf+0x40>
    2c58:	f9 2f       	mov	r31, r25
    2c5a:	96 e9       	ldi	r25, 0x96	; 150
    2c5c:	bb 27       	eor	r27, r27
    2c5e:	93 95       	inc	r25
    2c60:	f6 95       	lsr	r31
    2c62:	87 95       	ror	r24
    2c64:	77 95       	ror	r23
    2c66:	67 95       	ror	r22
    2c68:	b7 95       	ror	r27
    2c6a:	f1 11       	cpse	r31, r1
    2c6c:	f8 cf       	rjmp	.-16     	; 0x2c5e <__floatsisf+0x1c>
    2c6e:	fa f4       	brpl	.+62     	; 0x2cae <__floatsisf+0x6c>
    2c70:	bb 0f       	add	r27, r27
    2c72:	11 f4       	brne	.+4      	; 0x2c78 <__floatsisf+0x36>
    2c74:	60 ff       	sbrs	r22, 0
    2c76:	1b c0       	rjmp	.+54     	; 0x2cae <__floatsisf+0x6c>
    2c78:	6f 5f       	subi	r22, 0xFF	; 255
    2c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7c:	8f 4f       	sbci	r24, 0xFF	; 255
    2c7e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c80:	16 c0       	rjmp	.+44     	; 0x2cae <__floatsisf+0x6c>
    2c82:	88 23       	and	r24, r24
    2c84:	11 f0       	breq	.+4      	; 0x2c8a <__floatsisf+0x48>
    2c86:	96 e9       	ldi	r25, 0x96	; 150
    2c88:	11 c0       	rjmp	.+34     	; 0x2cac <__floatsisf+0x6a>
    2c8a:	77 23       	and	r23, r23
    2c8c:	21 f0       	breq	.+8      	; 0x2c96 <__floatsisf+0x54>
    2c8e:	9e e8       	ldi	r25, 0x8E	; 142
    2c90:	87 2f       	mov	r24, r23
    2c92:	76 2f       	mov	r23, r22
    2c94:	05 c0       	rjmp	.+10     	; 0x2ca0 <__floatsisf+0x5e>
    2c96:	66 23       	and	r22, r22
    2c98:	71 f0       	breq	.+28     	; 0x2cb6 <__floatsisf+0x74>
    2c9a:	96 e8       	ldi	r25, 0x86	; 134
    2c9c:	86 2f       	mov	r24, r22
    2c9e:	70 e0       	ldi	r23, 0x00	; 0
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	2a f0       	brmi	.+10     	; 0x2cae <__floatsisf+0x6c>
    2ca4:	9a 95       	dec	r25
    2ca6:	66 0f       	add	r22, r22
    2ca8:	77 1f       	adc	r23, r23
    2caa:	88 1f       	adc	r24, r24
    2cac:	da f7       	brpl	.-10     	; 0x2ca4 <__floatsisf+0x62>
    2cae:	88 0f       	add	r24, r24
    2cb0:	96 95       	lsr	r25
    2cb2:	87 95       	ror	r24
    2cb4:	97 f9       	bld	r25, 7
    2cb6:	08 95       	ret

00002cb8 <__fp_inf>:
    2cb8:	97 f9       	bld	r25, 7
    2cba:	9f 67       	ori	r25, 0x7F	; 127
    2cbc:	80 e8       	ldi	r24, 0x80	; 128
    2cbe:	70 e0       	ldi	r23, 0x00	; 0
    2cc0:	60 e0       	ldi	r22, 0x00	; 0
    2cc2:	08 95       	ret

00002cc4 <__fp_nan>:
    2cc4:	9f ef       	ldi	r25, 0xFF	; 255
    2cc6:	80 ec       	ldi	r24, 0xC0	; 192
    2cc8:	08 95       	ret

00002cca <__fp_pscA>:
    2cca:	00 24       	eor	r0, r0
    2ccc:	0a 94       	dec	r0
    2cce:	16 16       	cp	r1, r22
    2cd0:	17 06       	cpc	r1, r23
    2cd2:	18 06       	cpc	r1, r24
    2cd4:	09 06       	cpc	r0, r25
    2cd6:	08 95       	ret

00002cd8 <__fp_pscB>:
    2cd8:	00 24       	eor	r0, r0
    2cda:	0a 94       	dec	r0
    2cdc:	12 16       	cp	r1, r18
    2cde:	13 06       	cpc	r1, r19
    2ce0:	14 06       	cpc	r1, r20
    2ce2:	05 06       	cpc	r0, r21
    2ce4:	08 95       	ret

00002ce6 <__fp_round>:
    2ce6:	09 2e       	mov	r0, r25
    2ce8:	03 94       	inc	r0
    2cea:	00 0c       	add	r0, r0
    2cec:	11 f4       	brne	.+4      	; 0x2cf2 <__fp_round+0xc>
    2cee:	88 23       	and	r24, r24
    2cf0:	52 f0       	brmi	.+20     	; 0x2d06 <__fp_round+0x20>
    2cf2:	bb 0f       	add	r27, r27
    2cf4:	40 f4       	brcc	.+16     	; 0x2d06 <__fp_round+0x20>
    2cf6:	bf 2b       	or	r27, r31
    2cf8:	11 f4       	brne	.+4      	; 0x2cfe <__fp_round+0x18>
    2cfa:	60 ff       	sbrs	r22, 0
    2cfc:	04 c0       	rjmp	.+8      	; 0x2d06 <__fp_round+0x20>
    2cfe:	6f 5f       	subi	r22, 0xFF	; 255
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	8f 4f       	sbci	r24, 0xFF	; 255
    2d04:	9f 4f       	sbci	r25, 0xFF	; 255
    2d06:	08 95       	ret

00002d08 <__fp_split3>:
    2d08:	57 fd       	sbrc	r21, 7
    2d0a:	90 58       	subi	r25, 0x80	; 128
    2d0c:	44 0f       	add	r20, r20
    2d0e:	55 1f       	adc	r21, r21
    2d10:	59 f0       	breq	.+22     	; 0x2d28 <__fp_splitA+0x10>
    2d12:	5f 3f       	cpi	r21, 0xFF	; 255
    2d14:	71 f0       	breq	.+28     	; 0x2d32 <__fp_splitA+0x1a>
    2d16:	47 95       	ror	r20

00002d18 <__fp_splitA>:
    2d18:	88 0f       	add	r24, r24
    2d1a:	97 fb       	bst	r25, 7
    2d1c:	99 1f       	adc	r25, r25
    2d1e:	61 f0       	breq	.+24     	; 0x2d38 <__fp_splitA+0x20>
    2d20:	9f 3f       	cpi	r25, 0xFF	; 255
    2d22:	79 f0       	breq	.+30     	; 0x2d42 <__fp_splitA+0x2a>
    2d24:	87 95       	ror	r24
    2d26:	08 95       	ret
    2d28:	12 16       	cp	r1, r18
    2d2a:	13 06       	cpc	r1, r19
    2d2c:	14 06       	cpc	r1, r20
    2d2e:	55 1f       	adc	r21, r21
    2d30:	f2 cf       	rjmp	.-28     	; 0x2d16 <__fp_split3+0xe>
    2d32:	46 95       	lsr	r20
    2d34:	f1 df       	rcall	.-30     	; 0x2d18 <__fp_splitA>
    2d36:	08 c0       	rjmp	.+16     	; 0x2d48 <__fp_splitA+0x30>
    2d38:	16 16       	cp	r1, r22
    2d3a:	17 06       	cpc	r1, r23
    2d3c:	18 06       	cpc	r1, r24
    2d3e:	99 1f       	adc	r25, r25
    2d40:	f1 cf       	rjmp	.-30     	; 0x2d24 <__fp_splitA+0xc>
    2d42:	86 95       	lsr	r24
    2d44:	71 05       	cpc	r23, r1
    2d46:	61 05       	cpc	r22, r1
    2d48:	08 94       	sec
    2d4a:	08 95       	ret

00002d4c <__fp_zero>:
    2d4c:	e8 94       	clt

00002d4e <__fp_szero>:
    2d4e:	bb 27       	eor	r27, r27
    2d50:	66 27       	eor	r22, r22
    2d52:	77 27       	eor	r23, r23
    2d54:	cb 01       	movw	r24, r22
    2d56:	97 f9       	bld	r25, 7
    2d58:	08 95       	ret

00002d5a <__mulsf3>:
    2d5a:	0b d0       	rcall	.+22     	; 0x2d72 <__mulsf3x>
    2d5c:	c4 cf       	rjmp	.-120    	; 0x2ce6 <__fp_round>
    2d5e:	b5 df       	rcall	.-150    	; 0x2cca <__fp_pscA>
    2d60:	28 f0       	brcs	.+10     	; 0x2d6c <__mulsf3+0x12>
    2d62:	ba df       	rcall	.-140    	; 0x2cd8 <__fp_pscB>
    2d64:	18 f0       	brcs	.+6      	; 0x2d6c <__mulsf3+0x12>
    2d66:	95 23       	and	r25, r21
    2d68:	09 f0       	breq	.+2      	; 0x2d6c <__mulsf3+0x12>
    2d6a:	a6 cf       	rjmp	.-180    	; 0x2cb8 <__fp_inf>
    2d6c:	ab cf       	rjmp	.-170    	; 0x2cc4 <__fp_nan>
    2d6e:	11 24       	eor	r1, r1
    2d70:	ee cf       	rjmp	.-36     	; 0x2d4e <__fp_szero>

00002d72 <__mulsf3x>:
    2d72:	ca df       	rcall	.-108    	; 0x2d08 <__fp_split3>
    2d74:	a0 f3       	brcs	.-24     	; 0x2d5e <__mulsf3+0x4>

00002d76 <__mulsf3_pse>:
    2d76:	95 9f       	mul	r25, r21
    2d78:	d1 f3       	breq	.-12     	; 0x2d6e <__mulsf3+0x14>
    2d7a:	95 0f       	add	r25, r21
    2d7c:	50 e0       	ldi	r21, 0x00	; 0
    2d7e:	55 1f       	adc	r21, r21
    2d80:	62 9f       	mul	r22, r18
    2d82:	f0 01       	movw	r30, r0
    2d84:	72 9f       	mul	r23, r18
    2d86:	bb 27       	eor	r27, r27
    2d88:	f0 0d       	add	r31, r0
    2d8a:	b1 1d       	adc	r27, r1
    2d8c:	63 9f       	mul	r22, r19
    2d8e:	aa 27       	eor	r26, r26
    2d90:	f0 0d       	add	r31, r0
    2d92:	b1 1d       	adc	r27, r1
    2d94:	aa 1f       	adc	r26, r26
    2d96:	64 9f       	mul	r22, r20
    2d98:	66 27       	eor	r22, r22
    2d9a:	b0 0d       	add	r27, r0
    2d9c:	a1 1d       	adc	r26, r1
    2d9e:	66 1f       	adc	r22, r22
    2da0:	82 9f       	mul	r24, r18
    2da2:	22 27       	eor	r18, r18
    2da4:	b0 0d       	add	r27, r0
    2da6:	a1 1d       	adc	r26, r1
    2da8:	62 1f       	adc	r22, r18
    2daa:	73 9f       	mul	r23, r19
    2dac:	b0 0d       	add	r27, r0
    2dae:	a1 1d       	adc	r26, r1
    2db0:	62 1f       	adc	r22, r18
    2db2:	83 9f       	mul	r24, r19
    2db4:	a0 0d       	add	r26, r0
    2db6:	61 1d       	adc	r22, r1
    2db8:	22 1f       	adc	r18, r18
    2dba:	74 9f       	mul	r23, r20
    2dbc:	33 27       	eor	r19, r19
    2dbe:	a0 0d       	add	r26, r0
    2dc0:	61 1d       	adc	r22, r1
    2dc2:	23 1f       	adc	r18, r19
    2dc4:	84 9f       	mul	r24, r20
    2dc6:	60 0d       	add	r22, r0
    2dc8:	21 1d       	adc	r18, r1
    2dca:	82 2f       	mov	r24, r18
    2dcc:	76 2f       	mov	r23, r22
    2dce:	6a 2f       	mov	r22, r26
    2dd0:	11 24       	eor	r1, r1
    2dd2:	9f 57       	subi	r25, 0x7F	; 127
    2dd4:	50 40       	sbci	r21, 0x00	; 0
    2dd6:	8a f0       	brmi	.+34     	; 0x2dfa <__mulsf3_pse+0x84>
    2dd8:	e1 f0       	breq	.+56     	; 0x2e12 <__mulsf3_pse+0x9c>
    2dda:	88 23       	and	r24, r24
    2ddc:	4a f0       	brmi	.+18     	; 0x2df0 <__mulsf3_pse+0x7a>
    2dde:	ee 0f       	add	r30, r30
    2de0:	ff 1f       	adc	r31, r31
    2de2:	bb 1f       	adc	r27, r27
    2de4:	66 1f       	adc	r22, r22
    2de6:	77 1f       	adc	r23, r23
    2de8:	88 1f       	adc	r24, r24
    2dea:	91 50       	subi	r25, 0x01	; 1
    2dec:	50 40       	sbci	r21, 0x00	; 0
    2dee:	a9 f7       	brne	.-22     	; 0x2dda <__mulsf3_pse+0x64>
    2df0:	9e 3f       	cpi	r25, 0xFE	; 254
    2df2:	51 05       	cpc	r21, r1
    2df4:	70 f0       	brcs	.+28     	; 0x2e12 <__mulsf3_pse+0x9c>
    2df6:	60 cf       	rjmp	.-320    	; 0x2cb8 <__fp_inf>
    2df8:	aa cf       	rjmp	.-172    	; 0x2d4e <__fp_szero>
    2dfa:	5f 3f       	cpi	r21, 0xFF	; 255
    2dfc:	ec f3       	brlt	.-6      	; 0x2df8 <__mulsf3_pse+0x82>
    2dfe:	98 3e       	cpi	r25, 0xE8	; 232
    2e00:	dc f3       	brlt	.-10     	; 0x2df8 <__mulsf3_pse+0x82>
    2e02:	86 95       	lsr	r24
    2e04:	77 95       	ror	r23
    2e06:	67 95       	ror	r22
    2e08:	b7 95       	ror	r27
    2e0a:	f7 95       	ror	r31
    2e0c:	e7 95       	ror	r30
    2e0e:	9f 5f       	subi	r25, 0xFF	; 255
    2e10:	c1 f7       	brne	.-16     	; 0x2e02 <__mulsf3_pse+0x8c>
    2e12:	fe 2b       	or	r31, r30
    2e14:	88 0f       	add	r24, r24
    2e16:	91 1d       	adc	r25, r1
    2e18:	96 95       	lsr	r25
    2e1a:	87 95       	ror	r24
    2e1c:	97 f9       	bld	r25, 7
    2e1e:	08 95       	ret

00002e20 <__udivmodhi4>:
    2e20:	aa 1b       	sub	r26, r26
    2e22:	bb 1b       	sub	r27, r27
    2e24:	51 e1       	ldi	r21, 0x11	; 17
    2e26:	07 c0       	rjmp	.+14     	; 0x2e36 <__udivmodhi4_ep>

00002e28 <__udivmodhi4_loop>:
    2e28:	aa 1f       	adc	r26, r26
    2e2a:	bb 1f       	adc	r27, r27
    2e2c:	a6 17       	cp	r26, r22
    2e2e:	b7 07       	cpc	r27, r23
    2e30:	10 f0       	brcs	.+4      	; 0x2e36 <__udivmodhi4_ep>
    2e32:	a6 1b       	sub	r26, r22
    2e34:	b7 0b       	sbc	r27, r23

00002e36 <__udivmodhi4_ep>:
    2e36:	88 1f       	adc	r24, r24
    2e38:	99 1f       	adc	r25, r25
    2e3a:	5a 95       	dec	r21
    2e3c:	a9 f7       	brne	.-22     	; 0x2e28 <__udivmodhi4_loop>
    2e3e:	80 95       	com	r24
    2e40:	90 95       	com	r25
    2e42:	bc 01       	movw	r22, r24
    2e44:	cd 01       	movw	r24, r26
    2e46:	08 95       	ret

00002e48 <_exit>:
    2e48:	f8 94       	cli

00002e4a <__stop_program>:
    2e4a:	ff cf       	rjmp	.-2      	; 0x2e4a <__stop_program>
